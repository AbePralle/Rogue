class BCWriter : Visitor
  PROPERTIES
    this_type          : Type
    this_method        : Method

    writer             : Printer

    id_table           = Table<<String,Integer>>()
    id_list            = String[]

    real_table         = Table<<Real,Integer>>()
    real_list          = Real[]

    string_table       = Table<<String,Integer>>()
    string_list        = String[]

    code               = Integer[]

    line_info          = Integer[]
    compact_line_info  = StringBuilder()
    filepath_indices   = Table<<String,Integer>>()
    filenames          = String[]

    # line info tracking reset at the beginning of each method
    starting_ip        : Integer
    tokens             = Token[]

    min_embedded_n = -(2^21)
    max_embedded_n = (2^21)-1

    label_addresses       = Table<<String,Integer>>()
    backpatch_addresses   = Integer[]
    backpatch_labels      = String[]

    omit_method_bodies : Logical

  METHODS
    method compile( filepath:String )
      compile( filepath, null )

    method compile( filepath:String, writer )
      if (not filepath.ends_with(".bc")) filepath += ".bc"

      # Reset 'compiled' flag on all methods
      forEach (m in Analyzer.method_list) m.compiled = false

      id_table.clear
      id_list.clear
      string_table.clear
      string_list.clear

      code.clear
      code.add(Op.halt)  # Invariant: code[0] = HALT
      if (omit_method_bodies) code.add( Op.nop ).add( Op.nop )

      forEach (type in Types) 
        compile( type )
      endForEach

      reset_line_info_for_new_method  # flush encoded line info

      if (not writer) writer = File(filepath).writer
      writer.print( "BARDCODE" )
      writer.write( 0xb0 )
      writer.write( 0x20 )
      writer.write( 0x13 )
      writer.write( 0x06 )
      writer.write( 0x01 )

      write( code.count )
      forEach (n in code) 
        write( n )
      endForEach

      write( id_list.count )
      forEach (id in id_list) write(id)

      write( Types.type_list.count )
      forEach (type in Types.type_list)
        write( id_table[type.name] )
        write( type.attributes.flags )
        write( type.attributes.tags.count )
        forEach (tag in type.attributes.tags) write( id_table[tag] )

        write( type.base_types.count )
        forEach (base_type in type.base_types) write( base_type.index )

        if (type.element_type?) write( type.element_type.index )
        else                    write( -1 )

        write( type.settings_list.count )
        forEach (p in type.settings_list)
          write( id_table[p.name] )
          write( p.type.index )
        endForEach

        write( type.property_list.count )
        forEach (p in type.property_list)
          write( id_table[p.name] )
          write( p.type.index )
        endForEach

      endForEach

      write( Types.main_type.index )

      write( Analyzer.method_list.count )
      forEach (m in Analyzer.method_list) write( m )

      write( Types.type_list.count )
      forEach (type in Types.type_list) write_method_tables( type )

      write( real_list.count )
      forEach (r in real_list) write( r )

      # Convert filepaths to filenames
      forEach (index in filenames.indices) filenames[index] = File(filenames[index]).filename

      write( filenames.count )
      forEach (filename in filenames) write( filename )

      write( compact_line_info.count )
      forEach (n in compact_line_info) writer.write(n)

      write( string_list.count )
      forEach (st in string_list) write(st)

      writer.close

    method reset_line_info_for_new_method->Integer
      if (tokens.count?)
        compile_line_info
      endIf

      tokens.clear
      starting_ip = code.count

      local index = compact_line_info.count
      return index

    method write_code( t:Token, n:Integer )
      if (tokens.count == 0) tokens.add(t)
      while ((tokens.count+starting_ip) < code.count) tokens.add( tokens.last )

      tokens.add( t )
      code.add( n )

    method write_code_with_arg_n( t:Token, opcode:Integer, arg:Integer )
      if (tokens.count == 0) tokens.add(t)
      while ((tokens.count+starting_ip) < code.count) tokens.add( tokens.last )

      tokens.add( t )
      code.add( opcode_with_embedded_n(opcode,arg) )

    method write_jump( t:Token, jump_opcode:Integer, to_label:String )
      backpatch_addresses.add( code.count )
      backpatch_labels.add( to_label )
      write_code( t, jump_opcode )

    method define_label( label:String )
      if (label_addresses.contains(label)) throw BardError( "[Internal] Label already defined: " + label )

      label_addresses[label] = code.count

      # Remove unconditional jumps that jump to the very next address - conditional jumps still 
      # need to consume a stack value.
      while (backpatch_addresses.count? and backpatch_addresses.last == code.count-1 and
          label_addresses.contains(backpatch_labels.last) and label_addresses[backpatch_labels.last] == code.count and
          code[backpatch_addresses.last] == Op.jump_to_offset_n)

        backpatch_addresses.remove_last
        backpatch_labels.remove_last

        local remap_address = code.count
        code.remove_last
        tokens.remove_last

        forEach (key in label_addresses.keys)
          if (label_addresses[key] == remap_address)
            label_addresses[key] = (remap_address - 1)
          endIf
        endForEach
      endWhile


    method backpatch_all( m:Method )
      while (backpatch_labels.count? and label_addresses.contains(backpatch_labels.last))
        local destination_address = label_addresses[ backpatch_labels.remove_last ]
        local starting_address = backpatch_addresses.remove_last
        code[starting_address] = opcode_with_embedded_n( code[starting_address], destination_address - (starting_address+1) )
      endWhile

      if (backpatch_labels.count?)
        throw BardError( "[Internal] Unresolved label during backpatch: " + backpatch_labels.last )
      endIf

      # Fix up try/catch handler addresses
      forEach (handler in m.exception_handlers)
        forEach (c in handler.catches)
          #println( "ASSIGNING CATCH IP:" + label_addresses[c.label_name] )
          c.handler_ip = label_addresses[ c.label_name ]
        endForEach
      endForEach

      label_addresses.clear

    method discard_code( old_count:Integer )
      code.discard_from( old_count )
      tokens.discard_from( old_count )

    method compile( type:Type )
      this_type = type
      collect_id( type.name )
      forEach (tag in type.attributes.tags) collect_id( tag )
      forEach (p in type.property_list) collect_id( p.name )
      forEach (m in type.method_list) compile( m )

    method compile( m:Method )
      if (m.compiled) return
      m.compiled = true

      collect_id( m.name )
      #{
      forEach (param in m.parameters)
        collect_id( param.name )
      endForEach
      }#
      if (m.return_type?)
        collect_id( m.return_type.name )
      endIf

      this_method = m
      m.ip = code.count
      if (omit_method_bodies) m.ip -= 2  # all ip's point to the same NOP
      m.line_info_index = reset_line_info_for_new_method

      # Generate code even if we're discarding method bodies to pick up all the
      # string and real literals (needs to be optimized sometime to collect
      # literals without generating code).
      if (not m.type_context.is_aspect or m.full_signature == "init_settings()")
        if (m.referenced) 
          visit( m )
        endIf
      endIf

      if (m.return_type?)
        if (m.is_initializer or m.attributes.auto_return_this)
          write_code( m.t, Op.return_this )
        else
          write_code( m.t, Op.throw_missing_return )
        endIf
      else
        local t = m.t
        if (m.body.count?) t = m.body.last.t
        if (this_type.is_compound) write_code( t, opcode_with_embedded_n( Op.compound_return_nil_fp_adjust_n, this_type.slot_count) )
        else                       write_code( t, Op.return_nil )
      endIf

      backpatch_all( m )  # resolve all labels

      if (omit_method_bodies) code.discard_from(2)

      # Ensure there's enough room for the VM to rewrite the method body with 
      # a NATIVE_CALL_INDEX_N and NATIVE_RETURN for any native overrides.
      while (code.count - m.ip < 2) write_code( m.t, Op.nop )

      m.ip_limit = code.count

    method collect_id( id:String )->Integer
      if (id_table.contains(id)) return id_table[id]

      local index = id_table.count
      id_table[id] = index
      id_list.add( id )
      return index

    method collect_real( r:Real )->Integer
      if (real_table.contains(r)) return real_table[r]

      local index = real_table.count
      real_table[r] = index
      real_list.add( r )
      return index

    method collect_string( st:String )->Integer
      if (string_table.contains(st)) return string_table[st]

      local index = string_table.count
      string_table[st] = index
      string_list.add( st )
      return index

    method opcode_with_embedded_n( opcode:Integer, n:Integer )->Integer
      return opcode | n:<<:10

    method opcode_with_embedded_a_b( opcode:Integer, a:Integer, b:Integer )->Integer
      return opcode | ((a&0x7fff):<<:10) | ((b&0x7fff):<<:21)

    method write( n:Character )
      write( n->Integer )

    method write( n:Integer )
      if (n >= -64 and n <= 127)
        # %01111111 or %11xxxxxx
        writer.write( n )
      elseIf (n >= 128 and n <= 0xfff)
        # %1000xxxx yyyyyyyy
        writer.write( 0x80 | (n:>>:8) )
        writer.write( n )
      elseIf (n >= 0x1000 and n <= 0xfFFFF)
        # %1001xxxx yyyyyyyy zzzzzzzz
        writer.write( 0x90 | (n:>>:16) )
        writer.write( n:>>:8 )
        writer.write( n )
      elseIf (n >= 0x100000 and n <= 0xfFFFFff)
        # %1010xxxx yyyyyyyy zzzzzzzz aaaaaaaa
        writer.write( 0xa0 | (n:>>:24) )
        writer.write( n:>>:16 )
        writer.write( n:>>:8 )
        writer.write( n )
      else
        # %10110000 xxxxxxxx yyyyyyyy zzzzzzzz aaaaaaaa
        writer.write( 0xb0 )
        writer.write( n:>>:24 )
        writer.write( n:>>:16 )
        writer.write( n:>>:8 )
        writer.write( n )
      endIf

    method write( r:Real )
      local data = Integer64( r )
      write( data.high )
      write( data.low )

    method write( st:String )
      write( st.count )
      forEach (ch in st) write( ch )

    method write_method_tables( type:Type )
      write( type.method_list.count )
      forEach (m in type.method_list)
        if (m.referenced or (m.generic_base_method? and m.generic_base_method.referenced))
          write( m.global_index )
        else
          write( -1 )
        endIf
      endForEach

      write( type.aspects.count )
      forEach (a in type.aspects)
        write( a.index )
        write( a.method_list.count )
        forEach (m in a.method_list)
          write( type.must_find_method(m.signature,m.return_type).global_index )
        endForEach
      endForEach

    method write( m:Method )
      #println( "@$ $::$" (writer.position.to_String(16),m.type_context,m.full_signature))
      write( m.type_context.index )
      write( id_table[m.name] )
      write( m.parameters.count )
      if (m.return_type?) write( m.return_type.index )
      else                write( -1 )
      write( m.locals.count )

      forEach (v in m.locals)
        write( v.type.index )
      endForEach
      write( m.ip )
      write( m.ip_limit )
      write( m.line_info_index )

      write( m.attributes.flags )
      write( m.attributes.tags.count )
      forEach (tag in m.attributes.tags) write( id_table[tag] )

      write( m.exception_handlers.count )
      forEach (cur_handler in m.exception_handlers)
        write( cur_handler.ip_start )
        write( cur_handler.ip_limit )
        write( cur_handler.catches.count )
        forEach (cur_catch in cur_handler.catches)
          write( cur_catch.local_info.type.index )
          write( cur_catch.handler_ip )
          write( cur_catch.local_info.slot_index )
        endForEach
      endForEach

    method next_control_id->String
      return Analyzer.unique_id

    method print
      println( id_list.count + " identifiers" )
      forEach (index in id_list.indices)
        println( "  " + index + " " + id_list[index] )
      endForEach
      println

      println( string_list.count + " strings" )
      forEach (index in string_list.indices)
        println( "  " + index + " " + string_list[index] )
      endForEach
      println

    method compile_line_info
      # FORMAT
      #
      # file_switches
      #
      # forEach (1..file_switches)
      #   filename_index
      #   starting_line_number
      #   ip  # always > any previous IP
      #
      #   delta_count
      #   forEach (1..delta_count)
      #     line_delta
      #     ip_delta
      #   endForEach
      #
      # endForEach

      # Collect token filepaths
      forEach (t in tokens)
        if (not filepath_indices.contains(t.filepath))
          filepath_indices[t.filepath] = filenames.count
          filenames.add( t.filepath )
        endIf
      endForEach

      local file_switches_index = line_info.count
      line_info.add( 0 )

      local cur_filename : String
      local cur_line = 0
      local cur_ip = starting_ip
      local previous_ip = starting_ip
      local delta_count_index = -1
      forEach (t in tokens)
        if ((cur_filename is null) or t.filepath != cur_filename)
          cur_filename = t.filepath
          cur_line = t.line
          line_info[ file_switches_index ] = line_info[ file_switches_index ] + 1
          line_info.add( filepath_indices[cur_filename] )
          line_info.add( cur_line )
          line_info.add( cur_ip )
          previous_ip = cur_ip
          delta_count_index = line_info.count
          line_info.add( 0 )
        else
          if (cur_line != t.line)
            line_info[ delta_count_index ] = line_info[ delta_count_index ] + 1
            line_info.add( t.line - cur_line )
            line_info.add( cur_ip - previous_ip )
            previous_ip = cur_ip
            cur_line = t.line
          endIf
        endIf
        ++cur_ip
      endForEach

      # Transfer unencoded line_info to compact, encoded line_info
      local saved_writer = writer
      writer = compact_line_info
      forEach (n in line_info) write(n)
      line_info.clear
      writer = saved_writer

    method visit( cmd:CmdStatementList )
      Analyzer.context.push_local_scope
      forEach (statement in cmd)
        statement.dispatch( this )
        if (statement.type?)
          if (statement.type.is_primitive or statement.type.is_reference)
            write_code( statement.t, Op.pop_discard )
          else
            write_code( statement.t, opcode_with_embedded_n( Op.pop_discard_count_n, statement.type.slot_count) )
          endIf
        endIf
      endForEach
      Analyzer.context.pop_local_scope

    method visit( cmd:CmdTron )->Cmd
      write_code( cmd.t, Op.trace_on )
      return cmd

    method visit( cmd:CmdTroff )->Cmd
      write_code( cmd.t, Op.trace_off )
      return cmd

    method visit( cmd:CmdReturnNil )->Cmd
      if (this_method.is_initializer)
        write_code( cmd.t, Op.return_this )

      elseIf (this_type.is_compound)
        write_code( cmd.t, opcode_with_embedded_n( Op.compound_return_nil_fp_adjust_n, this_type.slot_count) )

      else
        write_code( cmd.t, Op.return_nil )
      endIf
      return cmd

    method visit( cmd:CmdReturnThis )->Cmd
      write_code( cmd.t, Op.return_this )
      return cmd

    method visit( cmd:CmdReturnValue )->Cmd
      cmd.operand.dispatch( this )
      local operand_type = cmd.operand.type
      local opcode = 0
      local context_slot_count = 0
      local context_type = this_type

      if (this_type.slot_count > 1)
        local delta_fp = this_type.slot_count - operand_type.slot_count

        which (operand_type.classification)
          case Type.reference_type: opcode = Op.compound_return_object_fp_adjust_n
          case Type.real_type:      opcode = Op.compound_return_real_fp_adjust_n
          case Type.integer_type:   opcode = Op.compound_return_integer_fp_adjust_n
          case Type.character_type: opcode = Op.compound_return_integer_fp_adjust_n
          case Type.byte_type:      opcode = Op.compound_return_integer_fp_adjust_n
          case Type.logical_type:   opcode = Op.compound_return_integer_fp_adjust_n
          case Type.compound_type
            write_code( cmd.t, opcode_with_embedded_a_b(Op.compound_return_compound_a_slots_fp_adjust_b, operand_type.slot_count, delta_fp ) )
            return cmd

          others: throw cmd.error( "TODO: CmdReturnValue for type " + operand_type )
        endWhich

        write_code( cmd.t, opcode_with_embedded_n( opcode, delta_fp ) )

      else
        which (operand_type.classification)
          case Type.reference_type: opcode = Op.return_object
          case Type.real_type:      opcode = Op.return_real
          case Type.integer_type:   opcode = Op.return_integer
          case Type.character_type: opcode = Op.return_integer
          case Type.byte_type:      opcode = Op.return_integer
          case Type.logical_type:   opcode = Op.return_integer

          case Type.compound_type
            write_code( cmd.t, opcode_with_embedded_n( Op.return_compound_n_slots, operand_type.slot_count ) )
            return cmd

          others: throw cmd.error( "TODO: CmdReturnValue for type " + operand_type )
        endWhich

        write_code( cmd.t, opcode_with_embedded_n( opcode, context_slot_count ) )
      endIf

      return cmd

    method visit( cmd:CmdSpecializeReference )->Cmd
      cmd.operand = cmd.operand.dispatch( this )
      write_code( cmd.t, opcode_with_embedded_n(Op.specialize_as_type_index_n,cmd.as_type.index) )
      return cmd

    method visit( cmd:CmdConvertIntegerToReal )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_integer_to_real )
      return cmd

    method visit( cmd:CmdConvertRealToInteger )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_real_to_integer )
      return cmd

    method visit( cmd:CmdConvertCharacterToInteger )->Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( cmd:CmdConvertByteToInteger )->Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( cmd:CmdConvertIntegerToCharacter )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_integer_to_character )
      return cmd

    method visit( cmd:CmdConvertIntegerToByte )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.convert_integer_to_byte )
      return cmd

    method visit( cmd:CmdConvertLogicalToInteger )->Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( cmd:CmdIf )->Cmd
      local next_block_index = 2
      cmd.condition.dispatch( this )
      write_jump( cmd.condition.t, Op.jump_if_false_to_offset_n, "next_" + next_block_index + "_" + cmd.control_id )

      cmd.body.dispatch( this )
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      forEach (index in cmd.elseIf_conditions.indices)
        define_label( "next_" + next_block_index + "_" + cmd.control_id )
        ++next_block_index

        local condition = cmd.elseIf_conditions[index]
        condition.dispatch( this )
        write_jump( condition.t, Op.jump_if_false_to_offset_n, "next_" + next_block_index + "_" + cmd.control_id )

        cmd.elseIf_bodies[index].dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
      endForEach

      define_label( "next_" + next_block_index + "_" + cmd.control_id )
      if (cmd.else_body?)
        cmd.else_body.dispatch( this )
      endIf

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdContingent )->Cmd
      cmd.body.dispatch( this )

      if(cmd.satisfied_body?)
        define_label( "satisfied_" + cmd.control_id )
        cmd.satisfied_body.dispatch( this )
      endIf

      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      if(cmd.unsatisfied_body?)
        define_label( "unsatisfied_" + cmd.control_id )
        cmd.unsatisfied_body.dispatch( this )
      endIf

      if(not cmd.satisfied_body?)   define_label( "satisfied_" + cmd.control_id )
      if(not cmd.unsatisfied_body?) define_label( "unsatisfied_" + cmd.control_id )
      define_label("end_" + cmd.control_id)

      return cmd

    method visit( cmd:CmdNecessary )->Cmd
      cmd.operand.dispatch( this )
      write_jump( cmd.t, Op.jump_if_false_to_offset_n, "unsatisfied_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdSufficient )->Cmd
      cmd.operand.dispatch( this )
      write_jump( cmd.t, Op.jump_if_true_to_offset_n, "satisfied_" + cmd.target_id )
      return cmd

      throw cmd.t.error( "No enclosing 'contingent' for 'sufficient' clause." )

    method visit( cmd:CmdEscapeContingent )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdAnonymousBlock )->Cmd
      cmd.body.dispatch( this )
      return cmd

    method visit( cmd:CmdWhile )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "next_iteration_" + cmd.control_id )

      define_label( "body_" + cmd.control_id )
      cmd.body.dispatch( this )

      define_label( "next_iteration_" + cmd.control_id )
      cmd.condition.dispatch( this )

      write_jump( cmd.t, Op.jump_if_true_to_offset_n, "body_" + cmd.control_id )

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdEscapeWhich )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeWhile )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdLoop )->Cmd
      #write_jump( cmd.t, Op.jump_to_offset_n, "loop_" + cmd.control_id)

      define_label( "loop_" + cmd.control_id )
      define_label( "next_iteration_" + cmd.control_id )
      cmd.body.dispatch( this )

      write_jump( cmd.t, Op.jump_to_offset_n, "next_iteration_" + cmd.control_id)

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdTry )->Cmd
      local ip_start = code.count
      cmd.body.dispatch( this )
      local ip_limit = code.count
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      local m = Analyzer.context.this_method
      m.exception_handlers.add( ExceptionHandler(ip_start,ip_limit) )

      local catch_index = 0
      forEach (cur_catch in cmd.catches)
        Analyzer.context.push_local_scope
        Analyzer.add_local( cur_catch.local_info )
        #local label_name = "catch_$_$_$" (cmd.control_id,m.exception_handlers.count-1,catch_index)
        local label_name = "catch_" + cmd.control_id + "_" + (m.exception_handlers.count-1) + "_" + catch_index
        define_label( label_name )
        m.exception_handlers.last.catches.add( ExceptionHandlerCatch(cur_catch.local_info,label_name) )
        cur_catch.body.dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
        Analyzer.context.pop_local_scope
        ++catch_index
      endForEach

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdThrow )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.throw_exception )
      return cmd

    method visit( cmd:CmdEscapeLoop )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeForEach )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeIf )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeTry )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdNextIteration )->Cmd
      write_jump( cmd.t, Op.jump_to_offset_n, "next_iteration_" + cmd.target_id )
      return cmd

    method visit( cmd:CmdLiteralReal )->Cmd
      local integer_value = cmd.value->Integer
      if (integer_value == cmd.value and integer_value >= min_embedded_n and integer_value <= max_embedded_n)
        write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n_as_real, integer_value ) )
      else
        write_code( cmd.t, Op.push_literal_real )
        local real_slot = collect_real( cmd.value )
        write_code( cmd.t, real_slot )
      endIf
      return cmd

    method visit( cmd:CmdLiteralString )->Cmd
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_string_n, collect_string(cmd.value) ) );
      return cmd

    method visit( cmd:CmdLiteralNull )->Cmd
      write_code( cmd.t, Op.push_literal_object_null );
      return cmd

    method visit( cmd:CmdLiteralInteger )->Cmd
      if (cmd.value >= min_embedded_n and cmd.value <= max_embedded_n)
        write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, cmd.value ) )
      else
        write_code( cmd.t, Op.push_literal_integer )
        write_code( cmd.t, cmd.value )
      endIf
      return cmd

    method visit( cmd:CmdLiteralByte )->Cmd
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, cmd.value ) )
      return cmd

    method visit( cmd:CmdLiteralArray )->Cmd
      local t = cmd.t
      local slot_count = cmd.element_type.slot_count
      local element_type_classification = cmd.element_type.classification
      local elements = cmd.elements

      write_code_with_arg_n( t, Op.push_literal_integer_n, cmd.elements.count )  # size arg
      write_code_with_arg_n( t, Op.create_array_type_n, cmd.array_type.index )
      write_code( t, cmd.element_type.index )

      forEach (index in elements.indices)
        # Index to write new value at.
        if (index < max_embedded_n)
          write_code_with_arg_n( t, Op.push_literal_integer_n, index )
        else
          write_code( t, Op.push_literal_integer )
          write_code( t, index )
        endIf

        # Value to store at index
        elements[index].dispatch( this )

        # Determine opcode
        local opcode = -1
        which (element_type_classification)
          case Type.reference_type: opcode = Op.write_array_element_object
          case Type.real_type:      opcode = Op.write_array_element_real
          case Type.integer_type:   opcode = Op.write_array_element_integer
          case Type.character_type: opcode = Op.write_array_element_character
          case Type.byte_type:      opcode = Op.write_array_element_byte
          case Type.logical_type:   opcode = Op.write_array_element_byte
          case Type.compound_type
            write_code_with_arg_n( t, Op.write_array_element_compound_n_slots, slot_count )
            return cmd
          others: throw Error()
        endWhich

        if (opcode != -1) write_code( t, opcode )
      endForEach

      return cmd

    method visit( cmd:CmdLiteralCharacter )->Cmd
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, cmd.value->Integer ) )
      return cmd

    method visit( cmd:CmdLiteralLogical )->Cmd
      local value = 0
      if (cmd.value?) value = 1
      write_code( cmd.t, opcode_with_embedded_n( Op.push_literal_integer_n, value ) )
      return cmd

    method visit( cmd:CmdReadLocal )->Cmd
      local type = cmd.local_info.type

      local opcode = 0
      which (type.classification)
        case Type.reference_type: opcode = Op.read_local_object_n
        case Type.real_type:      opcode = Op.read_local_real_n
        case Type.integer_type:   opcode = Op.read_local_integer_n
        case Type.character_type: opcode = Op.read_local_integer_n
        case Type.byte_type:      opcode = Op.read_local_integer_n
        case Type.logical_type:   opcode = Op.read_local_integer_n
        case Type.compound_type
          local v = cmd.local_info
          write_code( cmd.t, opcode_with_embedded_a_b(Op.read_local_compound_slot_a_size_b,-v.slot_index,v.type.slot_count) )
          return cmd
        others
        throw Error( "TODO: type " + type )
      endWhich
      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.local_info.slot_index) )
      return cmd

    method visit( cmd:CmdWriteLocal )->Cmd
      cmd.new_value.dispatch( this )

      local type = cmd.local_info.type
      local opcode = 0
      which (type.classification)
        case Type.reference_type: opcode = Op.write_local_object_n
        case Type.real_type:      opcode = Op.write_local_real_n
        case Type.integer_type:   opcode = Op.write_local_integer_n
        case Type.character_type: opcode = Op.write_local_integer_n
        case Type.byte_type:      opcode = Op.write_local_integer_n
        case Type.logical_type:   opcode = Op.write_local_integer_n
        case Type.compound_type
          local v = cmd.local_info
          write_code( cmd.t, opcode_with_embedded_a_b(Op.write_local_compound_slot_a_size_b,-v.slot_index,v.type.slot_count) )
          return cmd
        others
          throw Error("TODO")
      endWhich

      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.local_info.slot_index) )
      return cmd

    method visit( cmd:CmdWriteLocalDefault )->Cmd
      local v = cmd.local_info
      local type = v.type
      local opcode = -1
      which (type.classification)
        case Type.reference_type: opcode = Op.clear_local_object_n
        case Type.real_type:      opcode = Op.clear_local_real_n
        case Type.integer_type:   opcode = Op.clear_local_integer_n
        case Type.character_type: opcode = Op.clear_local_integer_n
        case Type.byte_type:      opcode = Op.clear_local_integer_n
        case Type.logical_type:   opcode = Op.clear_local_integer_n
        case Type.compound_type
          write_code( cmd.t, opcode_with_embedded_a_b(Op.clear_local_compound_slot_a_size_b,-v.slot_index,type.slot_count) )
          return cmd
        others
        throw cmd.t.error( "CmdWriteLocalDefault not implemented for type " + type + "." )
        #throw cmd.t.error( "CmdWriteLocalDefault not implemented for type $." (type) )
      endWhich

      write_code( cmd.t, opcode_with_embedded_n(opcode,v.slot_index) )

      return cmd

    method visit( cmd:CmdInstanceOf )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, opcode_with_embedded_n(Op.instance_of_type_index_n,cmd.target_type.index) )
      return cmd

    method visit( cmd:CmdIncrementLocal )->Cmd
      which (cmd.local_info.type.classification)
        case Type.real_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_real_n,cmd.local_info.slot_index) )

        case Type.integer_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_integer_n,cmd.local_info.slot_index) )

        case Type.character_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        case Type.byte_type
          write_code( cmd.t, opcode_with_embedded_n(Op.increment_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        others
        throw cmd.t.error( "Cannot increment a value of type " + cmd.local_info.type.name + "." )
      endWhich

      return cmd

    method write_increment_setting( cmd:CmdIncrementSetting, mask:Integer )
      if (cmd.context?) cmd.context.dispatch( this )

    method visit( cmd:CmdIncrementSetting )->Cmd
      local cmd_t = cmd.t
      local setting_index = cmd.setting.index

      if (cmd.context?)
        cmd.context.dispatch( this )
        if (cmd.context.type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n( Op.pop_discard_count_n, cmd.context.type.slot_count) )
        else
          write_code( cmd_t, Op.pop_discard )
        endIf
      endIf

      local setting_type_index = cmd.setting.type_context.index

      write_code_with_arg_n( cmd_t, Op.resolve_read_setting_index_n, setting_index )
      write_code( cmd_t, setting_type_index )

      which (cmd.setting.type.classification)
        case Type.real_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n_as_real, 1 )
          write_code( cmd_t, Op.add_real )

        case Type.integer_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.add_integer )

        case Type.character_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.add_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 65535 )
          write_code( cmd_t, Op.bitwise_and_integer )

        case Type.byte_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.add_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 255 )
          write_code( cmd_t, Op.bitwise_and_integer )

        others
          #throw cmd_t.error( "Cannot increment a value of type $." (cmd.setting.type) )
          throw cmd.t.error( "Cannot increment a value of type " + cmd.setting.type.name + "." )
      endWhich

      write_code_with_arg_n( cmd.t, Op.resolve_write_setting_index_n, setting_index )
      write_code( cmd.t, setting_type_index )

      return cmd

    method visit( cmd:CmdDecrementSetting )->Cmd
      local cmd_t = cmd.t
      local setting_index = cmd.setting.index

      if (cmd.context?)
        cmd.context.dispatch( this )
        if (cmd.context.type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n( Op.pop_discard_count_n, cmd.context.type.slot_count) )
        else
          write_code( cmd_t, Op.pop_discard )
        endIf
      endIf

      local setting_type_index = cmd.setting.type_context.index

      write_code_with_arg_n( cmd_t, Op.resolve_read_setting_index_n, setting_index )
      write_code( cmd_t, setting_type_index )

      which (cmd.setting.type.classification)
        case Type.real_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n_as_real, 1 )
          write_code( cmd_t, Op.subtract_real )

        case Type.integer_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.subtract_integer )

        case Type.character_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.subtract_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 65535 )
          write_code( cmd_t, Op.bitwise_and_integer )

        case Type.byte_type
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 1 )
          write_code( cmd_t, Op.subtract_integer )
          write_code_with_arg_n( cmd_t, Op.push_literal_integer_n, 255 )
          write_code( cmd_t, Op.bitwise_and_integer )

        others
          #throw cmd_t.error( "Cannot decrement a value of type $." (cmd.setting.type) )
          throw cmd.t.error( "Cannot increment a value of type " + cmd.setting.type.name + "." )
      endWhich

      write_code_with_arg_n( cmd.t, Op.resolve_write_setting_index_n, setting_index )
      write_code( cmd.t, setting_type_index )

      return cmd


    method visit( cmd:CmdIncrementProperty )->Cmd
      if (cmd.context?) cmd.context.dispatch( this )

      local property_index = cmd.property.index
      local classification = cmd.property.type.classification
      which (classification)
        case Type.real_type, Type.integer_type
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_increment_property, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_increment_this_property,property_index )

        case Type.character_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.add_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        case Type.byte_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.add_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        others
          #throw cmd.t.error( "Cannot increment a value of type $." (cmd.property.type) )
          throw cmd.t.error( "Cannot increment a value of type " + cmd.property.type.name + "." )
      endWhich
      return cmd

    method visit( cmd:CmdDecrementLocal )->Cmd
      which (cmd.local_info.type.classification)
        case Type.real_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_real_n,cmd.local_info.slot_index) )

        case Type.integer_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_integer_n,cmd.local_info.slot_index) )

        case Type.character_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        case Type.byte_type
          write_code( cmd.t, opcode_with_embedded_n(Op.decrement_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.read_local_integer_n,cmd.local_info.slot_index) )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.write_local_integer_n,cmd.local_info.slot_index) )

        others
          #throw cmd.t.error( "Cannot decrement a value of type $." (cmd.local_info.type) )
          throw cmd.t.error( "Cannot decrement a value of type " + cmd.local_info.type.name + "." )
      endWhich

      return cmd


    method visit( cmd:CmdDecrementProperty )->Cmd
      if (cmd.context?) cmd.context.dispatch( this )

      local property_index = cmd.property.index
      local classification = cmd.property.type.classification
      which (classification)
        case Type.real_type, Type.integer_type
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_decrement_property, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_decrement_this_property,property_index )

        case Type.character_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.subtract_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,65535) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        case Type.byte_type
          if (cmd.context?)
            write_code( cmd.t, Op.duplicate_object )
            write_code_with_arg_n( cmd.t, Op.resolve_read_property_index_n, property_index )
          else
            write_code_with_arg_n( cmd.t, Op.resolve_read_this_property_index_n, property_index )
          endIf
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,1) )
          write_code( cmd.t, Op.subtract_integer )
          write_code( cmd.t, opcode_with_embedded_n(Op.push_literal_integer_n,255) )
          write_code( cmd.t, Op.bitwise_and_integer )
          if (cmd.context?) write_code_with_arg_n( cmd.t, Op.resolve_write_property_index_n, property_index )
          else              write_code_with_arg_n( cmd.t, Op.resolve_write_this_property_index_n, property_index )

        others
        #throw cmd.t.error( "Cannot decrement a value of type $." (cmd.property.type) )
        throw cmd.t.error( "Cannot decrement a value of type " + cmd.property.type.name + "." )
      endWhich
      return cmd

    method visit( cmd:CmdImplicitCastToType )->Cmd
      throw cmd.t.error( "Internal error - CmdImplicitCastToType" )

    method visit( cmd:CmdNewObject )->Cmd
      write_code( cmd.t, opcode_with_embedded_n(Op.create_object_of_type_index_n,cmd.of_type.index) )
      if (cmd.args?) cmd.args.dispatch( this )
      write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,cmd.init_method.global_index) )
      return cmd

    method visit( cmd:CmdThis )->Cmd
      if (this_type.is_compound)
        write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
      elseIf (this_type.is_primitive)
        if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
        else                   write_code( cmd.t, Op.push_this_integer )
      else
        write_code( cmd.t, Op.push_this )
      endIf
      return cmd

    method visit( cmd:CmdReadSingleton )->Cmd
      cmd.of_type.resolve
      if (cmd.of_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      elseIf (cmd.of_type.is_reference)
        write_code( cmd.t, opcode_with_embedded_n(Op.read_singleton_of_type_index_n,cmd.of_type.index) )
      else
        write_code( cmd.t, opcode_with_embedded_n(Op.read_singleton_compound_of_type_index_n,cmd.of_type.index) )
      endIf
      return cmd

    method visit( cmd:CmdWriteSingleton )->Cmd
      cmd.of_type.resolve
      cmd.new_value.dispatch( this )
      if (cmd.of_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      elseIf (cmd.of_type.is_reference)
        write_code( cmd.t, opcode_with_embedded_n(Op.write_singleton_of_type_index_n,cmd.of_type.index) )
      else
        write_code( cmd.t, opcode_with_embedded_n(Op.write_singleton_compound_of_type_index_n,cmd.of_type.index) )
      endIf
      return cmd

    method visit( cmd:CmdReadSetting )->Cmd
      local setting_type = cmd.setting.type

      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (cmd.context? and cmd.context notInstanceOf CmdReadSingleton)
        # Arbitrary context (non-'this')
        if (cmd.context notInstanceOf CmdReadSingleton)
          cmd.context.dispatch( this )
          if (cmd.context.type.is_compound)
            write_code( cmd.t, opcode_with_embedded_n( Op.pop_discard_count_n, cmd.context.type.slot_count) )
          else
            write_code( cmd.t, Op.pop_discard )
          endIf
        endIf

        write_code( cmd.t, opcode_with_embedded_n(Op.resolve_read_setting_index_n,cmd.setting.index) )

      else
        # Read setting with no context needing discarding.
        write_code( cmd.t, opcode_with_embedded_n(Op.resolve_read_setting_index_n,cmd.setting.index) )
      endIf
      write_code( cmd.t, cmd.setting.type_context.index )

      # Extra arg space for object setting that is a compound
      if (setting_type.is_compound) write_code( cmd.t, Op.halt )

      return cmd

    method visit( cmd:CmdReadProperty )->Cmd
      local opcode = 0

      local property_type = cmd.property.type

      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        # Arbitrary context (non-'this')
        if (context_type.is_compound)
          # Element of a compound
          cmd.context.dispatch( this )
          local delta_sp      = context_type.slot_count - property_type.slot_count
          if (delta_sp?)
            which (property_type.classification)
              case Type.reference_type: opcode = Op.read_compound_object_offset_a_delta_sp_b
              case Type.real_type:      opcode = Op.read_compound_real_offset_a_delta_sp_b
              case Type.integer_type:   opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.character_type: opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.byte_type:      opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.logical_type:   opcode = Op.read_compound_integer_offset_a_delta_sp_b
              case Type.compound_type
                # Replace a compound on the stack with its subset
                write_code( cmd.t, opcode_with_embedded_a_b(Op.read_compound_subset_offset_a_delta_sp_b, cmd.property.slot_index, delta_sp) )
                write_code( cmd.t, property_type.slot_count )  # Element slot size is a separate parameter
                return cmd
            endWhich
            write_code( cmd.t, opcode_with_embedded_a_b(opcode, cmd.property.slot_index, delta_sp) )
          endIf
          return cmd
        else
          # Regular object property
          cmd.context.dispatch( this )
          opcode = Op.resolve_read_property_index_n

          write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.index) )

          # Extra arg space for object property that is a compound
          if (property_type.is_compound) write_code( cmd.t, Op.halt )
        endIf

      else
        # Read 'this' property.
        if (context_type.is_compound)
          which (property_type.classification)
            case Type.reference_type: opcode = Op.read_this_compound_object_offset_n
            case Type.real_type:      opcode = Op.read_this_compound_real_offset_n
            case Type.integer_type:   opcode = Op.read_this_compound_integer_offset_n
            case Type.character_type: opcode = Op.read_this_compound_integer_offset_n
            case Type.byte_type:      opcode = Op.read_this_compound_integer_offset_n
            case Type.logical_type:   opcode = Op.read_this_compound_integer_offset_n
            case Type.compound_type
              # Replace a compound on the stack with its subset
              write_code( cmd.t, opcode_with_embedded_a_b(Op.read_this_compound_subset_offset_a_slot_count_b, ...
                  cmd.property.slot_index, property_type.slot_count) )
              return cmd
          endWhich
          write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.slot_index) )
        else
          opcode = Op.resolve_read_this_property_index_n
          write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.index) )

          if (property_type.is_compound) write_code( cmd.t, cmd.property.type.slot_count )
        endIf
      endIf

      return cmd

    method visit( cmd:CmdWriteSetting )->Cmd
      local is_compound = cmd.setting.type.is_compound
      local opcode = 0

      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        if (cmd.context notInstanceOf CmdReadSingleton)
          cmd.context.dispatch( this )
          if (cmd.context.type.is_compound)
            write_code( cmd.t, opcode_with_embedded_n( Op.pop_discard_count_n, cmd.context.type.slot_count) )
          else
            write_code( cmd.t, Op.pop_discard )
          endIf
        endIf
      endIf

      if (is_compound) opcode = Op.resolve_write_setting_compound_index_n
      else             opcode = Op.resolve_write_setting_index_n

      cmd.new_value.dispatch( this )

      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.setting.index) )
      write_code( cmd.t, cmd.setting.type_context.index )
      if (is_compound) write_code( cmd.t, cmd.setting.type.slot_count )

      return cmd

    method visit( cmd:CmdWriteProperty )->Cmd
      local is_compound = cmd.property.type.is_compound
      local opcode = 0

      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (context_type.is_compound)
        throw cmd.t.error( "Compound properties cannot be individually reassigned.  A new compound must be created using the new properties." )
      endIf

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )

        if (is_compound) opcode = Op.resolve_write_property_compound_index_n
        else             opcode = Op.resolve_write_property_index_n

      else
        opcode = Op.resolve_write_this_property_index_n
      endIf

      cmd.new_value.dispatch( this )

      write_code( cmd.t, opcode_with_embedded_n(opcode,cmd.property.index) )

      if (is_compound) write_code( cmd.t, cmd.property.type.slot_count )

      return cmd

    method visit( cmd:CmdStaticCall )->Cmd
      if (cmd.context?)
        local context_type = cmd.context.type
        context_type.resolve( cmd.t )
        if (context_type.is_compound)
          if (cmd.method_info.name == "create")
            if (cmd.method_info.attributes.is_automatic)
              # The automatic create() method is the one that mirrors/defines the
              # composition of the compound.  Pushing its args on the stack in
              # reverse order to create the compound.
              forEach (arg in cmd.args.reverse_order)
                #println( "Arg $ has slot_index $" (arg.type.name,arg.type.slot_index))
                arg.dispatch( this )
              endForEach
              return cmd
              #else
              #throw cmd.t.error( "TODO: write developer-defined compound create() call" )
            endIf
          endIf
        endIf

        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf

      forEach (arg in cmd.args)
        arg.dispatch( this )
      endForEach

      local m_index = cmd.method_info.global_index
      local op = Op.static_call_to_method_index_n
      if (not cmd.method_info.type_context.is_reference) op = Op.unchecked_static_call_to_method_index_n

      write_code( cmd.t, opcode_with_embedded_n(op,m_index) )

      return cmd


    method visit( cmd:CmdSingletonCall )->Cmd
      local singleton_type = cmd.singleton_type
      singleton_type.resolve( cmd.t )

      if (singleton_type.is_compound)
        if (cmd.method_info.name == "create")
          if (cmd.method_info.attributes.is_automatic)
            # The automatic create() method is the one that mirrors/defines the
            # composition of the compound.  Pushing its args on the stack in
            # reverse order to create the compound.
            forEach (arg in cmd.args.reverse_order)
              arg.dispatch( this )
            endForEach
            return cmd
          endIf
        endIf
      endIf

      if (singleton_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      elseIf (singleton_type.is_reference)
        write_code( cmd.t, opcode_with_embedded_n(Op.read_singleton_of_type_index_n,singleton_type.index) )
      else
        write_code( cmd.t, opcode_with_embedded_n(Op.read_singleton_compound_of_type_index_n,singleton_type.index) )
      endIf

      forEach (arg in cmd.args)
        arg.dispatch( this )
      endForEach

      local m_index = cmd.method_info.global_index
      local op = Op.static_call_to_method_index_n
      if (not cmd.method_info.type_context.is_reference) op = Op.unchecked_static_call_to_method_index_n

      write_code( cmd.t, opcode_with_embedded_n(op,m_index) )

      return cmd


    method visit( cmd:CmdDynamicCall )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf

      forEach (arg in cmd.args)
        arg.dispatch( this )
      endForEach

      local context_type : Type
      contingent
        necessary (cmd.context?)
        context_type = cmd.context.type
        necessary (context_type.is_aspect)
      satisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.aspect_call_with_n_parameter_slots,cmd.method_info.parameter_slot_count) )
        write_code( cmd.t, context_type.index )
      unsatisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.dynamic_call_with_n_parameter_slots,cmd.method_info.parameter_slot_count) )
      endContingent
      write_code( cmd.t, cmd.method_info.local_index )

      return cmd

    method visit( cmd:CmdAdd )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.add_real
      elseIf (type.is_Integer) opcode = Op.add_integer
      else throw cmd.error( "TODO: CmdAdd for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdSubtract )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.subtract_real
      elseIf (type.is_Integer) opcode = Op.subtract_integer
      else throw cmd.error( "TODO: CmdAdd for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdMultiply )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.multiply_real
      elseIf (type.is_Integer) opcode = Op.multiply_integer
      else throw cmd.error( "TODO: CmdMultiply for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdDivide )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.divide_real
      elseIf (type.is_Integer) opcode = Op.divide_real
      else throw cmd.error( "TODO: CmdDivide for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdMod )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.mod_real
      elseIf (type.is_Integer) opcode = Op.mod_integer
      else throw cmd.error( "TODO: CmdMod for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdPower )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)    opcode = Op.power_real
      elseIf (type.is_Integer) opcode = Op.power_integer
      else throw cmd.error( "TODO: CmdPower for type " + type )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseAnd )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.bitwise_and_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseAnd." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseAnd " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseOr )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.bitwise_or_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseOr." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseOr " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseXor )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.bitwise_xor_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseXor." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseXor " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdNegate )->Cmd
      local opcode = 0
      local type = cmd.operand.type
      if (type.is_Real)        opcode = Op.negate_real
      elseIf (type.is_Integer) opcode = Op.negate_integer
      elseIf (type.is_Logical) opcode = Op.negate_logical
      else throw cmd.error( "Unhandled type " + type.name + " in CmdNegate." )
      #else throw cmd.error( "Unhandled type $ in CmdNegate " (type) )

      cmd.operand.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdLogicalize )->Cmd
      cmd.operand.dispatch( this )

      local opcode = 0
      local type = cmd.operand.type
      which (type.classification)
        case Type.reference_type: opcode = Op.logicalize_object
        case Type.real_type:      opcode = Op.logicalize_real
        case Type.integer_type:   opcode = Op.logicalize_integer
        case Type.character_type: opcode = Op.logicalize_integer
        case Type.byte_type:      opcode = Op.logicalize_integer
        case Type.logical_type:   return cmd
        case Type.compound_type
          throw Error("TODO: logicalize compound")
      endWhich

      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseNot )->Cmd
      local opcode = 0
      local type = cmd.operand.type
      if (type.is_Integer) opcode = Op.bitwise_not_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseNot." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseNot " (type) )

      cmd.operand.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseSHL )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.shl_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseSHL." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseSHL " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseSHR )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.shr_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseSHR." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseSHR " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdBitwiseSHRX )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_Integer) opcode = Op.shrx_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdBitwiseSHRX." )
      #else throw cmd.error( "Unhandled type $ in CmdBitwiseSHRX " (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdLogicalAnd )->Cmd
      cmd.lhs.dispatch( this )

      local control_id = next_control_id
      write_jump( cmd.t, Op.if_false_push_false_and_jump_to_offset_n, "end_and_" + control_id )

      cmd.rhs.dispatch( this )
      define_label( "end_and_" + control_id )

      return cmd

    method visit( cmd:CmdLogicalOr )->Cmd
      cmd.lhs.dispatch( this )

      local control_id = next_control_id
      write_jump( cmd.t, Op.if_true_push_true_and_jump_to_offset_n, "end_or_" + control_id )

      cmd.rhs.dispatch( this )
      define_label( "end_or_" + control_id )

      return cmd

    method visit( cmd:CmdLogicalNot )->Cmd
      local opcode = 0
      cmd.operand.dispatch( this )

      which (cmd.operand.type.classification)
        case Type.reference_type: opcode = Op.not_object
        case Type.real_type:      opcode = Op.not_real
        case Type.integer_type:   opcode = Op.not_integer
        case Type.character_type: opcode = Op.not_integer
        case Type.byte_type:      opcode = Op.not_integer
        case Type.logical_type:   opcode = Op.logical_not
        case Type.compound_type
          throw cmd.t.error( "Invalid operand - 'not' cannot be applied to a compound type." )
        others: throw Error()
      endWhich

      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdLogicalXor )->Cmd
      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, Op.logical_xor )
      return cmd

    method visit( cmd:CmdCompareEQ )->Cmd
      local opcode = 0
      which (cmd.lhs.type.classification)
        case Type.real_type:      opcode = Op.eq_real
        case Type.integer_type:   opcode = Op.eq_integer
        case Type.character_type: opcode = Op.eq_integer
        case Type.byte_type:      opcode = Op.eq_integer
        case Type.logical_type:   opcode = Op.eq_integer
        others:                   throw cmd.error( "Unhandled type " + cmd.lhs.type.name + " in CmdCompareEQ." )
        #others:                   throw cmd.error( "Unhandled type $ in CmdCompareEQ" (cmd.lhs.type) )
      endWhich

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareIs )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_reference) opcode = Op.is_object
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareIs." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareIs" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareNE )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.ne_real
      elseIf (type.is_Integer)   opcode = Op.ne_integer
      elseIf (type.is_Character) opcode = Op.ne_integer
      elseIf (type.is_Logical)   opcode = Op.ne_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareNE." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareNE" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareIsNot )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if (type.is_reference) opcode = Op.is_not_object
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareIsNot." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareIsNot" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareLT )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.lt_real
      elseIf (type.is_Integer)   opcode = Op.lt_integer
      elseIf (type.is_Character) opcode = Op.lt_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareLT." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareLT" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareLE )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.le_real
      elseIf (type.is_Integer)   opcode = Op.le_integer
      elseIf (type.is_Character) opcode = Op.le_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareLE." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareLE" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareGT )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.gt_real
      elseIf (type.is_Integer)   opcode = Op.gt_integer
      elseIf (type.is_Character) opcode = Op.gt_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareGT." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareGT" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCompareGE )->Cmd
      local opcode = 0
      local type = cmd.lhs.type
      if     (type.is_Real)      opcode = Op.ge_real
      elseIf (type.is_Integer)   opcode = Op.ge_integer
      elseIf (type.is_Character) opcode = Op.ge_integer
      else throw cmd.error( "Unhandled type " + type.name + " in CmdCompareGE." )
      #else throw cmd.error( "Unhandled type $ in CmdCompareGE" (type) )

      cmd.lhs.dispatch( this )
      cmd.rhs.dispatch( this )
      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdCreateArray )->Cmd
      cmd.size_expression.dispatch( this )
      write_code_with_arg_n( cmd.t, Op.create_array_type_n, cmd.array_type.index )
      write_code( cmd.t, cmd.element_type.index )
      return cmd

    method visit( cmd:CmdArrayCount )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.array_count )
      return cmd

    method visit( cmd:CmdReadArrayElement )->Cmd
      cmd.operand.dispatch( this )
      cmd.index_expression.dispatch( this )

      local opcode = -1
      which (cmd.element_type.classification)
        case Type.reference_type: opcode = Op.read_array_element_object
        case Type.real_type:      opcode = Op.read_array_element_real
        case Type.integer_type:   opcode = Op.read_array_element_integer
        case Type.character_type: opcode = Op.read_array_element_character
        case Type.byte_type:      opcode = Op.read_array_element_byte
        case Type.logical_type:   opcode = Op.read_array_element_byte
        case Type.compound_type
          write_code_with_arg_n( cmd.t, Op.read_array_element_compound_n_slots, cmd.element_type.slot_count )
          return cmd
        others: throw Error()
      endWhich

      write_code( cmd.t, opcode )
      return cmd

    method visit( cmd:CmdWriteArrayElement )->Cmd
      cmd.operand.dispatch( this )
      cmd.index_expression.dispatch( this )
      cmd.new_value.dispatch( this )

      local opcode = -1
      which (cmd.element_type.classification)
        case Type.reference_type: opcode = Op.write_array_element_object
        case Type.real_type:      opcode = Op.write_array_element_real
        case Type.integer_type:   opcode = Op.write_array_element_integer
        case Type.character_type: opcode = Op.write_array_element_character
        case Type.byte_type:      opcode = Op.write_array_element_byte
        case Type.logical_type:   opcode = Op.write_array_element_byte
        case Type.compound_type
          write_code_with_arg_n( cmd.t, Op.write_array_element_compound_n_slots, cmd.element_type.slot_count )
          return cmd
        others: throw Error()
      endWhich

      write_code( cmd.t, opcode )

      return cmd

    method visit( cmd:CmdFunction )->Cmd
      throw cmd.t.error( "Functions are only valid as arguments to methods that accept delegates." )
endClass

