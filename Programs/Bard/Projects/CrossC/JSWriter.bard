class JSWriter : Visitor
  PROPERTIES
    show_source = false : Logical

    this_type    : Type
    this_method  : Method

    writer       : Printer

    id_table     = Table<<String,String>>()

    indent       : Integer
    needs_indent : Logical
    previous_cmd_is_return : Logical

    project_prefix  = "Bard"
    setting_prefix  = ""
    property_prefix = ""

  METHODS
    method compile( filepath:String )
      project_prefix = Analyzer.target_rules.prefix

      local use_html_wrapper = filepath.ends_with(".html")
      writer = File(filepath).writer
      if (use_html_wrapper) writer.println( "<html><body><script type='text/javascript'>" )

      # Write $[code] defined in Custom.js
      if (Analyzer.target_rules.code.count?)
        writeln( "//-----------------------------------------------------------------------------" )
        writeln( "// $[code] defined in $." ('$',Analyzer.target_rules.filepath) )
        writeln( "//-----------------------------------------------------------------------------" )
        writeln( Analyzer.target_rules.code->String )
      endIf

      # Find max #args used in dynamic dispatch
      local max_args = 0
      forEach (m in Analyzer.method_list)
        if (m.overridden)
          local args = m.parameters.count
          if (args > max_args) max_args = args
        endIf
      endForEach

      # Write out dynamic dispatch methods
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Dynamic Dispatch Functions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (arg_count in 0..max_args)
        write( "function " )
        write( project_prefix )
        write( "_dispatch_" )
        write( "" + arg_count )
        write( "( index, context" )
        forEach (index in 1..arg_count)
          write( ", arg" )
          write( ""+index )
        endForEach
        writeln( " )" )
        writeln( "{" )
        write(   "  return context.dispatch_table[index]( context" )
        forEach (index in 1..arg_count)
          write( ", arg" )
          write( ""+index )
        endForEach
        writeln( " );" )
        writeln( "}" )
        writeln

      endForEach
      writeln

      # Write out method definitions as global functions.
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Method Definitions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (m in Analyzer.method_list)
        this_type = m.type_context
        if (m.inline_mapping?) nextIteration
        if (this_type.is_compound and m.attributes.is_automatic) nextIteration # create() method

        this_method = m
        if (m.attributes.is_native) write( "// NATIVE " )
        write( "function " )
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )

        local parameter_count = m.parameters.count
        write( "( THIS" )

        if (parameter_count? or this_type.is_functional)
          forEach (param in m.parameters)
            write( ", " )
            write( param.x_name )
          endForEach
        endIf
        write " )"

        writeln

        if (not m.attributes.is_native)
          writeln( "{" )

          if (not m.type_context.is_aspect or m.full_signature == "init_settings()")
            m = m.x_method
            if (m.referenced)
              indent = 2
              needs_indent = true

              # Write all local variable declarations
              if (m.locals.count > m.parameters.count)
                write( "var " );
                local first = true
                forEach (i in m.parameters.count..<m.locals.count)
                  if (first) first = false
                  else       write ", "
                  write m.locals[i].x_name
                endForEach
                writeln ";"
              endIf

#writeln( "console.log('$');" (m.context_signature) )
              visit( m )

              if (not previous_cmd_is_return and m.return_type?)
                if (m.is_initializer or m.attributes.auto_return_this)
                  writeln( "return THIS;" )
                else
                  write( project_prefix )
                  writeln( "_throw_missing_return();" );
                endIf
              endIf
            endIf
          endIf

          indent -= 2
          writeln( "}" )
        endIf
        writeln
      endForEach


      # Write out type definitions
      indent = 0
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Type Definitions" )
      writeln( "//-----------------------------------------------------------------------------" )
      forEach (type in Types.type_list)
        if (type.settings_list.count?)
          write( "var " )
          write( project_prefix )
          write( type.x_name )
          writeln( "Settings = new function()" )
          writeln( "{" )
          indent += 2
          forEach (setting in type.settings_list)
            write( "this." )
            write( setting_prefix )
            write( setting.x_name )
            write( " = " )
            write_default_value_for_type( type )
            writeln( ";" )
          endForEach
          indent -= 2
          writeln( "};" )
          writeln
        endIf

        if (not type.is_native)
          write( "function " )
          write( project_prefix )
          write( type.x_name )
          writeln( "()" )
          writeln( "{" )
          indent += 2

          write( "this.type_name = " );
          write_literal( type.name )
          writeln( ";" )
          writeln

          if (type.property_list.count?)
            forEach (p in type.property_list) write_property_def( "this.", p )
            writeln
          endIf

          indent -= 2
          writeln( "}" )
          writeln
        endIf

        local must_create_table = true
        if (not type.is_functional)
          forEach (m in type.method_list)
            m = m.x_method
            if (m.inline_mapping?) nextIteration
            if (m.referenced and (m.prior_method? or m.overridden))
              if (must_create_table)
                write( project_prefix )
                write( type.x_name )
                writeln( ".prototype.dispatch_table = [];" )
                must_create_table = false
              endIf

              write( project_prefix )
              write( type.x_name )
              write( ".prototype.dispatch_table[" )
              write( "" + m.local_index )
              write( "] = " )
              write( project_prefix )
              write( m.type_context.x_type.x_name )
              write( "__" )
              write( m.x_signature )
              writeln( ";" )
            endIf
          endForEach
        endIf

        writeln
      endForEach

      # Singleton setup
      indent = 0
      writeln( "//-----------------------------------------------------------------------------" )
      writeln( "// Singletons" )
      writeln( "//-----------------------------------------------------------------------------" )

      forEach (type in Types.type_list)
        write( "var " )
        write( project_prefix )
        write( type.x_name )
        write( "_singleton" )
        write( " = " )
        if (type.is_primitive or type.is_compound or type.is_native)
          write_default_value_for_type( type )
        else
          write( " new " )
          write( project_prefix )
          write( type.x_name )
          write( "()" )
        endIf
        writeln(";")
      endForEach
      writeln

      writeln( "// Init settings" )
      forEach (type in Types.type_list)
        if (not type.is_aspect)
          local m = type.x_type.find_method( "init_settings()" )
          if (m? and m.type_context is type)
            m = m.x_method
            if (m.referenced)
              write( project_prefix )
              write( type.x_name )
              writeln( "__init_settings();" )
            endIf
          endIf
        endIf
      endForEach
      writeln

      writeln( "// Init defaults on true singletons" )
      forEach (type in Types.type_list)
        if (type.attributes.is_singleton)
          local m = type.x_type.find_method( "init_defaults()" )
          if (m?)
            m = m.x_method
            if (m.referenced)
              write_static_call( m )
              write( project_prefix )
              write( type.x_name )
              write( "_singleton" )
              writeln( " );" )
            endIf
          endIf
        endIf
      endForEach
      writeln

      writeln( "// Call init() on non-main true singletons" )
      forEach (type in Types.type_list)
        if (type.attributes.is_singleton and type isNot Types.main_type)
          local m = type.x_type.find_method( "init()" )
          if (m?)
            m = m.x_method
            if (m.referenced)
              write_static_call( m )
              write( project_prefix )
              write( type.x_name )
              write( "_singleton" )
              writeln( " );" )
            endIf
          endIf
        endIf
      endForEach
      writeln

      write( "function " )
      write( project_prefix )
      write( "_init_main_object()" )
      writeln( "{" )
      indent += 2
      local has_init_defaults = write_static_call( Types.main_type.x_type.find_method("init_defaults()") );
      local has_init = write_static_call( Types.main_type.x_type.find_method("init()") );

      write( project_prefix )
      write( Types.main_type.x_name )
      write( "_singleton" )

      if (has_init) write( " )" )
      if (has_init_defaults) write( " )" )

      writeln( ";" )
      indent -= 2
      writeln( "}" )

      writeln
      if (use_html_wrapper) writer.println( "</script></body></html>" )

      writer.close

    method write_static_call( m:Method )->Logical
      if (m is null) return false
      write( project_prefix )
      write( m.type_context.x_name )
      write( "__" )
      write( m.x_signature )
      write( "( " )
      return true

    method write_default_value_for_type( type:Type )
      which (type.classification)
        case Type.reference_type: write( "null" )
        case Type.real_type:      write( "0" )
        case Type.integer_type:   write( "0" )
        case Type.character_type: write( "0" )
        case Type.byte_type:      write( "0" )
        case Type.logical_type:   write( "false" )
        case Type.compound_type
          write( "{" )
          local first = true
          forEach (sub_property in type.property_list)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( sub_property.x_name )
            write( "':" )
            write_default_value_for_type( sub_property.type )
          endForEach
          write( "}" )
        others
          throw Error("TODO")
      endWhich

    method write_property_def( base_name:String, property:Property )
      write( base_name )
      write( property_prefix )
      write( property.x_name )
      write( " = " )
      write_default_value_for_type( property.type )
      writeln( ";" )
      #{
      local classification = property.type.classification
      if (classification == Type.compound_type)
        base_name += property.x_name + "_"
        forEach (sub_property in property.type.property_list)
          write_property_def( base_name, sub_property )
        endForEach
      else
        write( base_name )
        write( property.x_name )
        write( " = " )
        write_default_value_for_type( property.type )
        writeln( ";" )
      endIf
      }#

    method generate_temporary_local_name->String
      return "temp_" + Analyzer.unique_id

    method x_name( st:String )->String
      # Returns "st" as a valid identifier - the "cross compile name" or "x name".
      local result = id_table[ st ]
      if (result?) return result

      if (st.ends_with("()")) st = st.leftmost(-2)
      result = Analyzer.convert_string_to_valid_identifier( st )
      id_table[st] = result
      return result

    method write( st:String )
      if (needs_indent)
        needs_indent = false
        forEach (sp in 1..indent) writer.print(' ')
      endIf
      writer.print(st)

    method write_literal( st:String )
      if (st is null)
        writer.print( "null" )
      else
        writer.print( '"' )
        forEach (ch in st)
          if (ch >= 32 and ch <= 126)
            which (ch)
              case '\\': writer.print( "\\\\" )
              case '"':  writer.print( "\\\"" )
              others:    writer.print( ch )
            endWhich
          else
            if (ch < 256)
              which (ch)
                case '\0': writer.print("\\0")
                case    8: writer.print("\\b")
                case   12: writer.print("\\f")
                case '\n': writer.print("\\n")
                case '\r': writer.print("\\r")
                case '\t': writer.print("\\t")
                case   11: writer.print("\\v")
                others
                  writer.print( "\\x" )
                  writer.print( ch->Integer.to_hex_string(2) )
              endWhich
            else
              writer.print( "\\u" )
              writer.print( ch->Integer.to_hex_string(4) )
            endIf
          endIf
        endForEach
        writer.print( '"' )
      endIf

    method writeln( st:String )
      write( st )
      writeln

    method writeln
      writer.println
      needs_indent = true

    method visit( cmd:CmdStatementList )
      Analyzer.context.push_local_scope
      previous_cmd_is_return = false
      forEach (statement in cmd) 
        previous_cmd_is_return = false
        statement.dispatch( this )
        if (statement notInstanceOf CmdControlStructure and statement notInstanceOf CmdLocalDeclaration)
          write( ";" )
        endIf
        #{
        if (show_source)
          write( " /*" )
          write( statement.type_name )
          write( ": " )
          write( statement.to_String )
          write( "*/" )
        endIf
        }#
        writeln
      endForEach
      Analyzer.context.pop_local_scope

    method visit( cmd:CmdLocalDeclaration )->Cmd
      #write( "var " )
      #write( cmd.local_info.x_name )
      return cmd

      #{
    method visit( cmd:CmdTron )->Cmd
      write_code( cmd.t, Op.trace_on )
      return cmd

    method visit( cmd:CmdTroff )->Cmd
      write_code( cmd.t, Op.trace_off )
      return cmd
      }#

    method visit( cmd:CmdReturnNil )->Cmd
      previous_cmd_is_return = true
      if (this_method.is_initializer)
        write( "return THIS" )

      elseIf (this_type.is_compound)
        write( "return" )

      else
        write( "return" )
      endIf
      return cmd

    method visit( cmd:CmdReturnThis )->Cmd
      previous_cmd_is_return = true
      writeln( "return THIS;" );
      return cmd

    method visit( cmd:CmdReturnValue )->Cmd
      write( "return " )
      cmd.operand.dispatch( this )
      previous_cmd_is_return = true
      return cmd

    method visit( cmd:CmdSpecializeReference )->Cmd
      cmd.operand = cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertIntegerToReal )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertRealToInteger )->Cmd
      write( "(" )
      cmd.operand.dispatch( this )
      write( "|0)" )
      return cmd

    method visit( cmd:CmdConvertCharacterToInteger )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertByteToInteger )->Cmd
      cmd.operand.dispatch( this )
      # No actual operator is required
      return cmd

    method visit( cmd:CmdConvertIntegerToCharacter )->Cmd
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdConvertIntegerToByte )->Cmd
      write( "(" )
      cmd.operand.dispatch( this )
      write( "&255)" )
      return cmd

    method visit( cmd:CmdConvertLogicalToInteger )->Cmd
      write( "(" )
      cmd.operand.dispatch( this )
      write( "&1)" )
      return cmd

    method visit( cmd:CmdIf )->Cmd
      if (cmd.control_id_used_in_nested_code)
        write( "label_" )
        write cmd.control_id
        writeln( ":" )
      endIf
      write( "if (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )

      forEach (index of cmd.elseIf_conditions)
        local condition = cmd.elseIf_conditions[index]
        write( "else if (" )
        condition.dispatch( this )
        writeln( ")" )
        writeln( "{" )
        indent += 2
        cmd.elseIf_bodies[index].dispatch( this )
        indent -= 2
        writeln( "}" )
      endForEach

      if (cmd.else_body?)
        writeln( "else" )
        writeln( "{" )
        indent += 2
        cmd.else_body.dispatch( this )
        indent -= 2
        writeln( "}" )
      endIf

      previous_cmd_is_return = false

      return cmd

      #{
      if (cmd.control_id_used_in_nested_code)
        write( "label_" )
        write cmd.control_id
        writeln( ":" )
      endIf
      write( "while (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )
      previous_cmd_is_return = false
      }#

    method visit( cmd:CmdContingent )->Cmd
      if (cmd.control_id_used_in_nested_code)
        write( "label_" )
        write cmd.control_id
        writeln( ":" )
      endIf

      writeln( "{" )
      indent += 2

      write( "necessary_" )
      write cmd.control_id
      writeln( ":" )

      writeln( "{" )
      indent += 2

      write( "sufficient_" )
      write cmd.control_id
      writeln( ":" )

      writeln( "{" )
      indent += 2

      cmd.body.dispatch( this )

      indent -= 2
      writeln( "}" )

      if(cmd.satisfied_body?) cmd.satisfied_body.dispatch( this )
      write( "break label_" )
      write( cmd.control_id )
      writeln( ";" )

      indent -= 2
      writeln( "}" )

      if(cmd.unsatisfied_body?) cmd.unsatisfied_body.dispatch( this )
      write( "break label_" )
      write( cmd.control_id )
      writeln( ";" )

      indent -= 2
      writeln( "}" )

      return cmd

    method visit( cmd:CmdNecessary )->Cmd
      write( "if ( !(" )
      cmd.operand.dispatch( this )
      write( ") ) break necessary_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdSufficient )->Cmd
      write( "if (" )
      cmd.operand.dispatch( this )
      write( ") break sufficient_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeContingent )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdAnonymousBlock )->Cmd
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )
      return cmd

    method visit( cmd:CmdWhile )->Cmd
      if (cmd.control_id_used_in_nested_code)
        write( "label_" )
        write cmd.control_id
        writeln( ":" )
      endIf
      write( "while (" )
      cmd.condition.dispatch( this )
      writeln( ")" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )
      previous_cmd_is_return = false
      return cmd

    method visit( cmd:CmdEscapeWhile )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdLoop )->Cmd
      if (cmd.control_id_used_in_nested_code)
        write( "label_" )
        write cmd.control_id
        writeln( ":" )
      endIf
      writeln( "for (;;)" )
      writeln( "{" )
      indent += 2
      cmd.body.dispatch( this )
      indent -= 2
      writeln( "}" )

      previous_cmd_is_return = false

      return cmd

      #{
    method visit( cmd:CmdTry )->Cmd
      cmd.control_id = next_control_id

      local ip_start = code.count
      cmd.body.dispatch( this )
      local ip_limit = code.count
      write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )

      local m = Analyzer.context.this_method
      m.exception_handlers.add( ExceptionHandler(ip_start,ip_limit) )

      local catch_index = 0
      forEach (cur_catch in cmd.catches)
        Analyzer.context.push_local_scope
        Analyzer.add_local( cur_catch.local_info )
        local label_name = "catch_$_$_$" (cmd.control_id,m.exception_handlers.count-1,catch_index)
        define_label( label_name )
        m.exception_handlers.last.catches.add( ExceptionHandlerCatch(cur_catch.local_info,label_name) )
        cur_catch.body.dispatch( this )
        write_jump( cmd.t, Op.jump_to_offset_n, "end_" + cmd.control_id )
        Analyzer.context.pop_local_scope
        ++catch_index
      endForEach

      define_label( "end_" + cmd.control_id )

      return cmd

    method visit( cmd:CmdThrow )->Cmd
      cmd.operand.dispatch( this )
      write_code( cmd.t, Op.throw_exception )
      return cmd
      }#

    method visit( cmd:CmdEscapeLoop )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeForEach )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeIf )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdEscapeTry )->Cmd
      write( "break label_" )
      write( cmd.target_id )
      return cmd

    method visit( cmd:CmdNextIteration )->Cmd
      write( "continue label_" )
      write( cmd.target_id )
      return cmd

    method format_string( value:Real, decimal_digits:Integer )->String
      return StringBuilder().print(value,decimal_digits)->String

    method visit( cmd:CmdLiteralReal )->Cmd
      local fractional_part = Math.abs(cmd.value) - Math.floor( Math.abs(cmd.value) )
      forEach (decimal_digits in 1..9)
        local magnitude = 10.0 ^ decimal_digits
        if (fractional_part == (fractional_part*magnitude)->Integer / magnitude)
          write( format_string( cmd.value, decimal_digits) )
          return cmd
        endIf
      endForEach

      if (cmd.value == pi)
        write( "Math.PI" );
      else
        write( format_string( cmd.value, decimal_digits) )  # KLUDGE
      endIf

      #throw cmd.t.error( "TODO: real " + cmd.value )
      #write( "TODO:int64_bits_to_real(0x..." )
      #write( (cmd.value as Int64).to_String(16) )
      #write( ")" )

      return cmd

    method visit( cmd:CmdLiteralString )->Cmd
      write_literal( cmd.value )
      return cmd

    method visit( cmd:CmdLiteralNull )->Cmd
      write( "null" )
      return cmd

    method visit( cmd:CmdLiteralInteger )->Cmd
      write( ""+cmd.value )
      return cmd

    method visit( cmd:CmdLiteralByte )->Cmd
      write( ""+cmd.value )
      return cmd

    method visit( cmd:CmdLiteralArray )->Cmd
      write( "[" )

      local first = true
      forEach (element in cmd.elements)
        if (first) first = false
        else       write(",")
        element.dispatch( this )
      endForEach

      write( "]" )

      return cmd

    method visit( cmd:CmdLiteralCharacter )->Cmd
      write( ""+cmd.value->Integer )
      return cmd

    method visit( cmd:CmdLiteralLogical )->Cmd
      if (cmd.value) write( "true" )
      else           write( "false" )
      return cmd

    method visit( cmd:CmdReadLocal )->Cmd
      write( cmd.local_info.x_name )
      return cmd

    method visit( cmd:CmdWriteLocal )->Cmd
      #if (cmd.local_info.type.is_compound)
      #else
        write( cmd.local_info.x_name )
        write( " = " )
        cmd.new_value.dispatch( this )
      #endIf
      return cmd

    method visit( cmd:CmdWriteLocalDefault )->Cmd
      write( cmd.local_info.x_name )
      write( " = " )
      local v = cmd.local_info
      local type = v.type
      local opcode = -1
      which (type.classification)
        case Type.reference_type: write( "null" )
        case Type.real_type:      write( "0" )
        case Type.integer_type:   write( "0" )
        case Type.character_type: write( "0" )
        case Type.byte_type:      write( "0" )
        case Type.logical_type:   write( "false" )
        case Type.compound_type
          write_default_value_for_type( type )
        others
        throw cmd.t.error( "CmdWriteLocalDefault not implemented for type " + type + "." )
      endWhich

      return cmd

    method visit( cmd:CmdInstanceOf )->Cmd
      cmd.operand.dispatch( this )
      write( ".instance_of(" )
      write( project_prefix )
      write( cmd.target_type.x_type.x_name )
      write( ")" )
      return cmd

    method visit( cmd:CmdAssign )->Cmd
      cmd.operand.dispatch( this )
      write( " = " )
      cmd.new_value.dispatch( this )
      return cmd

    method visit( cmd:CmdIncrementLocal )->Cmd
      which (cmd.local_info.type.classification)
        case Type.character_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " + 1 ) & 655335" )

        case Type.byte_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " + 1 ) & 255" )

        others
          write( "++" )
          write( cmd.local_info.x_name )
      endWhich
      return cmd

    method visit( cmd:CmdIncrementSetting )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
        writeln(";")
      endIf

      write( "++" )
      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "Settings." )
      write( setting_prefix )
      write( cmd.setting.x_name )

      which (cmd.setting.type.classification)
        case Type.character_type
          write( project_prefix )
          write( cmd.setting.type_context.x_name )
          write( "Settings." )
          write( setting_prefix )
          write( cmd.setting.x_name )
          write( " &= 65535" )

        case Type.byte_type
          write( project_prefix )
          write( cmd.setting.type_context.x_name )
          write( "Settings." )
          write( setting_prefix )
          write( cmd.setting.x_name )
          write( " &= 255" )

      endWhich

      return cmd

    method visit( cmd:CmdDecrementSetting )->Cmd
      if (cmd.context?)
        cmd.context.dispatch( this )
        writeln(";")
      endIf

      write( "--" )
      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "Settings." )
      write( setting_prefix )
      write( cmd.setting.x_name )

      which (cmd.setting.type.classification)
        case Type.character_type
          write( project_prefix )
          write( cmd.setting.type_context.x_name )
          write( "Settings." )
          write( setting_prefix )
          write( cmd.setting.x_name )
          write( " &= 65535" )

        case Type.byte_type
          write( project_prefix )
          write( cmd.setting.type_context.x_name )
          write( "Settings." )
          write( setting_prefix )
          write( cmd.setting.x_name )
          write( " &= 255" )

      endWhich

      return cmd

    method visit( cmd:CmdIncrementProperty )->Cmd
      if (cmd.context?)
        which (cmd.property.type.classification)
          case Type.character_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " + 1) & 65535" )

          case Type.byte_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " + 1) & 255" )

          others
            write( "++" )
            if (cmd.context?) cmd.context.dispatch( this )
            else              write_this
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
        endWhich
      else
        write( "++THIS." )
        write( property_prefix )
        write( cmd.property.x_name )
      endIf
      return cmd

    method visit( cmd:CmdDecrementLocal )->Cmd
      which (cmd.local_info.type.classification)
        case Type.character_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " - 1 ) & 655335" )

        case Type.byte_type
          write( cmd.local_info.x_name )
          write( " = (" )
          write( cmd.local_info.x_name )
          write( " - 1 ) & 255" )

        others
          write( "--" )
          write( cmd.local_info.x_name )
      endWhich
      return cmd


    method visit( cmd:CmdDecrementProperty )->Cmd
      if (cmd.context?)
        which (cmd.property.type.classification)
          case Type.character_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " - 1) & 65535" )

          case Type.byte_type
            local temp_name = generate_temporary_local_name
            write( "var " )
            write( temp_name )
            write( " = " )
            cmd.context.dispatch( this )
            writeln( ";" )

            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " = (" )
            write( temp_name )
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
            write( " - 1) & 255" )

          others
            write( "--" )
            if (cmd.context?) cmd.context.dispatch( this )
            else              write_this
            write( "." )
            write( property_prefix )
            write( cmd.property.x_name )
        endWhich
      else
        write( "--THIS." )
        write( property_prefix )
        write( cmd.property.x_name )
      endIf
      return cmd

    method visit( cmd:CmdNewObject )->Cmd
      local m = cmd.init_method.x_method
      if (cmd.of_type.new_object_inline_mappings?)
        local mapping = cmd.of_type.new_object_inline_mappings[ m.signature ]
        if (mapping?)
          write_inline_code( cmd.t, mapping, null, cmd.args )
          return cmd
        endIf
      endIf

      write( project_prefix )
      write( m.type_context.x_type.x_name )
      write( "__" )
      write( m.x_signature )
      write( "( " )

      local m = cmd.of_type.x_type.find_method( "init_defaults()" )

      if (m?)
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
      endIf

      write( "new " )
      write( project_prefix )
      write( cmd.of_type.x_type.x_name )
      write( "()" )

      if (m?) write( " )" )

      if (cmd.args?)
        forEach (arg in cmd.args)
          write( ", " )
          arg.dispatch( this )
        endForEach
      endIf
      write( " )" )

      return cmd

    method this_reference->String
      if (this_type.is_compound)
        return "THIS"
      elseIf (this_type.is_primitive or this_type.attributes.is_functional)
        return "THIS"
      else
        return "THIS"
      endIf

    method write_this
      if (this_type.is_compound)
        write( "THIS" )
      elseIf (this_type.is_primitive or this_type.attributes.is_functional)
        write( "THIS" )
      else
        write( "THIS" )
      endIf

    method write_context( context:Cmd )
      if (context?)
        context.dispatch( this )
      else
        write_this
      endIf

    method visit( cmd:CmdThis )->Cmd
      write_this
      return cmd

    method visit( cmd:CmdReadSingleton )->Cmd
      if (cmd.of_type.is_aspect)
        throw cmd.t.error( "Illegal reference - aspects do not have singleton objects." )
      else
        write( project_prefix )
        write( cmd.of_type.x_type.x_name )
        write( "_singleton" )
      endIf
      return cmd

    method visit( cmd:CmdWriteSingleton )->Cmd
      throw cmd.t.error( "TODO" )

    method visit( cmd:CmdReadSetting )->Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
        writeln
      endIf

      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "Settings." )
      write( setting_prefix )
      write( cmd.setting.x_name )

      return cmd


    method visit( cmd:CmdReadProperty )->Cmd
      write_context( cmd.context )

      write(".")
      write( property_prefix )
      write( cmd.property.x_name )

      return cmd


    method visit( cmd:CmdWriteSetting )->Cmd
      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
        writeln
      endIf

      write( project_prefix )
      write( cmd.setting.type_context.x_name )
      write( "Settings." )
      write( setting_prefix )
      write( cmd.setting.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )

      return cmd

    method visit( cmd:CmdWriteProperty )->Cmd
      local context_type : Type
      if (cmd.context?) context_type = cmd.context.type
      else              context_type = this_type

      if (context_type.is_compound)
        throw cmd.t.error( "Compound properties cannot be individually reassigned.  A new compound must be created using the new properties." )
      endIf

      if (cmd.context? and cmd.context notInstanceOf CmdThis)
        cmd.context.dispatch( this )
      else
        write_this
      endIf
      write( "." )
      write( property_prefix )

      write( cmd.property.x_name )
      write( " = " )
      cmd.new_value.dispatch( this )

      return cmd

    method write_inline_code( t:Token, code:String, context:Cmd, args:CmdArgs )
      local marker = code.locate( '$' )
      while (marker >= 0)
        local i = marker + 1
        local arg_index = code[i].to_number 

        ++i
        while (i < code.count and code[i].is_number)
          arg_index = arg_index * 10 + code[i].to_number
          ++i
        endWhile

        write( code.leftmost(marker) )

        if (arg_index == 0)
          if (context?) context.dispatch( this )
          else          write_this
        elseIf (arg_index <= args.count)
          args[arg_index-1].dispatch( this )
        else
          throw t.error( "Error mapping inline code: index $ is out of range (must be 0..$)." (arg_index,args.count) )
        endIf

        code = code.substring(i)
        marker = code.locate( '$' )
      endWhile
      write( code )

    method write_function_call( m:Method, context:Cmd, args:CmdArgs )
      local buffer = StringBuilder()
      buffer.print( m.type_context.x_type.x_name )
      buffer.print( "__" )
      buffer.print( m.x_signature )
      local signature = buffer.to_String

      which (signature)
        case "Math__floor__Real"
          write( "Math.floor( " )
          args.first.dispatch( this )
          write( " )" )

        case "Math__sqrt__Real"
          write( "Math.sqrt( " )
          args.first.dispatch( this )
          write( " )" )

        case "Properties__add__Real", "Properties__add__Logical", "Properties__add__Properties", "Properties__add__String"
          write_context( context )
          write ".push("
          args.first.dispatch( this )
          write ")"

        case "Properties__get__Integer", "Properties__get__String"
          write_context( context )
          write "["
          args.first.dispatch( this )
          write "]"

        case "Properties__set__Integer_Properties",
             "Properties__set__Integer_Integer",
             "Properties__set__Integer_Logical",
             "Properties__set__Integer_Real",
             "Properties__set__Integer_String",
             "Properties__set__String_Properties",
             "Properties__set__String_Integer",
             "Properties__set__String_Logical",
             "Properties__set__String_Real",
             "Properties__set__String_String"
          write_context( context )
          write "["
          args[0].dispatch( this )
          write "] = "
          args[1].dispatch( this )

        case "Properties__to_String"
          write "JSON.stringify("
          write_context( context )
          write ")"

        case "PropertyList__create"
          write "[]"

        case "PropertyTable__create"
          write "{}"

        case "String__count"
          write_context( context )
          write( ".length" )

        case "String__get__Integer"
          write_context( context )
          write( ".charCodeAt( " )
          args.first.dispatch( this )
          write( " )" )

        others
          write( project_prefix )
          write( signature )

          if (context?)
            if (m.name == "create" and (args is null or args.count == 0))
              write( "()" )
              return
            else
              write( "( " )
              local context_type = context.type
              context.dispatch( this )
            endIf
          else
            write( "( " )
            write_this
          endIf

          if (args?)
            forEach (arg in args)
              write( ", " )
              arg.dispatch( this )
            endForEach
          endIf
          write(" )")
      endWhich

      #local m_index = cmd.method_info.global_index
      #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )


    method visit( cmd:CmdStaticCall )->Cmd
      local m = cmd.method_info.x_method
      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, cmd.context, cmd.args )
        return cmd
      endIf

      local type_context = m.type_context.x_type

      if (type_context.is_compound and m.attributes.is_automatic)
        # Create compound
        write( "{" )
        if (cmd.args?)
          local first = true
          local i = 0
          forEach (arg in cmd.args)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( type_context.property_list[i].x_name )
            write( "':" )
            arg.dispatch( this )
            ++i
          endForEach
        endIf
        write( "}" )
      elseIf (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, cmd.context, cmd.args )
      else
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
        if (cmd.context?) cmd.context.dispatch( this )
        else              write_this
        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf
        write(" )")

        #local m_index = cmd.method_info.global_index
        #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )
      endIf

      return cmd


    method visit( cmd:CmdSingletonCall )->Cmd
      local m = cmd.method_info.x_method
      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, CmdReadSingleton(cmd.t,cmd.singleton_type), cmd.args )
        return cmd
      endIf

      local type_context = m.type_context.x_type

      if (type_context.is_compound and m.attributes.is_automatic)
        # Create compound
        write( "{" )
        if (cmd.args?)
          local first = true
          local i = 0
          forEach (arg in cmd.args)
            if (first) first = false
            else       write( "," )
            write( "'" )
            write( property_prefix )
            write( type_context.property_list[i].x_name )
            write( "':" )
            arg.dispatch( this )
            ++i
          endForEach
        endIf
        write( "}" )
      elseIf (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, CmdReadSingleton(cmd.t,cmd.singleton_type), cmd.args )
      else
        write( project_prefix )
        write( m.type_context.x_type.x_name )
        write( "__" )
        write( m.x_signature )
        write( "( " )
        write( project_prefix )
        write( cmd.singleton_type.x_name )
        write( "_singleton" )
        if (cmd.args? and cmd.args.count?)
          forEach (arg in cmd.args)
            write( ", " )
            arg.dispatch( this )
          endForEach
        endIf
        write(" )")

        #local m_index = cmd.method_info.global_index
        #write_code( cmd.t, opcode_with_embedded_n(Op.static_call_to_method_index_n,m_index) )
      endIf

      return cmd

    method visit( cmd:CmdDynamicCall )->Cmd
      local m = cmd.method_info.x_method

      if (m.inline_mapping?) 
        write_inline_code( cmd.t, m.inline_mapping, cmd.context, cmd.args )
        return cmd
      endIf

      local type_context = m.type_context

      if (type_context.is_primitive or type_context.is_functional)
        write_function_call( m, cmd.context, cmd.args )

      else
        if (m.type_context.is_reference)
          write( project_prefix )
          write( "_dispatch_" + m.parameters.count )
          write( "( " )
          write( m.local_index + ", " )

          if (cmd.context?) cmd.context.dispatch(this)
          else              write_this

          if (cmd.args? and cmd.args.count?)
            forEach (arg in cmd.args)
              write( ", " )
              arg.dispatch( this )
            endForEach
          endIf
          write(" )")
        else
          throw Error("TODO")
        endIf
      endIf

      #{
      if (cmd.context?)
        cmd.context.dispatch( this )
      else
        if (this_type.is_compound)
          write_code( cmd.t, opcode_with_embedded_n(Op.push_this_compound_n_slots,this_type.slot_count) )
        elseIf (this_type.is_primitive)
          if (this_type.is_Real) write_code( cmd.t, Op.push_this_real )
          else                   write_code( cmd.t, Op.push_this_integer )
        else
          write_code( cmd.t, Op.push_this )
        endIf
      endIf


      local context_type : Type
      contingent
        necessary (cmd.context?)
        context_type = cmd.context.type
        necessary (context_type.is_aspect)
      satisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.aspect_call_with_n_parameters,cmd.method_info.parameters.count) )
        write_code( cmd.t, context_type.index )
      unsatisfied
        write_code( cmd.t, opcode_with_embedded_n(Op.dynamic_call_with_n_parameters,cmd.method_info.parameters.count) )
      endContingent
      write_code( cmd.t, cmd.method_info.local_index )
      }#

      return cmd

    method visit( cmd:CmdConcatenateStrings )->Cmd
      if (cmd.lhs.type.instance_of(Types.type_String) and cmd.rhs.type.instance_of(Types.type_String))
        write( "(" )
        cmd.lhs.dispatch( this )
        write( " + " )
        cmd.rhs.dispatch( this )
        write( ")" )
      else
        cmd.builder = cmd.builder.dispatch( this )
      endIf
      return cmd

    method visit( cmd:CmdAdd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " + " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdSubtract )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " - " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdMultiply )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " * " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdDivide )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " / " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdMod )->Cmd
      write( project_prefix )
      if (cmd.lhs.type.is_Real) write( "_mod_real( " )
      else                      write( "_mod_integer( " )
      cmd.lhs.dispatch( this )
      write( ", " )
      cmd.rhs.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdPower )->Cmd
      write( "Math.pow( " )
      cmd.lhs.dispatch( this )
      write( ", " )
      cmd.rhs.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdBitwiseAnd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " & " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseOr )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " | " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseXor )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " ^ " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdNegate )->Cmd
      write( "-" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdLogicalize )->Cmd
      write( "!!" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseNot )->Cmd
      write( "~" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdBitwiseSHL )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " << " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseSHR )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >>> " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdBitwiseSHRX )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >> " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalAnd )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " && " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalOr )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " || " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdLogicalNot )->Cmd
      write( "!" )
      cmd.operand.dispatch( this )
      return cmd

    method visit( cmd:CmdLogicalXor )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " ^ " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareIs )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " == " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareEQ )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " == " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareNE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " != " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareIsNot )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " != " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareLT )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " < " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareLE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " <= " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareGT )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " > " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCompareGE )->Cmd
      write( "(" )
      cmd.lhs.dispatch( this )
      write( " >= " )
      cmd.rhs.dispatch( this )
      write( ")" )
      return cmd

    method visit( cmd:CmdCreateArray )->Cmd
      which (cmd.element_type.x_type.classification)
        case Type.reference_type: write( "new Array( " )
        case Type.real_type:      write( "new Float64Array( " )
        case Type.integer_type:   write( "new Int32Array( " )
        case Type.character_type: write( "new Uint16Array( " )
        case Type.byte_type:      write( "new Unit8Array( " )
        case Type.logical_type:   write( "new Uint8Array( " )
        case Type.compound_type:  write( "new Array( " )
      endWhich
      cmd.size_expression.dispatch( this )
      write( " )" )
      return cmd

    method visit( cmd:CmdArrayCount )->Cmd
      cmd.operand.dispatch( this )
      write( ".length" )
      return cmd

    method visit( cmd:CmdReadArrayElement )->Cmd
      if (cmd.element_type.is_Logical) write( "!!" )
      cmd.operand.dispatch( this )
      write( "[" )
      cmd.index_expression.dispatch( this )
      write( "]" )
      return cmd

    method visit( cmd:CmdWriteArrayElement )->Cmd
      cmd.operand.dispatch( this )
      write( "[" )
      cmd.index_expression.dispatch( this )
      write( "] = " )
      cmd.new_value.dispatch( this )
      return cmd
endClass

