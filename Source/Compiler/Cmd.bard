class Cmd
  PROPERTIES
    t : Token

  METHODS
    method cast_to( target_type:Type )->Cmd
      local this_type = type
      if (this_type is target_type) return this

      #if (this_type.is_primitive)
      #throw t.error( "TODO: Cmd::cast_to() primitive->...." )
      #else
      # this is a reference type
      if (this_type.instance_of(target_type))
        return CmdCastToType( t, this, target_type )
      else
        this_type.organize
        local m_name = "to_" + target_type.name
        if (this_type.has_method_named(m_name))
          return CmdAccess( t, this, m_name )
        endIf
        throw t.error( "Type $ is not instance of required type $." (this_type,target_type) )
      endIf
      #endIf

    method clone( clone_args=null:CloneArgs )->Cmd
      throw t.error( "[INTERNAL] $::clone() is not implemented." (type_name) )

    method clone( other:Cmd, clone_args=null:CloneArgs )->Cmd
      if (other?) return other.clone( clone_args )
      return null

    method clone( args:CmdArgs, clone_args=null:CloneArgs )->CmdArgs
      if (args?) return args.clone( clone_args )
      return null

    method clone( statements:CmdStatementList, clone_args=null:CloneArgs )->CmdStatementList
      if (statements?) return statements.clone( clone_args )
      return null

    method combine_literal_operands( common_type:Type )->Cmd
      return this

    method compile_type->Type
      return type.compile_type

    method exit_scope( scope:Scope )

    method find_common_type( left_type:Type, right_type:Type )->Type
      if (left_type is right_type) return left_type

      if (left_type.is_primitive)
        if (right_type.is_primitive)
          if (left_type is Program.type_Real or right_type is Program.type_Real) return Program.type_Real
          if (left_type is Program.type_Float or right_type is Program.type_Float) return Program.type_Float
          if (left_type is Program.type_Long or right_type is Program.type_Long) return Program.type_Long
          if (left_type is Program.type_Integer or right_type is Program.type_Integer) return Program.type_Integer
          if (left_type is Program.type_Character or right_type is Program.type_Character) return Program.type_Character
        endIf
      endIf

      throw t.error( "Types $ and $ are incompatible." (left_type,right_type) )

    method implicit_type->Type
      return null

    method is_literal->Logical
      return false

    method postmodify( count:Integer )->Cmd
      throw t.error( "Illegal target; ++ and -- can only be applied to variables." )

    method premodify( count:Integer )->Cmd
      throw t.error( "Illegal target; ++ and -- can only be applied to variables." )

    method set_modifiers( access:CmdAccessWithModify )->Cmd
      if (access.modified)
        throw t.error( "Illegal target; ++ and -- can only be applied to variables." )
      endIf
      return this

    method print_cpp( writer:CPPWriter )
      throw t.error( "[INTERNAL] $::print_cpp() is not defined." (type_name) )

    method print_cpp_statement( writer:CPPWriter )
      print_cpp( writer )

    method require_type_context
      if (type?) throw t.error( //Type name expected, e.g. "$.".// (type) )
      else       throw t.error( //Type name expected.// )

    method require_integer->Cmd
      local _type = type
      if (_type is null or _type isNot Program.type_Integer)
        throw t.error( "Integer value expected." )
      endIf
      return this

    method require_logical->Cmd
      local _type = type
      if (_type is null or _type isNot Program.type_Logical)
        throw t.error( "Logical value expected." )
      endIf
      return this

    method require_type->Type
      local result = type
      if (result is null) throw t.error( "Value expected; this statement or expression does not result in a value." )
      return result

    method require_value->Cmd
      require_type
      return this

    method requires_semicolon->Logical
      return true

    method resolve( scope:Scope )->Cmd
      throw t.error( "[INTERNAL] $::resolve() is not defined." (type_name) )
      return this

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      throw t.error( "Invalid assignment." )

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      throw t.error( "Invalid assignment." )

    method type->Type
      throw t.error( "[INTERNAL] $::type() is not defined." (type_name) )

endClass

#------------------------------------------------------------------------------
# StatementList
#------------------------------------------------------------------------------
class CmdStatementList : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Integer)
      prior.init( initial_capacity )

    method init( statement:Cmd )
      init
      add( statement )

    method init( statement1:Cmd, statement2:Cmd )
      init
      add( statement1 ).add( statement2 )

      #{
    method has_side_effects->Logical
      forEach (cmd in this)
        if (cmd.has_side_effects) return true
      endForEach
      return false
      }#

    method clone( clone_args:CloneArgs )->CmdStatementList
      local result = CmdStatementList( count )
      forEach (cmd in this) result.add( cmd.clone(clone_args) )
      return result

      #{
    method dispatch( v:Visitor ) [propagated]
      v.visit( this )

    method print( buffer:StringBuilder )
      Analyzer.context.push_local_scope
      forEach (statement in this)
        buffer.print( "      " )
        buffer.print( statement.type_name )
        buffer.print( " " )
        statement.print( buffer )
        buffer.println
      endForEach
      Analyzer.context.pop_local_scope
      }#

    method print_cpp( writer:CPPWriter )
      forEach (statement in this)
        statement.print_cpp_statement( writer )
        if (statement.requires_semicolon) writer.println ";"
      endForEach

    method resolve( scope:Scope )
      forEach (i of this)
        this[i] = this[i].resolve( scope )
      endForEach

      forEach (statement in this) statement.exit_scope( scope )
endClass


#------------------------------------------------------------------------------
# Args
#------------------------------------------------------------------------------
class CmdArgs : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Integer)
      prior.init( initial_capacity )

    method init( arg:Cmd )
      init
      add( arg )

    method init( arg1:Cmd, arg2:Cmd )
      init
      add( arg1 ).add( arg2 )

    method clone( clone_args=null:CloneArgs )->CmdArgs
      local result = CmdArgs( count )
      forEach (cmd in this) result.add( cmd.clone(clone_args) )
      return result

    method print_cpp( writer:CPPWriter )
      local first = true
      forEach (arg in this)
        if (first) first = false
        else       writer.print(",")
        arg.print_cpp( writer )
      endForEach

    method resolve( scope:Scope )
      forEach (i of this)
        local arg = this[i].resolve( scope )
        this[i] = arg
        arg.require_type.organize
      endForEach
endClass


#------------------------------------------------------------------------------
# Statements
#------------------------------------------------------------------------------
class CmdStatement : Cmd
endClass

class CmdNoAction : Cmd
endClass

class CmdLocalDeclaration : CmdStatement
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLocalDeclaration( t, local_info )

    method exit_scope( scope:Scope )
      scope.pop_local

    method print_cpp( writer:CPPWriter )
      writer.print( local_info.type ).print(" ").print( local_info.cpp_name ).print(" = ")
      if (local_info.initial_value?)
        writer.print( "(" ).print_cast( local_info.initial_value.type, local_info.type )
        local_info.initial_value.print_cpp( writer )
        writer.print( ")" )
      else
        writer.print_default_value( local_info.type )
      endIf

    method resolve( scope:Scope )->Cmd
      scope.push_local( local_info )

      if (local_info.initial_value?)
        local_info.initial_value = local_info.initial_value.resolve( scope )
        local initial_value_type = local_info.initial_value.require_type
        if (local_info.type is null) local_info.type = initial_value_type
      endIf

      if (local_info.type is null)
        throw t.error( "Cannot determine type of local variable - either assign an initial value (local $ = ...) or assign a type (local $ : Integer)." (local_info.name,local_info.name) )
      endIf

      local_info.type.organize

      return this
endClass


class CmdReturn : CmdStatement
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value=null )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdReturn( t, clone(value,clone_args) )

    method print_cpp( writer:CPPWriter )
      if (value?)
        writer.print "return "
        value.print_cpp( writer )
      else
        writer.print "return"
      endIf

    method resolve( scope:Scope )->Cmd
      if (value?)
        if (not scope.this_method.return_type)
          throw t.error( "$ is not declared as returning a value." (scope.this_method.signature) )
        endIf
        value = value.resolve( scope ).cast_to( scope.this_method.return_type ).resolve( scope )
      endIf
      return this

    method type->Type
      return value.type
endClass


#------------------------------------------------------------------------------
# Control Structures
#------------------------------------------------------------------------------
class CmdControlStructure : CmdStatement
  PROPERTIES
    statements : CmdStatementList

  METHODS
    method init( t )
      statements = CmdStatementList()

    method requires_semicolon->Logical
      return false
endClass


class CmdBlock : CmdControlStructure
  PROPERTIES
    statements : CmdStatementList

  METHODS
    method init( t )
      statements = CmdStatementList()

    method init( t, statements )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBlock( t, statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->CmdBlock
      statements.resolve( scope )
      return this
endClass


class CmdIf : CmdControlStructure
  PROPERTIES
    condition           : Cmd
    else_ifs            : CmdElseIf[]
    else_statements     : CmdStatementList

  METHODS
    method init( t )
      statements = CmdStatementList()

    method init( t, condition, statements, else_ifs, else_statements )

    method clone( clone_args=null:CloneArgs )->Cmd
      local cloned_else_ifs : CmdElseIf[]
      if (else_ifs?)
        cloned_else_ifs = CmdElseIf[]( else_ifs.count )
        forEach (e in else_ifs)
          cloned_else_ifs.add( e.clone(clone_args) )
        endForEach
      endIf

      return CmdIf( t, condition.clone(clone_args), statements.clone(clone_args), cloned_else_ifs, clone(else_statements,clone_args) )

    method add( cmd_else_if:CmdElseIf )
      if (else_ifs is null) else_ifs = CmdElseIf[]
      else_ifs.add( cmd_else_if )

    method print_cpp( writer:CPPWriter )
      writer.print( "if (" )
      condition.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

      if (else_ifs?)
        forEach (else_if in else_ifs)
          else_if.print_cpp( writer )
        endForEach
      endIf

      if (else_statements?)
        writer.println( "else" )
        writer.println( "{" )
        writer.indent += 2
        else_statements.print_cpp( writer )
        writer.indent -= 2
        writer.println( "}" )
      endIf

    method resolve( scope:Scope )->CmdIf
      condition = condition.resolve( scope ).require_logical
      statements.resolve( scope )
      if (else_ifs?)
        forEach (else_if in else_ifs) else_if.resolve( scope )
      endIf
      if (else_statements?) else_statements.resolve( scope )
      return this
endClass


class CmdElseIf
  PROPERTIES
    cmd_if     : CmdIf
    condition  : Cmd
    statements : CmdStatementList

  METHODS
    method init( cmd_if )
      statements = CmdStatementList()

    method init( cmd_if, condition, statements )

    method clone( clone_args=null:CloneArgs )->CmdElseIf
      return CmdElseIf( cmd_if, condition.clone(clone_args), statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "else if (" )
      condition.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )
      condition = condition.resolve( scope ).require_logical
      statements.resolve( scope )
endClass


class CmdWhile : CmdControlStructure
  PROPERTIES
    expression : Cmd

  METHODS
    method init( t )
      statements = CmdStatementList()

    method init( t, expression, statements )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdWhile( t, expression.clone(clone_args), statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "while (" )
      expression.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      expression = expression.resolve( scope )
      statements.resolve( scope )
      return this
endClass


class CmdForEachInRange : CmdControlStructure
  PROPERTIES
    control_var : Local
    last_var    : Local
    step_cmd    : Cmd

  METHODS
    method init( t, control_var, last_var, step_cmd, statements=CmdStatementList() )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdForEachInRange( t, control_var, last_var, clone(step_cmd,clone_args), statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "for (; " ).print( control_var.cpp_name ).print( "<=" ).print( last_var.cpp_name ).print( "; " )
      step_cmd.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      step_cmd = step_cmd.resolve( scope )
      statements.resolve( scope )
      return this
endClass

class CmdForEachInCollection : CmdControlStructure
  PROPERTIES
    control_var_name : String
    index_var_name   : String
    collection       : Cmd
    step_cmd         : Cmd

  METHODS
    method init( t, control_var_name, index_var_name, collection, step_cmd, statements=CmdStatementList() )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdForEachInCollection( t, control_var_name, index_var_name, collection.clone(clone_args), clone(step_cmd,clone_args), statements.clone(clone_args) )

    method resolve( scope:Scope )->Cmd
      collection = collection.resolve( scope )
      local collection_type = collection.require_type.organize

      local has_count = (collection_type.find_property("count")? or collection_type.find_method("count()")?)
      local m_at  = collection_type.find_method("at(Integer)")
      local m_get = collection_type.find_method("get(Integer)")
      local has_get = m_get? or m_at?

      local step_size = 1
      if (step_cmd?)
        step_cmd = step_cmd.resolve( scope )
        local literal_integer_cmd = step_cmd as CmdLiteralInteger
        if (literal_integer_cmd?)
          step_size = literal_integer_cmd.value
        else
          throw step_cmd.t.error( "Literal integer value expected." )
        endIf
      endIf

      if (has_count and has_get)
        if (m_at?) m_get = m_at  # prefer at(Integer) over get(Integer)

        local cmd_block = CmdBlock(t)

        local collection_var = scope.this_method.add_local( t, Program.create_unique_id )
        cmd_block.statements.add( CmdLocalDeclaration(collection.t,collection_var) )
        collection_var.initial_value = collection

        local index_var = scope.this_method.add_local( t, index_var_name, Program.type_Integer )
        local last_cmd : Cmd
        cmd_block.statements.add( CmdLocalDeclaration(collection.t,index_var) )
        if (step_size >= 0)
          index_var.initial_value = CmdLiteralInteger( t, 0 )
          last_cmd = CmdAccess( t, CmdReadLocal(t,collection_var), "count" )
        else
          local args = CmdArgs()
          index_var.initial_value = CmdSubtract( t, CmdAccess(t,CmdReadLocal(t,collection_var), "count"), CmdLiteralInteger(t,1) )
          last_cmd = CmdLiteralInteger( t, 0 )
        endIf

        local control_var = scope.this_method.add_local( t, control_var_name )

        if (step_size >= -1 and step_size <= 1)
          statements.add( CmdReadLocal(t,index_var).premodify(step_size) )
        elseIf (step_size >= 0)
          statements.add(CmdOpWithAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_plus_equals,CmdLiteralInteger(t,step_size)))
        else
          statements.add(CmdOpWithAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_minus_equals,CmdLiteralInteger(t,-step_size)))
        endIf

        statements.insert( CmdLocalDeclaration(control_var.t,control_var) )
        local args = CmdArgs()
        args.add( CmdReadLocal(t, index_var) )
        control_var.initial_value = CmdAccess( t, CmdReadLocal(t,collection_var), m_get.name, args )

        cmd_block.statements.add( CmdForEachInIndexedCollection( t, index_var, control_var, collection_var, last_cmd, step_size, statements ) )
        return cmd_block.resolve( scope )

      else
        # commandBlock
        #   local reader = expression
        #   while (reader.has_another)
        #     local control_var = reader.read
        #     statements
        #   endWhile
        local has_another = (collection_type.find_property("has_another")? or collection_type.find_method("has_another()")?)
        local m_read  = collection_type.find_method("read()")

        local cmd_block = CmdBlock(t)

        local reader_var = scope.this_method.add_local( t, Program.create_unique_id )
        cmd_block.statements.add( CmdLocalDeclaration(collection.t,reader_var) )
        reader_var.initial_value = collection

        local control_var = scope.this_method.add_local( t, control_var_name )
        statements.insert( CmdLocalDeclaration(control_var.t,control_var) )
        control_var.initial_value = CmdAccess( t, CmdReadLocal(t,reader_var), "read", CmdArgs() )

        cmd_block.statements.add( CmdForEachInReader( t, reader_var, control_var, statements ) )
        return cmd_block.resolve( scope )

      endIf
      return this
endClass

class CmdForEachInIndexedCollection : CmdControlStructure
  PROPERTIES
    index_var        : Local
    control_var      : Local
    collection_var   : Local
    last_cmd         : Cmd
    step_size        : Integer

  METHODS
    method init( t, index_var, control_var, collection_var, last_cmd, step_size, statements=CmdStatementList() )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdForEachInIndexedCollection( t, index_var, control_var, collection_var, last_cmd.clone(clone_args), step_size, statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "while (" ).print( index_var.cpp_name )
      if (step_size >= 0) writer.print( " < " )
      else                writer.print( " >= " )
      last_cmd.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      statements.resolve( scope )
      last_cmd = last_cmd.resolve( scope )
      return this
endClass


class CmdForEachInReader : CmdControlStructure
  PROPERTIES
    reader_var  : Local
    control_var : Local
    condition   : Cmd

  METHODS
    method init( t, reader_var, control_var, statements=CmdStatementList() )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdForEachInReader( t, reader_var, control_var, statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "while (" )
      condition.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      statements.resolve( scope )
      condition = CmdAccess( reader_var.t, CmdReadLocal(reader_var.t,reader_var), "has_another" ).resolve( scope )
      return this
endClass


class CmdForEachOfCollection : CmdControlStructure
  PROPERTIES
    control_var_name : String
    collection       : Cmd
    step_cmd         : Cmd

  METHODS
    method init( t, control_var_name, collection, step_cmd, statements=CmdStatementList() )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdForEachOfCollection( t, control_var_name, collection.clone(clone_args), clone(step_cmd,clone_args), statements.clone(clone_args) )

    method resolve( scope:Scope )->Cmd
      collection = collection.resolve( scope )
      local collection_type = collection.require_type.organize

      local has_count = (collection_type.find_property("count")? or collection_type.find_method("count()")?)

      local step_size = 1
      if (step_cmd?)
        step_cmd = step_cmd.resolve( scope )
        local literal_integer_cmd = step_cmd as CmdLiteralInteger
        if (literal_integer_cmd?)
          step_size = literal_integer_cmd.value
        else
          throw step_cmd.t.error( "Literal integer value expected." )
        endIf
      endIf

      if (has_count)
        local cmd_block = CmdBlock(t)

        local collection_var = scope.this_method.add_local( t, Program.create_unique_id )
        cmd_block.statements.add( CmdLocalDeclaration(collection.t,collection_var) )
        collection_var.initial_value = collection

        local index_var = scope.this_method.add_local( t, Program.create_unique_id, Program.type_Integer )
        local last_cmd : Cmd
        cmd_block.statements.add( CmdLocalDeclaration(collection.t,index_var) )
        if (step_size >= 0)
          index_var.initial_value = CmdLiteralInteger( t, 0 )
          last_cmd = CmdAccess( t, CmdReadLocal(t,collection_var), "count" )
        else
          local args = CmdArgs()
          index_var.initial_value = CmdSubtract( t, CmdAccess(t,CmdReadLocal(t,collection_var), "count"), CmdLiteralInteger(t,1) )
          last_cmd = CmdLiteralInteger( t, 0 )
        endIf

        local control_var = scope.this_method.add_local( t, control_var_name )

        local index_read_cmd : Cmd
        if (step_size == 1)
          index_read_cmd = CmdReadLocal( t, index_var ).postmodify(1)
        elseIf (step_size == -1)
          index_read_cmd = CmdReadLocal( t, index_var ).postmodify(-1)
        elseIf (step_size >= 0)
          index_read_cmd = CmdReadLocal( t, index_var )
          statements.insert(CmdOpWithAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_plus_equals,CmdLiteralInteger(t,step_size)))
        else
          index_read_cmd = CmdReadLocal( t, index_var )
          statements.insert(CmdOpWithAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_minus_equals,CmdLiteralInteger(t,-step_size)))
        endIf

        statements.insert( CmdLocalDeclaration(control_var.t,control_var) )
        control_var.initial_value = index_read_cmd

        cmd_block.statements.add( CmdForEachOfIndexedCollection( t, index_var, control_var, collection_var, last_cmd, step_size, statements ) )
        return cmd_block.resolve( scope )

      else
        trace
        throw t.error( "TODO" )

      endIf
      return this
endClass

class CmdForEachOfIndexedCollection : CmdControlStructure
  PROPERTIES
    index_var        : Local
    control_var      : Local
    collection_var   : Local
    last_cmd         : Cmd
    step_size        : Integer

  METHODS
    method init( t, index_var, control_var, collection_var, last_cmd, step_size, statements=CmdStatementList() )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdForEachOfIndexedCollection( t, index_var, control_var, collection_var, last_cmd.clone(clone_args), step_size, statements.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "while (" ).print( index_var.cpp_name )
      if (step_size >= 0) writer.print( " < " )
      else                writer.print( " >= " )
      last_cmd.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      statements.resolve( scope )
      last_cmd = last_cmd.resolve( scope )
      return this
endClass


#------------------------------------------------------------------------------
# Literals
#------------------------------------------------------------------------------
class CmdLiteral : Cmd
  METHODS
    method implicit_type->Type
      return type

    method is_literal->Logical
      return true
endClass

class CmdLiteralNull : CmdLiteral
  METHODS
    method init( t )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLiteralNull( t )

    method print_cpp( writer:CPPWriter )
      writer.print( "NULL" )

    method resolve( scope:Scope )->this
      return this

    method type->Type
      return Program.type_null
endClass

class CmdLiteralReal : CmdLiteral
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLiteralReal( t, value )

    method print_cpp( writer:CPPWriter )
      writer.print( value )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Real
endClass


class CmdLiteralInteger : CmdLiteral
  PROPERTIES
    value : Integer

  METHODS
    method init( t, value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLiteralInteger( t, value )

    method cast_to( target_type:Type )->Cmd
      if (target_type is Program.type_Real)
        return CmdLiteralReal( t, value )
      else
        return prior.cast_to( target_type )
      endIf

    method print_cpp( writer:CPPWriter )
      writer.print( value )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Integer
endClass


class CmdLiteralCharacter : CmdLiteral
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLiteralCharacter( t, value )

    method print_cpp( writer:CPPWriter )
      writer.print( "(RogueCharacter)'" )
      writer.print( value )
      writer.print( "'" )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Character
endClass


class CmdLiteralLogical : CmdLiteral
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLiteralLogical( t, value )

    method print_cpp( writer:CPPWriter )
      if (value) writer.print "true"
      else       writer.print "false"

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Logical
endClass


class CmdLiteralString : CmdLiteral
  PROPERTIES
    value : String
    index : Integer

  METHODS
    method init( t, value, index=0 )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLiteralString( t, value, index )

    method print_cpp( writer:CPPWriter )
      if (value?)
        writer.print( "Rogue_program.literal_strings[" ).print( index ).print( "]" )
      else
        writer.print( "0" );
      endIf

    method resolve( scope:Scope )->Cmd
      Program.type_String.resolve
      if (value?)
        if (not Program.literal_string_lookup.contains(value))
          index = Program.literal_string_list.count
          Program.literal_string_lookup[value] = index
          Program.literal_string_list.add( value )
        else
          index = Program.literal_string_lookup[value]
        endIf
      endIf
      return this

    method type->Type
      return Program.type_String
endClass

class CmdFormattedString : Cmd
  PROPERTIES
    format : String
    args   : CmdArgs

  METHODS
    method init( t, format, args )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdFormattedString( t, format, args.clone(clone_args) )

    method implicit_type->Type
      return Program.type_String

    method resolve( scope:Scope )->Cmd
      local cmd = CmdAccess( t, "StringBuilder", CmdArgs() )
      local fmt = format
      forEach (arg in args)
        arg = arg.resolve(scope).require_value
        local i = fmt.locate( '$' )
        if (i == -1) throw t.error( "More arguments than format markers ('$') in formatted string." )
        if (i > 0)
          cmd = CmdAccess( t, cmd, "print", CmdArgs(CmdLiteralString(t,fmt.leftmost(i))) )
          fmt = fmt.substring(i+1)
        else
          fmt = fmt.substring(1)
        endIf
        cmd = CmdAccess( t, cmd, "print", CmdArgs(arg.cast_to(Program.type_String)) )
      endForEach
      if (fmt.count?)
        if (fmt.locate('$') != -1)
          throw t.error( "More format markers ('$') than arguments in formatted string." )
        endIf
        cmd = CmdAccess( t, cmd, "print", CmdArgs(CmdLiteralString(t,fmt)) )
      endIf
      return cmd.resolve( scope )

    method type->Type
      return Program.type_String
endClass


#------------------------------------------------------------------------------
# Access
#------------------------------------------------------------------------------
class CmdAccessWithModify : Cmd
  PROPERTIES
    premodify_count : Integer
    # Sum of pre-increment and pre-decrement

    postmodify_count : Integer
    # Sum of post-increment and post-decrement

    modified : Logical

  METHODS
    method postmodify( count:Integer )->Cmd
      if (modified) throw t.error( "Only one ++ or -- may be used at a time." )
      postmodify_count += count
      modified = true
      return this

    method premodify( count:Integer )->Cmd
      if (modified)
        throw t.error( "Only one ++ or -- may be used at a time." )
      endIf
      premodify_count += count
      modified = true
      return this

    method set_modifiers( access:CmdAccessWithModify )->Cmd
      if (access.modified)
        modified = true
        premodify_count = access.premodify_count
        postmodify_count = access.postmodify_count
      endIf
      return this
endClass


class CmdAccess : CmdAccessWithModify
  PROPERTIES
    context   : Cmd
    name      : String
    args      : CmdArgs

  METHODS
    method init( t, name )

    method init( t, name, args )

    method init( t, context, name )

    method init( t, context, name, args )

    method init( t, context, name, arg:Cmd )
      args = CmdArgs()
      args.add( arg )

    method clone( clone_args=null:CloneArgs )->Cmd
      local result = CmdAccess( t, clone(context,clone_args), name, clone(args,clone_args) )
      result.set_modifiers( this )
      if (clone_args? and clone_args.inlining) return clone_args.inline_access( result )
      return result

    method implicit_type->Type
      return Program.find_type( name )

    method resolve( scope:Scope )->Cmd
      if (args?) args.resolve( scope )

      if (context is null)
        if (args is null)
          local v = scope.find_local( name )
          if (v?)
            if (args?) throw t.error( "Local variable '$' cannot be called like a method."(name) )
            return CmdReadLocal(t,v).set_modifiers(this).resolve(scope)
          endIf
        endIf

        local new_type = Program.find_type( name )
        if (new_type?)
          # new TypeName(...)
          new_type.organize

          if (args is null)
            if (name.ends_with(']'))
              # Turn DataType[] -> DataType[]()
              args = CmdArgs()
            else
              return CmdReadSingleton( t, new_type )
            endIf
          endIf

          if (new_type.is_array)
            return CmdCreateArray( t, new_type, args ).resolve( scope )
          endIf

          if (new_type.is_compound)
            local cmd_call = scope.resolve_call( new_type, CmdAccess(t,"create",args), true )
            if (cmd_call notInstanceOf CmdCallRoutine) trace; throw t.error( "[INTERNAL]" )
            local r = (cmd_call as CmdCallRoutine)
            if (r.method_info.is_generated)
              # Calling the core compound creation routine
              return CmdCreateCompound( t, new_type, r.args ).resolve( scope )
            else
              return cmd_call
            endIf
          endIf

          local cmd_create = CmdCreateObject( t, new_type )
          local cmd_new = cmd_create : Cmd

          local must_find = args.count? or new_type.is_native
          local cmd_call : Cmd
          if (not new_type.is_native) cmd_call = scope.resolve_call( new_type, CmdAccess(t,cmd_new,"init",args), false )
          if (not cmd_call)
            cmd_call = scope.resolve_call( new_type, CmdAccess(t,CmdAccess(t,new_type.name),"create",args), false )
            if (must_find)
              if (not new_type.is_native) cmd_call = scope.resolve_call( new_type, CmdAccess(t,cmd_new,"init",args), true )
              cmd_call = scope.resolve_call( new_type, CmdAccess(t,CmdAccess(t,new_type.name),"create",args), true )
            endIf
          endIf

          if (cmd_call?) cmd_new = cmd_call

          return cmd_new.resolve(scope)
        endIf

        local p = scope.this_type.find_setting( name )
        if (p?) return CmdReadSetting( t, p ).set_modifiers(this)

        p = scope.this_type.find_property( name )
        if (p?)
          if (scope.this_method.is_routine)
            throw t.error( "Cannot access object properties from routines - routines have no 'this' object context." )
          endIf
          context = CmdThisContext( t, scope.this_type )
          return CmdReadProperty( t, context, p ).set_modifiers(this)
        endIf

        return scope.resolve_call( scope.this_type, this, true )

      else
        context = context.resolve( scope )
      endIf

      local context_type = context.require_type

      local p = context_type.find_setting( name )
      if (p?)
        context.require_type_context
        return CmdReadSetting( t, p).set_modifiers(this).resolve(scope)
      endIf

      p = context_type.find_property( name )
      if (p?)
        return CmdReadProperty( t, context, p ).set_modifiers(this)
      endIf

      return scope.resolve_call( context_type, this, true )

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      if (args is null)
        local v = scope.find_local( name )
        if (v?)
          if (args?) throw t.error( "Local variable '$' cannot be called like a method."(name) )
          return CmdWriteLocal(t,v,new_value).resolve(scope)
        endIf
      endIf

      if (context is null)
        local p = scope.this_method.type_context.find_setting( name )
        if (p?) return CmdWriteSetting( t, p, new_value )

        if (scope.this_method.is_routine)
          p = scope.this_method.type_context.find_property( name )
          if (p?) throw t.error( "Cannot access object properties from routines - routines have no 'this' object context." )
        endIf

        context = CmdThisContext( t, scope.this_type )
      else
        context = context.resolve( scope )
      endIf

      local context_type = context.require_type

      local p = context_type.find_setting( name )
      if (p?)
        context.require_type_context
        return CmdWriteSetting( t, p, new_value ).resolve(scope)
      endIf

      p = context_type.find_property( name )
      if (p?) 
        if (scope.this_method.is_routine)
          throw t.error( "Cannot access object properties from routines - routines have no 'this' object context." )
        else
          return CmdWriteProperty( t, context, p, new_value ).resolve(scope)
        endIf
      endIf

      throw t.error( //No such method or variable "$" exists in the current scope.// (name) )

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      if (args is null)
        local v = scope.find_local( name )
        if (v?)
          if (args?) throw t.error( "Local variable '$' cannot be called like a method."(name) )
          return CmdLocalOpWithAssign(t,v,op,new_value).resolve(scope)
        endIf
      endIf

      local context_type : Type

      if (context?)
        context = context.resolve( scope )
        context_type = context.require_type
      else
        context_type = scope.this_type
      endIf

      local p = context_type.find_setting( name )
      if (p?)
        if (context?) context.require_type_context
        return CmdOpAssignSetting( t, p, op, new_value ).resolve(scope)
      endIf

      p = context_type.find_property( name )
      if (p?)
        if (not context?) context = CmdThisContext( t, context_type )
        if (scope.this_method.is_routine)
          throw t.error( "Cannot access object properties from routines - routines have no 'this' object context." )
        endIf
        return CmdOpAssignProperty( t, context, p, op, new_value ).resolve(scope)
      endIf

      throw t.error( //No such method or variable "$" exists in the current scope.// (name) )

    method type->Type
      local err = t.error( "[INTERNAL] '$' $::type() is not defined." (name,type_name) )
      println err.stack_trace
      throw err
endClass


class CmdElementAccess : CmdAccessWithModify
  PROPERTIES
    context   : Cmd
    index : Cmd

  METHODS
    method init( t, context, index )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdElementAccess( t, context.clone(clone_args), index.clone(clone_args) ).set_modifiers( this )

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope )

      local context_type = context.require_type
      context_type.organize
      if (context_type.is_array)
        return CmdReadArrayElement( t, context, index ).set_modifiers( this ).resolve( scope )
      else
        local args = CmdArgs()
        args.add( index )
        return scope.resolve_call( context_type, CmdAccess(t,context,"get",args), true ).set_modifiers(this)
      endIf

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      context = context.resolve( scope )

      local context_type = context.require_type
      context_type.organize
      if (context_type.is_array)
        return CmdWriteArrayElement( t, context, index, new_value ).set_modifiers( this ).resolve( scope )
      else
        local args = CmdArgs()
        args.add( index ).add( new_value )
        return scope.resolve_call( context_type, CmdAccess(t,context,"set",args), true )
      endIf

endClass


#------------------------------------------------------------------------------
# Object Creation
#------------------------------------------------------------------------------
class CmdCreateObject : Cmd
  PROPERTIES
    of_type       : Type

  METHODS
    method init( t, of_type )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCreateObject( t, of_type )

    method print_cpp( writer:CPPWriter )
      writer.print( "((" ).print(of_type).print(")") 
      print_cpp_statement( writer )
      writer.print( ")" )

    method print_cpp_statement( writer:CPPWriter )
      if (of_type.is_compound)
        writer.print_type_name( of_type )
      else
        writer.print_type_info(of_type).print( "->create_and_init_object()")
      endIf

    method resolve( scope:Scope )->Cmd
      of_type.organize
      return this

    method type->Type
      return of_type
endClass


class CmdCreateCompound : Cmd
  PROPERTIES
    of_type : Type
    args    : CmdArgs

  METHODS
    method init( t, of_type, args )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCreateCompound( t, of_type, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( of_type ).print( "(" )
      if (args.count?)
        writer.print( " " )
        local first = true
        forEach (arg in args)
          if (first) first = false
          else       writer.print( ", " )
          arg.print_cpp( writer )
        endForEach
        writer.print( " " )
      endIf
      writer.print( ")" )

    method resolve( scope:Scope )->Cmd
      of_type.organize
      args.resolve( scope )
      return this

    method type->Type
      return of_type
endClass


#------------------------------------------------------------------------------
# Assign
#------------------------------------------------------------------------------
class CmdAssign : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdAssign( t, target.clone(clone_args), new_value.clone(clone_args) )

    method resolve( scope:Scope )->Cmd
      return target.resolve_assignment( scope, new_value )
endClass

#------------------------------------------------------------------------------
# Read/Write
#------------------------------------------------------------------------------

class CmdThisContext : Cmd
  PROPERTIES
    this_type : Type

  METHODS
    method init( t, this_type )

    method clone( clone_args=null:CloneArgs )->Cmd
      if (clone_args? and clone_args.inlining) return clone_args.inline_this
      return CmdThisContext( t, this_type )

    method print_cpp( writer:CPPWriter )
      writer.print "THIS"

    method require_type_context
      noAction

    method resolve( scope:Scope )->Cmd
      this_type.organize
      return this

    method type->Type
      return this_type
endClass

class CmdLiteralThis : CmdThisContext
  PROPERTIES
    this_type : Type

  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      if (clone_args? and clone_args.inlining) return clone_args.inline_this
      return CmdLiteralThis( t, this_type )

    method require_type_context
      throw t.error( //Type name expected.// )

    method resolve( scope:Scope )->Cmd
      this_type.organize
      if (scope.this_method.is_routine)
        throw t.error( "Invalid reference to 'this' object - routines have no object context." )
      endIf
      return this
endClass


class CmdReadSingleton : Cmd
  PROPERTIES
    of_type : Type

  METHODS
    method init( t, of_type )

    method print_cpp( writer:CPPWriter )
      if (not of_type.is_singleton)
        throw t.error( "$ is not a singleton." (of_type.name) )
      endIf
      writer.print( "((" ).print( of_type ).print( ")" )
      writer.print_type_info( of_type ).print( "->singleton())" )

    method require_type_context
      noAction

    method resolve( scope:Scope )->Cmd
      of_type.organize
      return this

    method type->Type
      return of_type
endClass


class CmdReadLocal : CmdAccessWithModify
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method clone( clone_args=null:CloneArgs )->Cmd
      if (clone_args? and clone_args.inlining) return clone_args.inline_read_local( this )
      return CmdReadLocal( t, local_info ).set_modifiers( this )

    method print_cpp( writer:CPPWriter )
      if (premodify_count > 0) writer.print("++")
      elseIf (premodify_count < 0) writer.print("--")

      writer.print( local_info.cpp_name )

      if (postmodify_count > 0) writer.print("++")
      elseIf (postmodify_count < 0) writer.print("--")

    method resolve( scope:Scope )->Cmd
      local_info.type.organize
      return this

    method type->Type
      return local_info.type
endClass


class CmdWriteLocal : Cmd
  PROPERTIES
    local_info : Local
    new_value  : Cmd

  METHODS
    method init( t, local_info, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      if (clone_args? and clone_args.inlining) return clone_args.inline_write_local( this )
      return CmdWriteLocal( t, local_info, clone(new_value,clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( local_info.cpp_name ).print(" = ")
      writer.print( "((" ).print( local_info.type ).print( ")" )
      new_value.print_cpp( writer )
      writer.print( ")" )

    method resolve( scope:Scope )->Cmd
      local_info.type.organize
      new_value = new_value.resolve(scope).cast_to( local_info.type ).resolve( scope )
      return this

    method type->Type
      return local_info.type
endClass


class CmdReadSetting : CmdAccessWithModify
  PROPERTIES
    setting_info : Property

  METHODS
    method init( t, setting_info )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdReadSetting( t, setting_info ).set_modifiers(this)

    method print_cpp( writer:CPPWriter )
      if (premodify_count > 0) writer.print("++")
      elseIf (premodify_count < 0) writer.print("--")

      writer.print_type_name( setting_info.type_context ).print( "::" )
      writer.print( setting_info.cpp_name )

      if (postmodify_count > 0) writer.print("++")
      elseIf (postmodify_count < 0) writer.print("--")

    method resolve( scope:Scope )->Cmd
      setting_info.type_context.resolve
      return this

    method type->Type
      return setting_info.type
endClass


class CmdWriteSetting : Cmd
  PROPERTIES
    setting_info  : Property
    new_value     : Cmd

  METHODS
    method init( t, setting_info, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdWriteSetting( t, setting_info, new_value.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print_type_name( setting_info.type_context ).print( "::" )
      writer.print( setting_info.cpp_name ).print(" = ")

      if (setting_info.type.compile_type is new_value.compile_type)
        new_value.print_cpp( writer )
      else
        writer.print( "((" ).print( setting_info.type ).print( ")" )
        new_value.print_cpp( writer )
        writer.print( ")" )
      endIf

    method resolve( scope:Scope )->Cmd
      new_value = new_value.resolve(scope).cast_to( setting_info.type ).resolve( scope )
      return this

    method type->Type
      return setting_info.type
endClass

class CmdReadProperty : CmdAccessWithModify
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdReadProperty( t, context.clone(clone_args), property_info ).set_modifiers(this)

    method print_cpp( writer:CPPWriter )
      if (premodify_count > 0) writer.print("++")
      elseIf (premodify_count < 0) writer.print("--")

      context.print_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name )

      if (postmodify_count > 0) writer.print("++")
      elseIf (postmodify_count < 0) writer.print("--")

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope ).require_value
      return this

    method type->Type
      return property_info.type
endClass


class CmdWriteProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property
    new_value     : Cmd

  METHODS
    method init( t, context, property_info, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdWriteProperty( t, context.clone(clone_args), property_info, new_value.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      context.print_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name ).print(" = ")

      if (property_info.type.compile_type is new_value.compile_type)
        new_value.print_cpp( writer )
      else
        writer.print( "((" ).print( property_info.type ).print( ")" )
        new_value.print_cpp( writer )
        writer.print( ")" )
      endIf

    method resolve( scope:Scope )->Cmd
      context = context.resolve(scope).require_value
      new_value = new_value.resolve(scope).cast_to( property_info.type ).resolve( scope )
      return this

    method type->Type
      return property_info.type
endClass

#------------------------------------------------------------------------------
# Method Calls
#------------------------------------------------------------------------------
class CmdCall : Cmd
  PROPERTIES
    context     : Cmd
    method_info : Method
    args        : CmdArgs

  METHODS
    method init( t, context, method_info, args )

    method resolve( scope:Scope )->Cmd
      if (context?) context = context.resolve(scope).require_value
      args.resolve( scope )
      return this

    method type->Type
      return method_info.return_type
endClass


class CmdCallRoutine : CmdCall
  METHODS
    method init( t, method_info, args )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallRoutine( t, method_info, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      local compile_target = method_info.compile_target
      writer.print( compile_target.cpp_name )
      writer.print( "(" )
      if (args.count?)
        writer.print( " " )
        local i = 0
        forEach (arg in args)
          if (i > 0) writer.print( ", " )
          local param_type = compile_target.parameters[i].type
          if ((method_info.generic_method? and method_info.parameters[i].generic_type?) or param_type.is_aspect)
            writer.print( "(" ).print_cast(arg.type,compile_target.parameters[i].type).print("(")
            arg.print_cpp( writer )
            writer.print( "))" )
          else
            arg.print_cpp( writer )
          endIf
          ++i
        endForEach
        writer.print( " " )
      endIf
      writer.print( ")" )
endClass

class CmdCallAspectMethod : CmdCall
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallAspectMethod( t, clone(context,clone_args), method_info, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      local compile_target = method_info.compile_target
      writer.print( compile_target.cpp_name )
      writer.print( "( " )
      writer.print( "(" )
      writer.print( Program.type_Object )
      writer.print( ")" )
      context.print_cpp( writer )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        local param_type = compile_target.parameters[i].type
        if ((method_info.generic_method? and method_info.parameters[i].generic_type?) or param_type.is_aspect)
          writer.print( "(" ).print_cast(arg.type,compile_target.parameters[i].type).print("(")
          arg.print_cpp( writer )
          writer.print( "))" )
        else
          arg.print_cpp( writer )
        endIf
        ++i
      endForEach
      writer.print( " )" )
endClass



class CmdCallDynamicMethod : CmdCall
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallDynamicMethod( t, clone(context,clone_args), method_info, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      local compile_target = method_info.compile_target
      if (compile_target.is_overridden)
        writer.print( "call_" ).print( compile_target.cpp_typedef )
        writer.print( "( " )
        writer.print( compile_target.index ).print( ", " )
        writer.print( "(" )
        writer.print( compile_target.type_context )
        writer.print( ")(" )
        context.print_cpp( writer )
        writer.print( ")" )
        local i = 0
        forEach (arg in args)
          writer.print( ", " )
          local param_type = compile_target.parameters[i].type
          if ((method_info.generic_method? and method_info.parameters[i].generic_type?) or param_type.is_aspect)
            writer.print( "(" ).print_cast(arg.type,compile_target.parameters[i].type)
            arg.print_cpp( writer )
            writer.print( ")" )
          else
            arg.print_cpp( writer )
          endIf
          ++i
        endForEach
        writer.print( " )" )

      else
        CmdCallStaticMethod( t, context, method_info, args ).print_cpp( writer )
      endIf
endClass


class CmdCallStaticMethod : CmdCall
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallStaticMethod( t, clone(context,clone_args), method_info, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      local compile_target = method_info.compile_target
      writer.print( compile_target.cpp_name )
      writer.print( "( (" )
      writer.print( compile_target.type_context )
      writer.print( ")(" )
      context.print_cpp( writer )
      writer.print( ")" )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        local param_type = compile_target.parameters[i].type
        if ((method_info.generic_method? and method_info.parameters[i].generic_type?) or param_type.is_aspect)
          writer.print( "(" ).print_cast(arg.type,compile_target.parameters[i].type)
          arg.print_cpp( writer )
          writer.print( ")" )
        else
          arg.print_cpp( writer )
        endIf
        ++i
      endForEach
      writer.print( " )" )
endClass


class CmdCallNativeRoutine : CmdCall
  METHODS
    method init( t, method_info, args )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallNativeRoutine( t, method_info, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      local compile_target = method_info.compile_target
      writer.print( compile_target.cpp_name )
      writer.print( "( " )
      local i = 0
      forEach (arg in args)
        if (i > 0) writer.print( ", " )
        local param_type = compile_target.parameters[i].type
        if ((method_info.generic_method? and method_info.parameters[i].generic_type?) or param_type.is_aspect)
          writer.print( "(" ).print_cast(arg.type,compile_target.parameters[i].type).print("(")
          arg.print_cpp( writer )
          writer.print( "))" )
        else
          arg.print_cpp( writer )
        endIf
        ++i
      endForEach
      writer.print( " )" )
endClass

class CmdCallNativeMethod : CmdCall
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallNativeMethod( t, clone(context,clone_args), method_info, args.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      local compile_target = method_info.compile_target
      writer.print( compile_target.cpp_name )
      writer.print( "( " )
      context.print_cpp( writer )
      local i = 0
      forEach (arg in args)
        writer.print( ", " )
        local param_type = compile_target.parameters[i].type
        if ((method_info.generic_method? and method_info.parameters[i].generic_type?) or param_type.is_aspect)
          writer.print( "(" ).print_cast(arg.type,compile_target.parameters[i].type).print("(")
          arg.print_cpp( writer )
          writer.print( "))" )
        else
          arg.print_cpp( writer )
        endIf
        ++i
      endForEach
      writer.print( " )" )
endClass

class CmdCallInlineNative : CmdCall
  METHODS
    method print_cpp( writer:CPPWriter )
      local st = method_info.native_code

      local dollar = st.locate('$')
      while (dollar != -1)
        writer.print( st.substring(0,dollar-1) )
        st = st.substring( dollar+1 )
        
        local best_match : Local
        forEach (p in method_info.parameters)
          if (st.begins_with(p.name))
            if (best_match is null or p.name.count > best_match.name.count) best_match = p
          endIf
        endForEach

        if (best_match?)
          args[ best_match.index ].print_cpp( writer )
          st = st.substring( best_match.name.count )
        else
          if (st.begins_with("this"))
            print_this( writer )
            st = st.substring( 4 )
          endIf
        endIf

        dollar = st.locate('$')
      endWhile

      writer.print( st )

    method print_this( writer:CPPWriter )
      throw t.error( "Illegal use of '$this' in routine." )

    method to->String
      return method_info.signature
endClass

class CmdCallInlineNativeRoutine : CmdCallInlineNative
  METHODS
    method init( t, method_info, args )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallInlineNativeRoutine( t, method_info, args.clone(clone_args) )

    method type->Type
      return method_info.return_type
endClass

class CmdCallInlineNativeMethod : CmdCallInlineNative
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCallInlineNativeMethod( t, clone(context,clone_args), method_info, args.clone(clone_args) )

    method print_this( writer:CPPWriter )
      context.print_cpp( writer )

    method type->Type
      return method_info.return_type
endClass

#------------------------------------------------------------------------------
# Miscellaneous Expressions
#------------------------------------------------------------------------------
class CmdRange : Cmd
  PROPERTIES
    first : Cmd
    last  : Cmd
    step_size  : Cmd

  METHODS
    method init( t, first, last, step_size=null )
endClass

class CmdRangeUpTo : CmdRange
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdRangeUpTo( t, first.clone(clone_args), last.clone(clone_args), clone(step_size,clone_args) )
endClass


#------------------------------------------------------------------------------
# Unary Operators
#------------------------------------------------------------------------------
class CmdUnary : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method cpp_prefix_symbol->String
      return prefix_symbol

    method cpp_suffix_symbol->String
      return suffix_symbol

    method prefix_symbol->String
      return ""

    method print_cpp( writer:CPPWriter )
      writer.print( cpp_prefix_symbol )
      operand.print_cpp( writer )
      writer.print( cpp_suffix_symbol )

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      if (operand.is_literal) return resolve_for_literal_operand( scope )
      else                    return resolve_for_operand_type( scope, operand.require_type )

    method resolve_for_literal_operand( scope:Scope )->Cmd
      return this

    method resolve_for_operand_type( scope:Scope, operand_type:Type )->Cmd
      return this

    method suffix_symbol->String
      return ""

    method type->Type
      return operand.type
endClass

class CmdLogicalize : CmdUnary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLogicalize( t, operand.clone(clone_args) )

    method cpp_prefix_symbol->String
      return "!!"

    method cpp_suffix_symbol->String
      return ""

    method prefix_symbol->String
      return ""

    method resolve_for_literal_operand( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value
      return this

    method suffix_symbol->String
      return "?"

    method type->Type
      return Program.type_Logical

endClass

class CmdLogicalNot : CmdUnary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLogicalNot( t, operand.clone(clone_args) )

    method cpp_prefix_symbol->String
      return "!"

    method prefix_symbol->String
      return "not "

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal)
        return CmdLiteralLogical( t, not (operand as CmdLiteralReal).value )
      elseIf (operand instanceOf CmdLiteralInteger)
        return CmdLiteralLogical( t, not (operand as CmdLiteralInteger).value )
      endIf
      return this

    method type->Type
      return Program.type_Logical

endClass


class CmdNegate : CmdUnary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdNegate( t, operand.clone(clone_args) )

    method prefix_symbol->String
      return "(-"

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal)
        return CmdLiteralReal( t, -(operand as CmdLiteralReal).value )
      elseIf (operand instanceOf CmdLiteralInteger)
        return CmdLiteralInteger( t, -(operand as CmdLiteralInteger).value )
      endIf
      return this

    method suffix_symbol->String
      return ")"
endClass


#------------------------------------------------------------------------------
# Binary Operators
#------------------------------------------------------------------------------
class CmdBinary : Cmd
  PROPERTIES
    left   : Cmd
    right  : Cmd

  METHODS
    method init( t, left, right )

    method cpp_symbol->String
      return symbol

    method fn_name->String
      throw t.error( "[INTERNAL] $::fn_name() is not defined." (type_name) )

    method print_cpp( writer:CPPWriter )
      if (requires_parens) writer.print( "(" )
      left.print_cpp( writer )
      writer.print( " " ).print( cpp_symbol ).print( " " )
      right.print_cpp( writer )
      if (requires_parens) writer.print( ")" )

    method requires_parens->Logical
      return true

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope )
      right = right.resolve( scope )
      local left_type = left.require_type
      local right_type = right.require_type
      return resolve_for_types( scope, left.require_type, right.require_type )

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local operator_method_call = resolve_operator_method( scope, left_type, right_type )
      if (operator_method_call?) return operator_method_call

      local common_type = find_common_type( left_type, right_type )
      left = left.cast_to( common_type )
      right = right.cast_to( common_type )
      if (left.is_literal and right.is_literal) return combine_literal_operands( common_type )
      return resolve_for_common_type( scope, common_type )

    method resolve_for_common_type( scope:Scope, common_type:Type )->Cmd
      return this

    method resolve_operator_method( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (left_type.has_method_named(fn_name))
        return CmdAccess( t, left, fn_name, CmdArgs(right) ).resolve( scope )
      elseIf (left_type.has_routine_named(fn_name))
        return CmdAccess( t, CmdAccess(t,left_type.name), fn_name, CmdArgs(left,right) ).resolve( scope )
      elseIf (right_type.has_routine_named(fn_name))
        return CmdAccess( t, CmdAccess(t,right_type.name), fn_name, CmdArgs(left,right) ).resolve( scope )
      else
        return null
      endIf

    method symbol->String
      throw t.error( "[INTERNAL] $::symbol() is not defined." (type_name) )

    method type->Type
      return left.type
endClass

class CmdAdd : CmdBinary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdAdd( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value + (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value + (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method fn_name->String
      return "operator+"

    method symbol->String
      return "+"
endClass


class CmdSubtract : CmdBinary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdSubtract( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value - (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value - (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method fn_name->String
      return "operator-"

    method symbol->String
      return "-"
endClass

class CmdMultiply : CmdBinary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdMultiply( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value * (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value * (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method fn_name->String
      return "operator*"

    method symbol->String
      return "*"
endClass


class CmdDivide : CmdBinary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdDivide( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value / (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value / (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method fn_name->String
      return "operator/"

    method symbol->String
      return "/"
endClass


class CmdMod : CmdBinary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdMod( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value % (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value % (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method print_cpp( writer:CPPWriter )
      writer.print( Program.program_name ).print( ".mod( " )
      left.print_cpp( writer )
      writer.print( ", " )
      right.print_cpp( writer )
      writer.print( " )" )

    method fn_name->String
      return "operator%"

    method symbol->String
      return "%"
endClass


class CmdPower : CmdBinary
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdPower( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value ^ (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value ^ (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method print_cpp( writer:CPPWriter )
      writer.print( "((" ).print( left.type ).print( ") pow((double)")
      left.print_cpp( writer )
      writer.print( ", (double)" )
      right.print_cpp( writer )
      writer.print( "))" )

    method fn_name->String
      return "operator^"

    method symbol->String
      return "^"
endClass


class CmdBinaryLogical : CmdBinary
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      throw t.error( "[INTERNAL] $::combine_literal_operands(Logical,Logical) is not defined." (type_name) )

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope ).require_logical
      right = right.resolve( scope ).require_logical
      if (left.is_literal and right.is_literal)
        return CmdLiteralLogical(
            t,
            combine_literal_operands(
                (left as CmdLiteralLogical).value,
                (right as CmdLiteralLogical).value
              )
          )
      endIf
      return this

    method resolve_operator_method( scope:Scope, left_type:Type, right_type:Type )->Cmd
      return null

    method type->Type
      return Program.type_Logical
endClass

class CmdLogicalAnd : CmdBinaryLogical
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLogicalAnd( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a and b)

    method cpp_symbol->String
      return "&&"

    method symbol->String
      return "and"
endClass


class CmdLogicalOr : CmdBinaryLogical
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLogicalOr( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a or b)

    method cpp_symbol->String
      return "||"

    method symbol->String
      return "or"
endClass



class CmdLogicalXor : CmdBinaryLogical
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLogicalXor( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a xor b)

    method cpp_symbol->String
      return "^"

    method symbol->String
      return "xor"
endClass


#------------------------------------------------------------------------------
# Comparison Operators
#------------------------------------------------------------------------------
class CmdComparison : CmdBinary
  METHODS
    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (left_type.is_reference or right_type.is_reference)
        return resolve_for_reference( scope, left_type, right_type )
      endIf

      local common_type = find_common_type( left_type, right_type )
      left = left.cast_to( common_type )
      right = right.cast_to( common_type )
      if (left.is_literal and right.is_literal) return combine_literal_operands( common_type )

      return this

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      throw t.error( "[INTERNAL] $::resolve_for_reference() is undefined." )

    method type->Type
      return Program.type_Logical
endClass

class CmdCompareEQ : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareEQ( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value == (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value == (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method requires_parens->Logical
      return false

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator==",CmdArgs(right)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<>",CmdArgs(right)), false )
      if (cmd?) return CmdCompareEQ( t, cmd, CmdLiteralInteger(t,0) ).resolve( scope )

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator!=",CmdArgs(right)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator==",CmdArgs(left)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator!=",CmdArgs(left)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      # Force error
      return scope.resolve_call( left_type, CmdAccess(t,left,"operator==",CmdArgs(right)), true )

    method symbol->String
      return "=="
endClass

class CmdCompareNE : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareNE( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value != (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value != (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator!=",CmdArgs(right)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<>",CmdArgs(right)), false )
      if (cmd?) return CmdCompareNE( t, cmd, CmdLiteralInteger(t,0) ).resolve( scope )

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator==",CmdArgs(right)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator!=",CmdArgs(left)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator==",CmdArgs(left)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      # Force error
      return scope.resolve_call( left_type, CmdAccess(t,left,"operator!=",CmdArgs(right)), true )

    method symbol->String
      return "!="
endClass

class CmdCompareLT : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareLT( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value < (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value < (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<",CmdArgs(right)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<>",CmdArgs(right)), false )
      if (cmd?) return CmdCompareEQ( t, cmd, CmdLiteralInteger(t,-1) ).resolve( scope )

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator>=",CmdArgs(right)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator>",CmdArgs(left)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator<=",CmdArgs(left)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      # Force error
      return scope.resolve_call( left_type, CmdAccess(t,left,"operator<",CmdArgs(right)), true )

    method symbol->String
      return "<"
endClass

class CmdCompareLE : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareLE( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value <= (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value <= (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<=",CmdArgs(right)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<>",CmdArgs(right)), false )
      if (cmd?) return CmdCompareNE( t, cmd, CmdLiteralInteger(t,1) ).resolve( scope )

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator>",CmdArgs(right)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator>=",CmdArgs(left)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator<",CmdArgs(left)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      # Force error
      return scope.resolve_call( left_type, CmdAccess(t,left,"operator<=",CmdArgs(right)), true )

    method symbol->String
      return "<="
endClass

class CmdCompareGT : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareGT( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value > (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value > (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator>",CmdArgs(right)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<>",CmdArgs(right)), false )
      if (cmd?) return CmdCompareEQ( t, cmd, CmdLiteralInteger(t,1) ).resolve( scope )

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<=",CmdArgs(right)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator<",CmdArgs(left)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator>=",CmdArgs(left)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      # Force error
      return scope.resolve_call( left_type, CmdAccess(t,left,"operator>",CmdArgs(right)), true )

    method symbol->String
      return ">"
endClass

class CmdCompareGE : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareGE( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value >= (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value >= (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator>=",CmdArgs(right)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<>",CmdArgs(right)), false )
      if (cmd?) return CmdCompareNE( t, cmd, CmdLiteralInteger(t,-1) ).resolve( scope )

      cmd = scope.resolve_call( left_type, CmdAccess(t,left,"operator<",CmdArgs(right)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator<=",CmdArgs(left)), false )
      if (cmd?) return cmd

      cmd = scope.resolve_call( right_type, CmdAccess(t,right,"operator>",CmdArgs(left)), false )
      if (cmd?) return CmdLogicalNot( t, cmd )

      # Force error
      return scope.resolve_call( left_type, CmdAccess(t,left,"operator>=",CmdArgs(right)), true )

    method symbol->String
      return ">="
endClass

class CmdCompareIs : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareIs( t, left.clone(clone_args), right.clone(clone_args) )

    method cpp_symbol->String
      return "=="

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (left_type.is_reference and right_type.is_reference)
        return this

      elseIf (left_type.is_primitive and right_type.is_primitive)
        return CmdCompareEQ( t, left, right ).resolve( scope )

      elseIf (left_type.is_compound and right_type.is_compound)
        throw t.error( "[INTERNAL] TODO: 'is' for compounds." )

      else
        throw t.error( "Cannot use 'is' between mixed type categories $ and $." (left_type,right_type) )

      endIf

    method symbol->String
      return "is"
endClass

class CmdCompareIsNot : CmdComparison
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCompareIsNot( t, left.clone(clone_args), right.clone(clone_args) )

    method cpp_symbol->String
      return "!="

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (left_type.is_reference and right_type.is_reference)
        return this

      elseIf (left_type.is_primitive and right_type.is_primitive)
        return CmdCompareEQ( t, left, right ).resolve( scope )

      elseIf (left_type.is_compound and right_type.is_compound)
        throw t.error( "[INTERNAL] TODO: 'is' for compounds." )

      else
        throw t.error( "Cannot use 'isNot' between mixed type categories $ and $." (left_type,right_type) )

      endIf

    method symbol->String
      return "isNot"
endClass

#------------------------------------------------------------------------------
# Bitwise
#------------------------------------------------------------------------------
class CmdBitwiseOp : CmdBinary
  METHODS
    method resolve_for_common_type( scope:Scope, common_type:Type )->Cmd
      if (common_type is Program.type_Byte or common_type is Program.type_Character)
        left  = left.cast_to( Program.type_Integer ).resolve( scope )
        right = right.cast_to( Program.type_Integer ).resolve( scope )

        # TODO: allow Integer & Logical
        #elseIf (common_type isNot Program.type_Integer)
        #throw t.error( "'$' requires integer operands." (symbol) )
      endIf

      return this

    method resolve_operator_method( scope:Scope, left_type:Type, right_type:Type )->Cmd
      return null
endClass

class CmdBitwiseAnd : CmdBitwiseOp
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBitwiseAnd( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value & (right as CmdLiteralInteger).value )
      elseIf (common_type is Program.type_Logical)
        return CmdLiteralLogical( t, (left as CmdLiteralLogical).value and (right as CmdLiteralLogical).value )
      else
        return this
      endIf

    method symbol->String
      return "&"
endClass

class CmdBitwiseOr : CmdBitwiseOp
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBitwiseOr( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value | (right as CmdLiteralInteger).value )
      elseIf (common_type is Program.type_Logical)
        return CmdLiteralLogical( t, (left as CmdLiteralLogical).value or (right as CmdLiteralLogical).value )
      else
        return this
      endIf

    method symbol->String
      return "|"
endClass

class CmdBitwiseXor : CmdBitwiseOp
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBitwiseXor( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value ~ (right as CmdLiteralInteger).value )
      elseIf (common_type is Program.type_Logical)
        return CmdLiteralLogical( t, (left as CmdLiteralLogical).value xor (right as CmdLiteralLogical).value )
      else
        return this
      endIf

    method cpp_symbol->String
      return "^"

    method symbol->String
      return "~"
endClass

class CmdBitwiseShiftLeft : CmdBitwiseOp
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBitwiseShiftLeft( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value :<<: (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method cpp_symbol->String
      return "<<"

    method symbol->String
      return ":<<:"
endClass

class CmdBitwiseShiftRight : CmdBitwiseOp
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBitwiseShiftRight( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value :<<: (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method cpp_symbol->String
      return ">>>"

    method print_cpp( writer:CPPWriter )
      writer.print( "Rogue_program.shift_right( " )
      left.print_cpp( writer )
      writer.print( ", " )
      right.print_cpp( writer )
      writer.print( " )" )

    method symbol->String
      return ":>>:"
endClass

class CmdBitwiseShiftRightX : CmdBitwiseOp
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdBitwiseShiftRightX( t, left.clone(clone_args), right.clone(clone_args) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value :<<: (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method cpp_symbol->String
      return ">>"

    method symbol->String
      return ":>>>:"
endClass

#------------------------------------------------------------------------------
# OpWithAssign
#------------------------------------------------------------------------------
class CmdOpWithAssign : Cmd
  PROPERTIES
    target    : Cmd
    op        : TokenType
    new_value : Cmd

  METHODS
    method init( t, target, op, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdOpWithAssign( t, target.clone(clone_args), op, new_value.clone(clone_args) )
      
    method resolve( scope:Scope )->Cmd
      return target.resolve_modify_and_assign( scope, op, new_value )
endClass

class CmdResolvedOpWithAssign : Cmd
  PROPERTIES
    op         : TokenType
    new_value  : Cmd

  METHODS
    method cpp_symbol->String
      return symbol

    method symbol->String
      if (op is TokenType.symbol_tilde_equals) return "^="
      return op->String

endClass

class CmdLocalOpWithAssign : CmdResolvedOpWithAssign
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info, op, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdLocalOpWithAssign( t, local_info, op, new_value.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( local_info.cpp_name ).print( " " ).print( cpp_symbol ).print( " " )
      new_value.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      if (local_info.type.is_reference)
        local m_name = "operator" + op->String
        if (local_info.type.method_lookup_by_name[m_name]?)
          return CmdAccess( t, CmdReadLocal(t,local_info), m_name, new_value ).resolve( scope )
        else
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (local_info.type.method_lookup_by_name[m_name]?)
            return CmdWriteLocal( t, local_info,
            CmdAccess( t, CmdReadLocal(t,local_info), m_name, new_value ) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (local_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          if (RogueC.target == "C++")
            return CmdWriteLocal( t, local_info, CmdPower(t,CmdReadLocal(t,local_info),new_value) ).resolve( scope )
          endIf

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          if (RogueC.target == "C++")
            return CmdWriteLocal( t, local_info, CmdMod(t,CmdReadLocal(t,local_info),new_value) ).resolve( scope )
          endIf

        case TokenType.symbol_dot_equals
          local access = new_value as CmdAccess
          if (not access?) throw new_value.t.error( "Property or method name expected." )
          if (access.context?) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadLocal( t, local_info )
          return CmdWriteLocal( t, local_info, access ).resolve( scope )
      endWhich

      new_value = new_value.resolve( scope ).cast_to( local_info.type ).resolve( scope )
      return this

    method type->Type
      return local_info.type
endClass


class CmdOpAssignSetting : CmdResolvedOpWithAssign
  PROPERTIES
    setting_info : Property

  METHODS
    method init( t, setting_info, op, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdOpAssignSetting( t, setting_info, op, new_value.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print_type_name( setting_info.type_context ).print( "::" )
      writer.print( setting_info.cpp_name ).print(" ").print(cpp_symbol).print(" ")
      new_value.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      if (setting_info.type.is_reference)
        local m_name = "operator" + op->String
        if (setting_info.type.method_lookup_by_name[m_name]?)
          return CmdAccess( t, CmdReadSetting(t,setting_info), m_name, new_value ).resolve( scope )
        else
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (setting_info.type.method_lookup_by_name[m_name]?)
            return CmdWriteSetting( t, setting_info,
              CmdAccess(t, CmdReadSetting(t,setting_info), m_name, new_value) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (setting_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          if (RogueC.target == "C++")
            return CmdWriteSetting( t, setting_info, CmdPower(t,CmdReadSetting(t,setting_info),new_value) ).resolve( scope )
          endIf

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          if (RogueC.target == "C++")
            return CmdWriteSetting( t, setting_info, CmdMod(t,CmdReadSetting(t,setting_info),new_value) ).resolve( scope )
          endIf

        case TokenType.symbol_dot_equals
          local access = new_value as CmdAccess
          if (not access?) throw new_value.t.error( "Property or method name expected." )
          if (access.context?) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadSetting( t, setting_info )
          return CmdWriteSetting( t, setting_info, access ).resolve( scope )
      endWhich

      new_value = new_value.resolve(scope).cast_to( setting_info.type ).resolve( scope )
      return this

    method type->Type
      return setting_info.type
endClass

class CmdOpAssignProperty : CmdResolvedOpWithAssign
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info, op, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdOpAssignProperty( t, context.clone(clone_args), property_info, op, new_value.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      context.print_cpp( writer )
      writer.print_access_operator( context.type )  # -> or .
      writer.print( property_info.cpp_name ).print(" ").print(cpp_symbol).print(" ")
      new_value.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      if (property_info.type.is_reference)
        local m_name = "operator" + op->String
        if (property_info.type.method_lookup_by_name[m_name]?)
          return CmdAccess( t, CmdReadProperty(t,context,property_info), m_name, new_value ).resolve( scope )
        else
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (property_info.type.method_lookup_by_name[m_name]?)
            return CmdWriteProperty( t, context, property_info,
              CmdAccess(t, CmdReadProperty(t,clone(context),property_info), m_name, new_value) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (property_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          if (RogueC.target == "C++")
            return CmdWriteProperty( t, context, property_info, CmdPower(t,CmdReadProperty(t,clone(context),property_info),new_value) ).resolve( scope )
          endIf

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          if (RogueC.target == "C++")
            return CmdWriteProperty( t, context, property_info, CmdMod(t,CmdReadProperty(t,clone(context),property_info),new_value) ).resolve( scope )
          endIf

        case TokenType.symbol_dot_equals
          local access = new_value as CmdAccess
          if (not access?) throw new_value.t.error( "Property or method name expected." )
          if (access.context?) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadProperty( t, clone(context), property_info )
          return CmdWriteProperty( t, context, property_info, access ).resolve( scope )
      endWhich

      context = context.resolve(scope).require_value
      new_value = new_value.resolve(scope).cast_to( property_info.type ).resolve( scope )
      return this

    method type->Type
      return property_info.type
endClass

#------------------------------------------------------------------------------
# Arrays
#------------------------------------------------------------------------------
class CmdCreateArray : Cmd
  PROPERTIES
    array_type   : Type
    count_cmd    : Cmd

  METHODS
    method init( t, array_type, args:CmdArgs )
      if (args is null or args.count != 1)
        throw t.error( "Array count expected." )
      endIf
      count_cmd = args.first

    method init( t, array_type, count_cmd )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCreateArray( t, array_type, count_cmd.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      writer.print( "RogueArray::create( " )
      count_cmd.print_cpp( writer )
      writer.print( ", sizeof(" ).print_type_name( array_type.element_type ).print( ")" )
      if (array_type.element_type.is_reference) writer.print( ", true" )
      writer.print( " )" )

    method resolve( scope:Scope )->Cmd
      array_type.organize
      count_cmd = count_cmd.resolve(scope).require_integer
      return this

    method type->Type
      return array_type
endClass

class CmdReadArrayElement : CmdAccessWithModify
  PROPERTIES
    context    : Cmd
    array_type : Type
    index      : Cmd

  METHODS
    method init( t, context, index )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdReadArrayElement( t, context.clone(clone_args), index.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      if (array_type.element_type.is_reference)
        if (premodify_count != 0 or postmodify_count != 0)
          throw t.error( "++ and -- currently cannot be applied to object list elements." )
        endIf

        writer.print( "((" )
        writer.print( array_type.element_type )
        writer.print( ")(" )
        context.print_cpp( writer )
        writer.print( "->objects[" )
        index.print_cpp( writer )
        writer.print( "]))" )

      else
        if (premodify_count > 0) writer.print("++")
        elseIf (premodify_count < 0) writer.print("--")

        context.print_cpp( writer )
        writer.print( "->" )
        if (array_type.element_type.is_primitive)
          whichIs (array_type.element_type)
            case Program.type_Real:      writer.print( "reals[" )
            case Program.type_Float:     writer.print( "floats[" )
            case Program.type_Long:      writer.print( "longs[" )
            case Program.type_Integer:   writer.print( "integers[" )
            case Program.type_Character: writer.print( "characters[" )
            case Program.type_Byte:      writer.print( "bytes[" )
            case Program.type_Logical:   writer.print( "logical[" )
          endWhichIs

        else
          throw t.error( "[INTERNAL] TODO: CmdReadArrayElement non-primitive" )
        endIf
        
        index.print_cpp( writer )
        writer.print( "]" )

        if (postmodify_count > 0) writer.print("++")
        elseIf (postmodify_count < 0) writer.print("--")
      endIf


    method resolve( scope:Scope )->Cmd
      if (array_type?) return this

      context = context.resolve(scope)
      array_type = context.require_type
      index = index.resolve(scope).require_integer
      return this

    method type->Type
      return array_type.element_type
endClass

class CmdReadArrayCount : Cmd
  PROPERTIES
    context      : Cmd
    array_type   : Type

  METHODS
    method init( t, context )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdReadArrayCount( t, context.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      context.print_cpp( writer )
      writer.print( "->count" )
        
    method resolve( scope:Scope )->Cmd
      if (array_type?) return this

      context = context.resolve(scope)
      array_type = context.require_type
      return this

    method type->Type
      return Program.type_Integer
endClass

class CmdWriteArrayElement : Cmd
  PROPERTIES
    context    : Cmd
    array_type : Type
    index      : Cmd
    new_value  : Cmd

  METHODS
    method init( t, context, index, new_value )

    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdWriteArrayElement( t, context.clone(clone_args), index.clone(clone_args), new_value.clone(clone_args) )

    method print_cpp( writer:CPPWriter )
      context.print_cpp( writer )
      writer.print( "->" )
      if (array_type.element_type.is_primitive)
        whichIs (array_type.element_type)
          case Program.type_Real:      writer.print( "reals[" )
          case Program.type_Float:     writer.print( "floats[" )
          case Program.type_Long:      writer.print( "longs[" )
          case Program.type_Integer:   writer.print( "integers[" )
          case Program.type_Character: writer.print( "characters[" )
          case Program.type_Byte:      writer.print( "bytes[" )
          case Program.type_Logical:   writer.print( "logical[" )
        endWhichIs

      elseIf (array_type.element_type.is_reference)
        writer.print( "objects[" )

      else
        throw t.error( "[INTERNAL] TODO: CmdWriteArrayElement non-primitive" )
      endIf
        
      index.print_cpp( writer )
      writer.print( "] = " )
      new_value.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      if (array_type?) return this

      context = context.resolve(scope)
      array_type = context.require_type
      index = index.resolve(scope).require_integer
      new_value = new_value.resolve( scope ).require_value.cast_to( array_type.element_type ).resolve( scope )
      return this

    method type->Type
      return array_type.element_type
endClass


#------------------------------------------------------------------------------
# Type Checks and Conversions
#------------------------------------------------------------------------------
class CmdTypeOperator : Cmd
  PROPERTIES
    operand     : Cmd
    target_type : Type

  METHODS
    method init( t, operand, target_type )

    method type->Type
      return target_type
endClass


class CmdCastToType : CmdTypeOperator
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdCastToType( t, operand.clone(clone_args), target_type )

    method print_cpp( writer:CPPWriter )
      writer.print( "((" ).print( target_type ).print( ")(" )
      operand.print_cpp( writer )
      writer.print( "))" )

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      target_type.organize
      if (operand.require_type is target_type) return operand
      return this
endClass

class CmdConvertToType : CmdTypeOperator
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdConvertToType( t, operand.clone(clone_args), target_type )

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      local operand_type = operand.require_type
      target_type.organize
      if (operand_type is target_type) return operand

      if (operand_type.is_primitive)
        return CmdConvertToPrimitiveType( t, operand, target_type ).resolve( scope )
      else
        return CmdAccess( t, operand, "to_" + target_type.name ).resolve( scope )
      endIf
endClass


class CmdConvertToPrimitiveType : CmdConvertToType
  METHODS
    method clone( clone_args=null:CloneArgs )->Cmd
      return CmdConvertToPrimitiveType( t, operand.clone(clone_args), target_type )

    method print_cpp( writer:CPPWriter )
      writer.print( "((" ).print( target_type.cpp_name ).print( ")(" )
      operand.print_cpp( writer )
      writer.print( "))" )

    method resolve( scope:Scope )->Cmd
      local operand_type = operand.require_type
      if (not operand_type.is_primitive)
        trace
        throw t.error( "TODO: CmdConvertToPrimitiveType with non-primitive operand." )
      endIf
      return this
endClass

