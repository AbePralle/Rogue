class Cmd
  PROPERTIES
    t : Token

  METHODS
    method cast_to( target_type:Type )->Cmd
      if (type is target_type) return this
      throw t.error( "TODO: Cmd::cast_to()." )

    method combine_literal_operands( common_type:Type )->Cmd
      return this

    method exit_scope( scope:Scope )

    method find_common_type( left_type:Type, right_type:Type )->Type
      if (left_type is right_type) return left_type

      if (left_type.is_primitive)
        if (right_type.is_primitive)
          if (left_type is Program.type_Real or right_type is Program.type_Real) return Program.type_Real
          if (left_type is Program.type_Integer or right_type is Program.type_Integer) return Program.type_Integer
        endIf
      endIf

      throw t.error( "Types $ and $ are incompatible." (left_type,right_type) )

    method implicit_type->Type
      return null

    method is_literal->Logical
      return false

    method postmodify( count:Integer )->Cmd
      throw t.error( "Illegal target; ++ and -- can only be applied to specific variables." )

    method premodify( count:Integer )->Cmd
      throw t.error( "Illegal target; ++ and -- can only be applied to specific variables." )

    method print_cpp( writer:CPPWriter )
      throw t.error( "[INTERNAL] $::print_cpp() is not defined." (type_name) )

    method require_logical->Cmd
      local _type = type
      if (_type is null or _type isNot Program.type_Logical)
        throw t.error( "Logical value expected." )
      endIf
      return this

    method require_type->Type
      local result = type
      if (result is null) throw t.error( "Value expected; this statement or expression does not result in a value." )
      return result

    method require_value->Cmd
      require_type
      return this

    method requires_semicolon->Logical
      return true

    method resolve( scope:Scope )->Cmd
      throw t.error( "[INTERNAL] $::resolve() is not defined." (type_name) )
      return this

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      throw t.error( "[INTERNAL] $::resolve_assignment() is not defined." (type_name) )
      return this

    method type->Type
      throw t.error( "[INTERNAL] $::type() is not defined." (type_name) )

endClass

#------------------------------------------------------------------------------
# StatementList
#------------------------------------------------------------------------------
class CmdStatementList : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Integer)
      prior.init( initial_capacity )

    method init( statement:Cmd )
      init
      add( statement )

    method init( statement1:Cmd, statement2:Cmd )
      init
      add( statement1 ).add( statement2 )

      #{
    method has_side_effects->Logical
      forEach (cmd in this)
        if (cmd.has_side_effects) return true
      endForEach
      return false

    method clone->CmdStatementList
      local result = CmdStatementList( count )
      forEach (cmd in this) result.add( cmd.clone )
      return result

    method dispatch( v:Visitor ) [propagated]
      v.visit( this )

    method print( buffer:StringBuilder )
      Analyzer.context.push_local_scope
      forEach (statement in this)
        buffer.print( "      " )
        buffer.print( statement.type_name )
        buffer.print( " " )
        statement.print( buffer )
        buffer.println
      endForEach
      Analyzer.context.pop_local_scope
      }#

    method print_cpp( writer:CPPWriter )
      forEach (statement in this)
        statement.print_cpp( writer )
        if (statement.requires_semicolon) writer.println ";"
      endForEach

    method resolve( scope:Scope )
      forEach (i of this)
        this[i] = this[i].resolve( scope )
      endForEach

      forEach (statement in this) statement.exit_scope( scope )
endClass


#------------------------------------------------------------------------------
# Args
#------------------------------------------------------------------------------
class CmdArgs : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Integer)
      prior.init( initial_capacity )

    method init( arg:Cmd )
      init
      add( arg )

    method init( statement1:Cmd, statement2:Cmd )
      init
      add( statement1 ).add( statement2 )

    method print_cpp( writer:CPPWriter )
      local first = true
      forEach (arg in this)
        if (first) first = false
        else       writer.print(",")
        arg.print_cpp( writer )
      endForEach

    method resolve( scope:Scope )
      forEach (i of this)
        this[i] = this[i].resolve( scope )
      endForEach
endClass


#------------------------------------------------------------------------------
# Statements
#------------------------------------------------------------------------------
class CmdStatement : Cmd
endClass

class CmdLocalDeclaration : CmdStatement
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method exit_scope( scope:Scope )
      scope.pop_local

    method print_cpp( writer:CPPWriter )
      writer.print( local_info.type ).print(" ").print( local_info.name ).print(" = ")
      if (local_info.initial_value?)
        local_info.initial_value.print_cpp( writer )
      else
        writer.print_default_value( local_info.type )
      endIf

    method resolve( scope:Scope )->Cmd
      scope.push_local( local_info )

      if (local_info.initial_value?)
        local_info.initial_value = local_info.initial_value.resolve( scope )
        local initial_value_type = local_info.initial_value.require_type
        if (local_info.type is null) local_info.type = initial_value_type
      endIf

      if (local_info.type is null)
        throw t.error( "Cannot determine type of local variable - either assign an initial value (local $ = ...) or assign a type (local $ : Integer)." (local_info.name,local_info.name) )
      endIf

      local_info.type.resolve

      return this
endClass

class CmdPrintln : CmdStatement
  PROPERTIES
    expression : Cmd

  METHODS
    method init( t, expression=null )

    method print_cpp( writer:CPPWriter )
      if (expression?)
        local print_type = expression.type

        if (print_type is Program.type_String)
          writer.print "RogueString::println( "
          expression.print_cpp( writer )
          writer.print " )"

        elseIf (print_type is Program.type_Integer)
          writer.print( //printf( "%d\\n", // )
          expression.print_cpp( writer )
          writer.print " )"

        elseIf (print_type is Program.type_Real)
          writer.print( //printf( "%.4lf\\n", // )
          expression.print_cpp( writer )
          writer.print " )"

        elseIf (print_type is Program.type_Logical)
          writer.print( //printf( "%s\\n", // )
          expression.print_cpp( writer )
          writer.print //?"true":"false" );//

        else

          throw t.error( "[INTERNAL/CmdPrintln] Unhandled type in println: " + print_type.name )
        endIf

      else
        writer.print //printf( "\\n" )//
      endIf

    method resolve( scope:Scope )->Cmd
      if (expression is null) return this

      expression = expression.resolve( scope )
      return this
endClass

class CmdReturnValue : CmdStatement
  PROPERTIES
    expression : Cmd

  METHODS
    method init( t, expression )

    method print_cpp( writer:CPPWriter )
      writer.print "return "
      expression.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      expression = expression.resolve( scope )
      return this
endClass


#------------------------------------------------------------------------------
# Control Structures
#------------------------------------------------------------------------------
class CmdControlStructure : CmdStatement
  PROPERTIES
    statements : CmdStatementList

  METHODS
    method init( t )
      statements = CmdStatementList()

    method requires_semicolon->Logical
      return false
endClass


class CmdBlock : CmdControlStructure
  PROPERTIES
    statements : CmdStatementList

  METHODS
    method init( t )
      statements = CmdStatementList()

    method print_cpp( writer:CPPWriter )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->CmdBlock
      statements.resolve( scope )
      return this
endClass


class CmdIf : CmdControlStructure
  PROPERTIES
    condition           : Cmd
    else_ifs            : CmdElseIf[]
    else_statements     : CmdStatementList

  METHODS
    method init( t )
      statements = CmdStatementList()

    method add( cmd_else_if:CmdElseIf )
      if (else_ifs is null) else_ifs = CmdElseIf[]
      else_ifs.add( cmd_else_if )

    method print_cpp( writer:CPPWriter )
      writer.print( "if (" )
      condition.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

      forEach (else_if in else_ifs)
        else_if.print_cpp( writer )
      endForEach

      if (else_statements?)
        writer.println( "else" )
        writer.println( "{" )
        writer.indent += 2
        else_statements.print_cpp( writer )
        writer.indent -= 2
        writer.println( "}" )
      endIf

    method resolve( scope:Scope )->CmdIf
      condition = condition.resolve( scope ).require_logical
      statements.resolve( scope )
      if (else_ifs?)
        forEach (else_if in else_ifs) else_if.resolve( scope )
      endIf
      if (else_statements?) else_statements.resolve( scope )
      return this
endClass


class CmdElseIf
  PROPERTIES
    cmd_if     : CmdIf
    condition  : Cmd
    statements : CmdStatementList

  METHODS
    method init( cmd_if )
      statements = CmdStatementList()

    method print_cpp( writer:CPPWriter )
      writer.print( "else if (" )
      condition.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )
      condition = condition.resolve( scope ).require_logical
      statements.resolve( scope )
endClass


class CmdWhile : CmdControlStructure
  PROPERTIES
    expression : Cmd

  METHODS
    method print_cpp( writer:CPPWriter )
      writer.print( "while (" )
      expression.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      expression = expression.resolve( scope )
      statements.resolve( scope )
      return this
endClass


class CmdForEachInRange : CmdControlStructure
  PROPERTIES
    control_var : Local
    last_var    : Local
    step_var    : Local
    first       : Cmd
    last        : Cmd

  METHODS
    method init( t, control_var, last_var )

      #{
    method print_cpp( writer:CPPWriter )
      writer.print( "for (" ).print( contr
      expression.print_cpp( writer )
      writer.println( ")" )
      writer.println( "{" )
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println( "}" )

    method resolve( scope:Scope )->Cmd
      expression = expression.resolve( scope )
      statements.resolve( scope )
      return this
      }#
endClass


#------------------------------------------------------------------------------
# Literals
#------------------------------------------------------------------------------
class CmdLiteral : Cmd
  METHODS
    method implicit_type->Type
      return type

    method is_literal->Logical
      return true
endClass


class CmdLiteralReal : CmdLiteral
  PROPERTIES
    value : Real

  METHODS
    method init( t, value )

    method print_cpp( writer:CPPWriter )
      writer.print( value )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Real
endClass


class CmdLiteralInteger : CmdLiteral
  PROPERTIES
    value : Integer

  METHODS
    method init( t, value )

    method cast_to( target_type:Type )->Cmd
      if (target_type is Program.type_Real)
        return CmdLiteralReal( t, value )
      else
        return prior.cast_to( target_type )
      endIf

    method print_cpp( writer:CPPWriter )
      writer.print( value )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Integer
endClass


class CmdLiteralCharacter : CmdLiteral
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Character
endClass


class CmdLiteralLogical : CmdLiteral
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method print_cpp( writer:CPPWriter )
      if (value) writer.print "true"
      else       writer.print "false"

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return Program.type_Logical
endClass


class CmdLiteralString : CmdLiteral
  PROPERTIES
    value : String
    index : Integer

  METHODS
    method init( t, value )

    method print_cpp( writer:CPPWriter )
      if (value?)
        writer.print( "rogue_program.literal_strings[" ).print( index ).print( "]" )
      else
        writer.print( "0" );
      endIf

    method resolve( scope:Scope )->Cmd
      Program.type_String.resolve
      if (value?)
        if (not Program.literal_string_lookup.contains(value))
          index = Program.literal_string_list.count
          Program.literal_string_lookup[value] = index
          Program.literal_string_list.add( value )
        endIf
      endIf
      return this

    method type->Type
      return Program.type_String
endClass


#------------------------------------------------------------------------------
# Access
#------------------------------------------------------------------------------
class CmdAccessWithModify : Cmd
  PROPERTIES
    premodify_count : Integer
    # Sum of pre-increment and pre-decrement

    postmodify_count : Integer
    # Sum of post-increment and post-decrement

  METHODS
    method postmodify( count:Integer )->Cmd
      if (count? and (premodify_count? or postmodify_count?))
        throw t.error( "Only one ++ or -- may be used at a time." )
      endIf
      postmodify_count += count
      return this

    method premodify( count:Integer )->Cmd
      if (count? and (premodify_count? or postmodify_count?))
        throw t.error( "Only one ++ or -- may be used at a time." )
      endIf
      premodify_count += count
      return this
endClass


class CmdAccess : CmdAccessWithModify
  PROPERTIES
    context   : Cmd
    name      : String
    args      : CmdArgs

  METHODS
    method init( t, name )

    method init( t, context, name )

    method resolve( scope:Scope )->Cmd
      if (args is null)
        local v = scope.find_local( name )
        if (v?)
          if (args?) throw t.error( "Local variable '$' cannot be called like a method."(name) )
          return CmdReadLocal(t,v).premodify(premodify_count).postmodify(postmodify_count).resolve(scope)
        endIf
      endIf

      if (context is null)
        local new_type = Program.find_type( name )
        if (new_type?)
          # new TypeName(...)
          return CmdCreateObject( t, new_type, args).resolve(scope)
        endIf

        context = CmdReadThis( t, scope.this_type )

      else
        context = context.resolve( scope )
      endIf

      local context_type = context.require_type
      local p = context_type.find_property( name )
      if (p?)
        return CmdReadProperty( t, context, p ).premodify(premodify_count).postmodify(postmodify_count)
      endIf

      throw t.error( //No such method or variable "$" exists in the current scope.// (name) )

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      if (args is null)
        local v = scope.find_local( name )
        if (v?)
          if (args?) throw t.error( "Local variable '$' cannot be called like a method."(name) )
          return CmdWriteLocal(t,v,new_value).resolve(scope)
        endIf
      endIf


      if (context is null)
        context = CmdReadThis( t, scope.this_type )
      else
        context = context.resolve( scope )
      endIf

      local context_type = context.require_type
      local p = context_type.find_property( name )
      if (p?)
        return CmdWriteProperty( t, context, p, new_value ).resolve(scope)
      endIf

      throw t.error( //No such method or variable "$" exists in the current scope.// (name) )
endClass


#------------------------------------------------------------------------------
# Object Creation
#------------------------------------------------------------------------------
class CmdCreateObject : Cmd
  PROPERTIES
    of_type : Type
    args    : CmdArgs

  METHODS
    method init( t, of_type, args )

    method print_cpp( writer:CPPWriter )
      writer.print( Program.program_name ).print(".type_")  # rogue_program.
      writer.print(of_type.cpp_name).print("->create_object()")

    method resolve( scope:Scope )->Cmd
      of_type.resolve
      args.resolve( scope )
      return this

    method type->Type
      return of_type
endClass


#------------------------------------------------------------------------------
# Assign
#------------------------------------------------------------------------------
class CmdAssign : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method resolve( scope:Scope )->Cmd
      return target.resolve_assignment( scope, new_value )
endClass

#------------------------------------------------------------------------------
# Read/Write
#------------------------------------------------------------------------------

class CmdReadThis : Cmd
  PROPERTIES
    this_type : Type

  METHODS
    method init( t, this_type )

    method print_cpp( writer:CPPWriter )
      writer.print "THIS"

    method resolve( scope:Scope )->Cmd
      this_type.resolve
      return this

    method type->Type
      return this_type
endClass

class CmdReadLocal : CmdAccessWithModify
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method print_cpp( writer:CPPWriter )
      if (premodify_count > 0) writer.print("++")
      elseIf (premodify_count < 0) writer.print("--")

      writer.print( local_info.name )

      if (postmodify_count > 0) writer.print("++")
      elseIf (postmodify_count < 0) writer.print("--")

    method resolve( scope:Scope )->Cmd
      local_info.type.resolve
      return this

    method type->Type
      return local_info.type
endClass


class CmdWriteLocal : Cmd
  PROPERTIES
    local_info : Local
    new_value  : Cmd

  METHODS
    method init( t, local_info, new_value )

    method print_cpp( writer:CPPWriter )
      writer.print( local_info.name ).print(" = ")
      new_value.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      local_info.type.resolve
      new_value = new_value.resolve(scope).require_value
      return this

    method type->Type
      return local_info.type
endClass


class CmdReadProperty : CmdAccessWithModify
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info )

    method print_cpp( writer:CPPWriter )
      if (premodify_count > 0) writer.print("++")
      elseIf (premodify_count < 0) writer.print("--")

      context.print_cpp( writer )
      writer.print("->").print( property_info.cpp_name )

      if (postmodify_count > 0) writer.print("++")
      elseIf (postmodify_count < 0) writer.print("--")

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope ).require_value
      return this

    method type->Type
      return property_info.type
endClass


class CmdWriteProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property
    new_value     : Cmd

  METHODS
    method init( t, context, property_info, new_value )

    method print_cpp( writer:CPPWriter )
      context.print_cpp( writer )
      writer.print("->").print( property_info.cpp_name ).print(" = ")
      new_value.print_cpp( writer )

    method resolve( scope:Scope )->Cmd
      context = context.resolve(scope).require_value
      new_value = new_value.resolve(scope).require_value
      return this

    method type->Type
      return property_info.type
endClass


#------------------------------------------------------------------------------
# Miscellaneous Expressions
#------------------------------------------------------------------------------
class CmdRange : Cmd
  PROPERTIES
    first : Cmd
    last  : Cmd
    step  : Cmd

  METHODS
    method init( t, first, last, step=null )
endClass

class CmdRangeUpTo : CmdRange
endClass


#------------------------------------------------------------------------------
# Unary Operators
#------------------------------------------------------------------------------
class CmdUnary : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method cpp_prefix_symbol->String
      return prefix_symbol

    method cpp_suffix_symbol->String
      return suffix_symbol

    method prefix_symbol->String
      return "("

    method print_cpp( writer:CPPWriter )
      writer.print( cpp_prefix_symbol )
      operand.print_cpp( writer )
      writer.print( cpp_suffix_symbol )

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      if (operand.is_literal) return resolve_for_literal_operand( scope )
      else                    return resolve_for_operand_type( scope, operand.require_type )

    method resolve_for_literal_operand( scope:Scope )->Cmd
      return this

    method resolve_for_operand_type( scope:Scope, operand_type:Type )->Cmd
      return this

    method suffix_symbol->String
      return ")"

    method type->Type
      return operand.type
endClass


class CmdLogicalNot : CmdUnary
  METHODS
    method cpp_prefix_symbol->String
      return "!"

    method cpp_suffix_symbol->String
      return ""

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal)
        return CmdLiteralLogical( t, not (operand as CmdLiteralReal).value )
      elseIf (operand instanceOf CmdLiteralInteger)
        return CmdLiteralLogical( t, not (operand as CmdLiteralInteger).value )
      endIf
      return this

    method type->Type
      return Program.type_Logical

endClass


class CmdNegate : CmdUnary
  METHODS
    method prefix_symbol->String
      return "(-"

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal)
        return CmdLiteralReal( t, -(operand as CmdLiteralReal).value )
      elseIf (operand instanceOf CmdLiteralInteger)
        return CmdLiteralInteger( t, -(operand as CmdLiteralInteger).value )
      endIf
      return this
endClass


#------------------------------------------------------------------------------
# Binary Operators
#------------------------------------------------------------------------------
class CmdBinary : Cmd
  PROPERTIES
    left   : Cmd
    right  : Cmd

  METHODS
    method init( t, left, right )

    method cpp_symbol->String
      return symbol

    method print_cpp( writer:CPPWriter )
      writer.print( "(" )
      left.print_cpp( writer )
      writer.print( " " ).print( cpp_symbol ).print( " " )
      right.print_cpp( writer )
      writer.print( ")" )

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope )
      right = right.resolve( scope )
      local left_type = left.require_type
      local right_type = right.require_type
      return resolve_for_types( scope, left.require_type, right.require_type )

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local common_type = find_common_type( left_type, right_type )
      left = left.cast_to( common_type )
      right = right.cast_to( common_type )
      if (left.is_literal and right.is_literal) return combine_literal_operands( common_type )
      return this

    method symbol->String
      throw t.error( "[INTERNAL] $::symbol() is not defined." (type_name) )

    method type->Type
      return left.type
endClass

class CmdAdd : CmdBinary
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value + (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value + (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "+"
endClass


class CmdSubtract : CmdBinary
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value - (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value - (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "-"
endClass

class CmdMultiply : CmdBinary
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value * (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value * (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "*"
endClass


class CmdDivide : CmdBinary
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value / (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value / (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "/"
endClass


class CmdMod : CmdBinary
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralReal( t, (left as CmdLiteralReal).value % (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralInteger( t, (left as CmdLiteralInteger).value % (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method print_cpp( writer:CPPWriter )
      writer.print( Program.program_name ).print( ".mod( " )
      left.print_cpp( writer )
      writer.print( ", " )
      right.print_cpp( writer )
      writer.print( " )" )

    method symbol->String
      return "%"
endClass


class CmdBinaryLogical : CmdBinary
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      throw t.error( "[INTERNAL] $::combine_literal_operands(Logical,Logical) is not defined." (type_name) )

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope ).require_logical
      right = right.resolve( scope ).require_logical
      if (left.is_literal and right.is_literal)
        return CmdLiteralLogical(
            t,
            combine_literal_operands(
                (left as CmdLiteralLogical).value,
                (right as CmdLiteralLogical).value
              )
          )
      endIf
      return this

    method type->Type
      return Program.type_Logical
endClass

class CmdLogicalAnd : CmdBinaryLogical
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a and b)

    method cpp_symbol->String
      return "&&"

    method symbol->String
      return "and"
endClass


class CmdLogicalOr : CmdBinaryLogical
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a or b)

    method cpp_symbol->String
      return "||"

    method symbol->String
      return "or"
endClass



class CmdLogicalXor : CmdBinaryLogical
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a xor b)

    method cpp_symbol->String
      return "^"

    method symbol->String
      return "xor"
endClass


#------------------------------------------------------------------------------
# Comparison Operators
#------------------------------------------------------------------------------
class CmdComparison : CmdBinary
  METHODS
    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local common_type = find_common_type( left_type, right_type )
      left = left.cast_to( common_type )
      right = right.cast_to( common_type )
      if (left.is_literal and right.is_literal) return combine_literal_operands( common_type )
      return this

    method type->Type
      return Program.type_Logical
endClass

class CmdCompareEQ : CmdComparison
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value == (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value == (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "=="
endClass

class CmdCompareNE : CmdComparison
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value != (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value != (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "!="
endClass

class CmdCompareLT : CmdComparison
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value < (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value < (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "<"
endClass

class CmdCompareLE : CmdComparison
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value <= (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value <= (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return "<="
endClass

class CmdCompareGT : CmdComparison
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value > (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value > (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return ">"
endClass

class CmdCompareGE : CmdComparison
  METHODS
    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real)
        return CmdLiteralLogical( t, (left as CmdLiteralReal).value >= (right as CmdLiteralReal).value )
      elseIf (common_type is Program.type_Integer)
        return CmdLiteralLogical( t, (left as CmdLiteralInteger).value >= (right as CmdLiteralInteger).value )
      else
        return this
      endIf

    method symbol->String
      return ">="
endClass

