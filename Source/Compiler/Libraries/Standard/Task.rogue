#------------------------------------------------------------------------------
# Task
#------------------------------------------------------------------------------
class Task
  METHODS
    method start->Task
      if (update()) TaskManager.add( this )
      return this

    method update->Logical
      return false  # return "true" to continue the task next time
endClass


class TaskWithResult<<$ResultType>> : Task
  PROPERTIES
    result : $ResultType

  METHODS
    method finish->$ResultType
      # Synchronously runs task until completion.  You can call
      # "await task" instead of "task.finish" to allow it to finish
      # concurrently.
      while (update()) noAction
      return result
endClass


#------------------------------------------------------------------------------
# TaskManager
#------------------------------------------------------------------------------
class TaskManager [requisite singleton]
  PROPERTIES
    active_list = Task[]
    update_list = Task[]

  METHODS
    method add( task:Task )->TaskManager
      active_list.add( task )
      return this

    method await_all( tasks:Task[] ) [task]
      local still_waiting = true
      while (still_waiting)
        still_waiting = false
        local i = tasks.count - 1
        while (i >= 0)
          local task = tasks[i]
          local active = false
          try
            active = task.update
          catch (error:Error)
            println "Uncaught error in task: " + error
          endTry
          if (active) still_waiting = true
          else        tasks.remove_at(i)
          --i
        endWhile
        if (still_waiting) yield
      endWhile

    method dispatch_events
      SystemEventQueue.begin_reading
      while (SystemEventQueue.has_another)
        println SystemEventQueue.read_string
      endWhile

    method update->Logical
      dispatch_events

      local any_active = false

      update_list.clear().add( active_list )
      active_list.clear()
      forEach (task in update_list)
        try
          if (task.update())
            # Active tasks stay in the list
            any_active = true
            active_list.add( task )
          endIf
        catch (error:Error)
          # task is implicitly removed from list
          println "Uncaught error in task: " + error
        endTry
      endForEach

      return any_active
endClass

class SystemEventQueue
  ROUTINES
    routine begin_reading
      inlineNative "Rogue_program.event_queue.begin_reading()"

    routine has_another->Logical
      inlineNative "Rogue_program.event_queue.has_another()"

    routine read_byte->Byte
      inlineNative "Rogue_program.event_queue.read_byte()"

    routine read_character->Character
      inlineNative "Rogue_program.event_queue.read_character()"

    routine read_integer->Integer
      inlineNative "Rogue_program.event_queue.read_integer()"

    routine read_logical->Logical
      inlineNative "Rogue_program.event_queue.read_logical()"

    routine read_real->Real
      inlineNative "Rogue_program.event_queue.read_real()"

    routine read_string->String
      inlineNative "Rogue_program.event_queue.read_string()"
endClass
