$[include "Local.bard"]

class Method
  PROPERTIES
    t            : Token
    type_context : Type
    name         : String
    signature    : String

    cpp_name     : String
    cpp_typedef  : String

    attributes   = Attributes()

    return_type  : Type

    parameters = Local[] : Local[]
    locals     = Local[] : Local[]

    min_args     : Integer

    statements = CmdStatementList()

    generic_method : Method
    native_code    : String

    resolved  : Logical
    index     : Integer

  METHODS
    method init( t, type_context, name )

    method accepts_arg_count( n:Integer )->Logical
      return n >= min_args and n <= parameters.count

    method add_local( v_t:Token, v_name:String, v_type=null:Type )->Local
      local v = Local( v_t, v_name )
      v.index = locals.count
      v.type = v_type
      locals.add( v )
      return v

    method add_parameter( p_t:Token, p_name:String )->Local
      local p = add_local( p_t, p_name )
      parameters.add( p )
      return p

    method assign_cpp_name
      if (cpp_name?) return
      local buffer = StringBuilder()
      buffer.print( Program.code_prefix )
      buffer.print( type_context.name ).print( "__" )
      buffer.print( name )
      cpp_name = Program.validate_cpp_name( buffer->String )

    method assign_signature
      if (signature?) return
      local buffer = StringBuilder()
      buffer.print name
      buffer.print "("
      local first = true
      forEach (param in parameters)
        if (first) first = false
        else       buffer.print( "," )
        buffer.print( param.type.name )
      endForEach
      buffer.print ")"
      signature = buffer->String

    method compile_target->Method
      if (generic_method?) return generic_method
      return this

    method is_dynamic->Logical
      return (attributes.flags & Attribute.is_dynamic)?

    method is_initializer->Logical
      return (attributes.flags & Attribute.is_initializer)?

    method is_inline->Logical
      return (attributes.flags & Attribute.is_inline)?

    method is_native->Logical
      return (attributes.flags & Attribute.is_native)?

    method is_overridden->Logical
      return (attributes.flags & Attribute.is_overridden)?

    method is_routine->Logical
      return (attributes.flags & Attribute.is_routine)?

    method organize->Method
      if (name == "init")
        attributes.flags |= Attribute.is_initializer
        return_type = type_context
      endIf

      forEach (param in parameters)
        if (not is_routine) 
          local property = type_context.find_property( param.name )

          if (property?)
            if (param.type is null)
              # Autostore parameter
              local new_name = Program.create_unique_id
              local pt = property.t
              statements.insert( CmdAssign(pt,CmdAccess(pt,property.name),CmdAccess(pt,new_name)) )
              param.name = new_name
              param.type = property.type
            else
              throw param.t.error( //A property named "$" already exists.// (param.name) )
            endIf
          endIf
        endIf

        if (not param.type) throw param.t.error( //No type declared for parameter "$".// (param.name) )
        param.type.organize
      endForEach

      if (return_type?) return_type.organize

      assign_signature

      # Add method to type's lookup table.
      if (is_routine)
        local existing_m = type_context.routine_lookup_by_signature[signature]
        if (existing_m? and existing_m.type_context is type_context)
          throw t.error( "A routine with the signature $ is already defined." (signature) )
        endIf
        type_context.routine_lookup_by_signature[signature] = this
      else
        local existing_m = type_context.method_lookup_by_signature[signature]
        if (existing_m? and existing_m.type_context is type_context)
          throw t.error( "A method with the signature $ is already defined." (signature) )
        endIf
        type_context.method_lookup_by_signature[signature] = this
      endIf

      min_args = parameters.count
      while (min_args >= 1 and parameters[min_args-1].initial_value?)
        --min_args
      endWhile

      return this

    method print_prototype( writer:CPPWriter )
      if (is_native or is_inline) return
      print_signature( writer )
      writer.println( ";" )

    method print_signature( writer:CPPWriter )
      writer.print( return_type ).print(" ").print( cpp_name )
      writer.print( "(" )
      local first = true
      if (not is_routine)
        first = false
        writer.print( " " )
        writer.print( type_context )
        writer.print( " THIS" )
      endIf
      if (parameters.count?)
        forEach (param in parameters)
          if (first) writer.print( " " ); first = false
          else       writer.print( ", " )
          writer.print( param.type ).print( " " ).print( param.cpp_name )
        endForEach
      endIf
      if (not first) writer.print( " " )
      writer.print( ")" )

    method print_definition( writer:CPPWriter )
      if (is_native or is_inline) return
      print_signature( writer )
      writer.println
      writer.println "{"
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println "}"
      writer.println


    method resolve
      if (resolved) return
      resolved = true

      if (type_context.generic_type?)
        # Find the generic version of this method
        type_context.generic_type.organize
        local buffer = StringBuilder()
        buffer.print( name ).print( "(" )

        local first = true
        forEach (p in parameters)
          if (first) first = false
          else       buffer.print( "," )
          if (p.generic_type?) buffer.print( p.generic_type.name )
          else                 buffer.print( p.type.name )
        endForEach

        buffer.print( ")" )

        local generic_sig = buffer->String
        generic_method = type_context.generic_type.find_method( generic_sig )
        if (not generic_method)
          throw t.error( "[INTERNAL] Could not find generic mapping of $::$ -> $::$" (type_context,signature,type_context.generic_type,generic_sig) )
        endIf
      endIf

      local scope = Scope( type_context, this )
      forEach (p in parameters) scope.push_local( p )

      statements.resolve( scope )

      if (is_initializer)
        local return_t = t
        if (statements.count?) return_t = statements.last.t
        statements.add( CmdReturn(return_t,CmdLiteralThis(return_t,type_context)).resolve(scope) )
      endIf

    method to->String
      return signature
endClass

