$[include "Local.bard"]

class Method
  PROPERTIES
    t            : Token
    type_context : Type
    name         : String
    signature    : String
    cpp_name     : String
    attributes   : Integer

    return_type  : Type

    parameters = Local[] : Local[]
    locals     = Local[] : Local[]

    statements = CmdStatementList()

    native_code : String

    resolved  : Logical

  METHODS
    method init( t, type_context, name )

    method accepts_arg_count( n:Integer )->Logical
      return n == parameters.count

    method add_local( v_t:Token, v_name:String )->Local
      local v = Local( v_t, v_name )
      v.index = locals.count
      locals.add( v )
      return v

    method add_parameter( p_t:Token, p_name:String )->Local
      local p = add_local( p_t, p_name )
      parameters.add( p )
      return p

    method assign_cpp_name
      local buffer = StringBuilder()
      buffer.print( Program.code_prefix )
      buffer.print( type_context.name ).print( "__" )
      buffer.print( name )
      cpp_name = Program.validate_cpp_name( buffer->String )

    method assign_signature
      local buffer = StringBuilder()
      buffer.print name
      buffer.print "("
      buffer.print ")"
      signature = buffer->String

      type_context.method_lookup_by_signature[signature] = this

    method is_initializer->Logical
      return (attributes & Attributes.flag_initializer)?

    method is_native->Logical
      return (attributes & Attributes.flag_native)?

    method organize
      if (name == "init")
        attributes |= Attributes.flag_initializer
        return_type = type_context
      endIf

      assign_signature

    method print_prototype( writer:CPPWriter )
      if (is_native) return
      print_signature( writer )
      writer.println( ";" )

    method print_signature( writer:CPPWriter )
      writer.print( return_type ).print(" ").print( cpp_name )
      writer.print( "( " )
      writer.print( type_context )
      writer.print( " THIS" )
      forEach (param in parameters)
        writer.print( ", " ).print( param.type ).print( " " ).print( param.cpp_name )
      endForEach
      writer.print( " )" )

    method print_definition( writer:CPPWriter )
      if (is_native) return
      print_signature( writer )
      writer.println
      writer.println "{"
      writer.indent += 2
      statements.print_cpp( writer )
      writer.indent -= 2
      writer.println "}"
      writer.println


    method resolve
      if (resolved) return
      resolved = true

      forEach (p in parameters)
        local property = type_context.find_property( p.name )

        if (property?)
          throw p.t.error( //A property named "$" already exists.// (p.name) )
        endIf

        if (not p.type) throw p.t.error( //No type declared for parameter "$".// (p.name) )
        p.type.resolve

      endForEach

      if (return_type?) return_type.resolve

      local scope = Scope( type_context, this )
      forEach (p in parameters) scope.push_local( p )

      statements.resolve( scope )

      if (is_initializer)
        local return_t = t
        if (statements.count?) return_t = statements.last.t
        statements.add( CmdReturn(return_t,CmdReadThis(return_t,type_context)).resolve(scope) )
      endIf
endClass

