$[include "Cmd.bard"]
$[include "Method.bard"]
$[include "Property.bard"]
$[include "TypeTemplate.bard"]

class Parser
  PROPERTIES
    reader      : TokenReader
    this_type   : Type
    this_method : Method

    local_declarations = Local[]  # repeated temporary use
    property_list = Property[]    # temp use

  METHODS
    method init( filepath:String )
      init( Preprocessor().process(Tokenizer().tokenize(filepath)) )

    method init( filepath:String, data:String )
      init( Preprocessor().process(Tokenizer().tokenize(filepath)) )

    method init( tokens:Token[] )
      reader = TokenReader( tokens )

    method consume( type:TokenType )->Logical
      if (not reader.next_is(type)) return false
      reader.read
      return true

    method consume_end_commands->Logical
      local found = false
      while (consume(TokenType.eol) or consume(TokenType.symbol_semicolon)) found = true
      return found

    method consume_eols->Logical
      local found_any = false
      while (consume(TokenType.eol)) found_any = true
      return found_any

    method error( message:String )->RogueError
      throw reader.peek.error( message )

    method must_consume( type:TokenType, error_message=null:String )
      if (consume(type)) return
      local t = peek
      if (not error_message)
        error_message = "$ expected, found $." (type.quoted_name,t.quoted_name)
      endIf
      throw t.error( error_message )

    method must_consume_eols
      must_consume( Token.eol )
      consume_eols

    method must_read( type:TokenType )->Token
      local t = reader.peek
      if (t.type isNot type) must_consume(type)
      return reader.read

    method next_is( type:TokenType )->Logical
      return reader.next_is( type )

    method next_is_end_command->Logical
      if (not reader.has_another) return false
      local type = reader.peek.type
      return (type is TokenType.eol or type is TokenType.symbol_semicolon)

    method next_is_statement->Logical
      if (not reader.has_another) return false
      return reader.next_is_statement_token

    method parse_elements
      while (parse_element) noAction

      if (reader.has_another)
        local t = peek
        throw t.error( "Syntax error - unexpected $." (t.quoted_name) )
      endIf

    method parse_element->Logical
      consume_eols
      local t = peek

      if (t.type is TokenType.keyword_class)
        parse_class_template
        return true

      elseIf (t.type is TokenType.keyword_primitive)
        parse_primitive_template
        return true
      endIf

      return false

    method parse_class_template
      local t = read  # 'class'
      local name = read_identifier
      local template = TypeTemplate( t, name, Attributes.flag_reference_type )
      parse_template_tokens( template, TokenType.keyword_endClass )

      if (not Program.implicit_main_class_t)
        Program.implicit_main_class_t    = t
        Program.implicit_main_class_name = name
      endIf

    method parse_primitive_template
      local t = read  # 'primitive'
      local name = read_identifier
      local template = TypeTemplate( t, name, Attributes.flag_primitive_type )
      parse_template_tokens( template, TokenType.keyword_endPrimitive )

    method parse_template_tokens( template:TypeTemplate, end_type:TokenType )
      while (reader.has_another)
        local t = reader.read
        if (t.type is end_type)
          Program.template_list.add( template )
          Program.template_lookup[template.name] = template
          return
        endIf
        template.tokens.add( t )
      endWhile

      throw reader.error( "$ expected, found end of file." (end_type.quoted_name) )

    method parse_type_def( this_type )
      while (parse_section) noAction
      if (reader.has_another)
        throw peek.error( "Syntax error - unexpected $." (peek.quoted_name) )
      endIf

    method parse_section->Logical
      consume_eols

      if (consume(TokenType.keyword_PROPERTIES))
        while (parse_properties) noAction
        return true
      endIf

      if (consume(TokenType.keyword_METHODS))
        while (parse_method) noAction
        return true
      endIf

      return false

    method parse_properties->Logical
      consume_eols
      if (not next_is(TokenType.identifier)) return false

      property_list.clear
      # Stores current property declarations so that we can come back and
      # and assign a type to them.

      local first = true
      while (first or consume(TokenType.symbol_comma))
        first = false
        consume_eols
        local t = must_read(TokenType.identifier)
        local p = this_type.add_property( t, t->String )
        property_list.add( p )
        if (consume(TokenType.symbol_equals))
          p.initial_value = parse_expression
        endIf
      endWhile

      consume_eols
      if (consume(TokenType.symbol_colon))
        local p_type = parse_type
        forEach (p in property_list) p.type = p_type
      else
        forEach (p in property_list)
          if (p.initial_value?)
            p.type = p.initial_value.implicit_type
            if (p.type is null) 
              throw p.initial_value.t.error( 
                //Cannot determine property type from initial value; // +
                //append an explicit type declaration such as ": Object" // )
            endIf
          else
            throw p.t.error( //An initial value or property type (for example, ": Object") must be specified.// )
          endIf
        endForEach
      endIf

      return true

    method parse_method->Logical
      consume_eols
      if (not next_is(TokenType.keyword_method)) return false

      local t = read
      local name = read_identifier
      this_method = Method( t, this_type, name )
      this_type.method_list.add( this_method )

      parse_multi_line_statements( this_method.statements )
      return true

    method parse_multi_line_statements( statements:CmdStatementList )
      consume_end_commands
      while (next_is_statement)
        parse_statement( statements, true )
        while (consume(TokenType.eol) or consume(TokenType.symbol_semicolon)) noAction
        consume_end_commands
      endWhile

    method parse_statement( statements:CmdStatementList, allow_control_structures:Logical )
      local t = peek

      #{
      if (next_is(Token.keyword_delegate))
        throw t.error( "Unused delegate definition." )
      endIf

      if (allow_control_structures)
        if (next_is(Token.keyword_if))
          statements.add( parse_if )
          return

        elseIf (next_is(Token.keyword_which))
          statements.add( parse_which )
          return

        elseIf (next_is(Token.keyword_whichIs))
          statements.add( parse_which( true ) )
          return

        elseIf (next_is(Token.keyword_forEach))
          statements.add( parse_forEach )
          return

        elseIf (next_is(Token.keyword_contingent))
          statements.add( parse_contingent )
          return

        elseIf (next_is(Token.keyword_while))
          statements.add( parse_while )
          return

        elseIf (next_is(Token.keyword_loop))
          statements.add( parse_loop )
          return

        elseIf (next_is(Token.keyword_try))
          statements.add( parse_try )
          return

        endIf
      else
        local err = false
        if (next_is(Token.keyword_if)) err = true
        if (err) throw t.error( "Control structures must begin on a separate line." )
      endIf
      }#

      if (next_is(TokenType.keyword_local))
        parse_local_declaration( statements )
        return

        #{
      elseIf (consume(Token.keyword_return))

        if (next_is_end_command)
          statements.add( CmdReturnNil(t) )
        else
          statements.add( CmdReturnValue(t,parse_expression) )
        endIf
        return

      elseIf (consume(Token.keyword_yield))

        if (next_is_end_command)
          statements.add( CmdYieldNil(t) )
        elseIf (this_method.is_task and this_method.return_type is null)
          throw t.error( "This task does not declare a return type." )
        else
          statements.add( CmdYieldValue(t,parse_expression) )
        endIf
        return

      elseIf (consume(Token.keyword_yieldAndWait))
        statements.add( CmdYieldAndWait(t,parse_expression) )
        return

      elseIf (consume(Token.keyword_yieldWhile))
        local cmd_while = CmdWhile( t, parse_expression )

        if (consume(Token.keyword_withTimeout))
          local t2 = peek
          local timeout_expr = parse_expression
          local timeout_name = "_timeout_" + Analyzer.unique_id
          cmd_while.condition = CmdLogicalAnd( t2,
            CmdCompareLT( t2, CmdAccess(t2, "Time", "current"), CmdAccess(t2,timeout_name) ),
            cmd_while.condition )

          local v = Local( t2, timeout_name )
          this_method.add_local( v )
          statements.add( CmdLocalDeclaration( t2, v ) )
          statements.add( 
            CmdWriteLocal( t2, v, 
              CmdAdd( t2,
                CmdAccess(t2,"Time","current"),
                timeout_expr
              )
            )
          )
        endIf

        cmd_while.body.add( CmdYieldNil(t) )
        statements.add( cmd_while )

        return

      elseIf (consume(Token.keyword_throw))
        statements.add( CmdThrow(t,parse_expression) )
        return

      elseIf (consume(Token.keyword_noAction))
        noAction
        return

      elseIf (consume(Token.keyword_trace))
        local cmd_trace = CmdTrace(t,this_method)
        while (reader.has_another)
          if (next_is(Token.symbol_semicolon) or next_is(Token.eol) or next_is(Token.symbol_close_brace))
            escapeWhile
          endIf

          local pos1 = reader.position
          t = peek
          if (consume(Token.symbol_comma))
            cmd_trace.labels.add(", ")
            cmd_trace.expressions.add( CmdLiteralString(t,", ") )
          else
            cmd_trace.expressions.add( parse_expression )
            cmd_trace.labels.add( reader.source_string(pos1,reader.position-1) )
          endIf

        endWhile
        statements.add( cmd_trace )
        return

      elseIf (consume(Token.keyword_tron))
        statements.add( CmdTron(t) )
        return

      elseIf (consume(Token.keyword_troff))
        statements.add( CmdTroff(t) )
        return
      }#

      endIf

      if (consume(TokenType.keyword_println))
        if (next_is_end_command) statements.add( CmdPrintln(t) )
        else                     statements.add( CmdPrintln(t, parse_expression) )
        return
      endIf

      #{
      if (consume(Token.keyword_escapeContingent))
        statements.add( CmdEscapeContingent(t) )
        return
      endIf

      if (consume(Token.keyword_escapeForEach))
        statements.add( CmdEscapeForEach(t) )
        return
      endIf

      if (consume(Token.keyword_escapeIf))
        statements.add( CmdEscapeIf(t) )
        return
      endIf

      if (consume(Token.keyword_escapeLoop))
        statements.add( CmdEscapeLoop(t) )
        return
      endIf

      if (consume(Token.keyword_escapeTry))
        statements.add( CmdEscapeTry(t) )
        return
      endIf

      if (consume(Token.keyword_escapeWhich))
        statements.add( CmdEscapeWhich(t) )
        return
      endIf

      if (consume(Token.keyword_escapeWhile))
        statements.add( CmdEscapeWhile(t) )
        return
      endIf

      if (consume(Token.keyword_nextIteration))
        statements.add( CmdNextIteration(t) )
        return
      endIf

      if (consume(Token.keyword_necessary))
        statements.add( CmdNecessary(t, parse_expression))
        return
      endIf

      if (consume(Token.keyword_sufficient))
        statements.add( CmdSufficient(t, parse_expression))
        return
      endIf

      if (consume(Token.symbol_increment))
        statements.add( CmdIncrement(t, parse_expression) )
        return
      endIf

      if (consume(Token.symbol_decrement))
        statements.add( CmdDecrement(t, parse_expression) )
        return
      endIf
      }#

      local expression = parse_expression

      t = peek
      if (consume(TokenType.symbol_equals))
        statements.add( CmdAssign(t,expression,parse_expression) )
        return
      endIf

      #{
      if (consume(Token.symbol_access_assign))
        local rhs = parse_expression
        local access = rhs as CmdAccess
        if (access is null) throw rhs.error( "Property access or method call expected." )
        while (access.operand?)
          local operand = access.operand as CmdAccess
          if (operand is null) throw access.operand.t.error( "Property access or method call expected." )
          access = operand
        endWhile
        access.operand = expression.clone
        statements.add( CmdAssign(t,expression,access) )
      endIf
      }#

      #{
      if (consume(Token.symbol_increment))
        statements.add( CmdIncrement(t, expression) )
        return
      endIf

      if (consume(Token.symbol_decrement))
        statements.add( CmdDecrement(t, expression) )
        return
      endIf

      local t_type = t.type
      if (t_type >= Token.first_shorthand_operator and t_type <= Token.last_shorthand_operator)
        read
        local lhs = expression.clone
        local rhs = parse_expression
        local new_value : Cmd

        which (t_type)
          case Token.symbol_add_assign:          new_value = CmdAdd( t, lhs, rhs )
          case Token.symbol_subtract_assign:     new_value = CmdSubtract( t, lhs, rhs )
          case Token.symbol_multiply_assign:     new_value = CmdMultiply( t, lhs, rhs )
          case Token.symbol_divide_assign:       new_value = CmdDivide( t, lhs, rhs )
          case Token.symbol_mod_assign:          new_value = CmdMod( t, lhs, rhs )
          case Token.symbol_power_assign:        new_value = CmdPower( t, lhs, rhs )
          case Token.symbol_bitwise_and_assign:  new_value = CmdBitwiseAnd( t, lhs, rhs )
          case Token.symbol_bitwise_or_assign:   new_value = CmdBitwiseOr( t, lhs, rhs )
          case Token.symbol_bitwise_xor_assign:  new_value = CmdBitwiseXor( t, lhs, rhs )
          case Token.symbol_access_assign
            local access = rhs as CmdAccess
            if (access is null or access.operand?) throw t.error( "Syntax error." )
            access.operand = lhs
            new_value = access
        endWhich
        statements.add( CmdAssign(t, expression, new_value) )
        return
      endIf

      # No-parens args can follow an initial expression
      if (not next_is_end_command)
        local access = expression as CmdAccess
        if (access? and access.args is null)
          local args = CmdArgs()
          while (not next_is_end_command and peek.type >= Token.last_non_statement)
            args.add( parse_expression )
          endWhile
          access.args = args
        endIf
      endIf
      }#

      statements.add( expression )

    method parse_local_declaration( statements:CmdStatementList )
      local_declarations.clear
      local t = read   # "local"

      # local[=initial_value] [, ...]
      local first = true
      while (first or consume(TokenType.symbol_comma))
        first = false
        t = peek
        local name = read_identifier
        local v = this_method.add_local( t, name )
        local_declarations.add( v )
        if (consume(TokenType.symbol_equals)) v.initial_value = parse_expression
      endWhile

      # [: Type]
      if (consume(TokenType.symbol_colon))
        local type = parse_type
        forEach (v in local_declarations) v.type = type
      else
        forEach (v in local_declarations)
          if (v.type is null and v.initial_value?)
            v.type = v.initial_value.implicit_type
          endIf
        endForEach
      endIf

      # Turn each declaration into a separate CmdLocalDeclaration
      forEach (v in local_declarations)
        statements.add( CmdLocalDeclaration(v.t,v) )
      endForEach

    method parse_type->Type
      local t = peek
      local name = parse_possible_type
      return Program.get_type_reference( t, name )

    method parse_possible_type->String
      local t = peek
      local name = read_identifier

      #name = parse_delegate_or_task_type_name( t, name )

      #if (next_is(TokenType.symbol_open_specialize)) name += parse_specialization_string

      while (consume(TokenType.symbol_empty_brackets)) name += "[]"
      return name

    method peek->Token
      return reader.peek

    method read->Token
      return reader.read

    method read_identifier->String
      if (not next_is(TokenType.identifier))
        throw error( "Identifier expected, found $." (peek.quoted_name) )
      endIf
      return read->String

    method parse_expression->Cmd
      consume_eols
      return parse_add_subtract
      #{
      return parse_range

    method parse_range->Cmd
      return parse_range( parse_logical_xor )

    method parse_range( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_upTo))
        return CmdRangeUpTo( t, lhs, parse_logical_xor )
      elseIf (consume(Token.symbol_upToLessThan))
        return CmdRangeUpToLessThan( t, lhs, parse_logical_xor )
      elseIf (consume(Token.symbol_downToGreaterThan))
        return CmdRangeDownToGreaterThan( t, lhs, parse_logical_xor )
      elseIf (consume(Token.keyword_downTo))
        return CmdRangeDownTo( t, lhs, parse_logical_xor )
      else
        return lhs
      endIf

    method parse_logical_xor->Cmd
      return parse_logical_xor( parse_logical_or )

    method parse_logical_xor( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.keyword_xor))
        consume_eols
        return parse_logical_xor( CmdLogicalXor(t, lhs, parse_logical_or) )
      endIf
      return lhs

    method parse_logical_or->Cmd
      return parse_logical_or( parse_logical_and )

    method parse_logical_or( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.keyword_or))
        consume_eols
        return parse_logical_or( CmdLogicalOr(t, lhs, parse_logical_and) )
      endIf
      return lhs

    method parse_logical_and->Cmd
      return parse_logical_and( parse_comparison )

    method parse_logical_and( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.keyword_and))
        consume_eols
        return parse_logical_and( CmdLogicalAnd(t, lhs, parse_comparison) )
      endIf
      return lhs

    method parse_comparison->Cmd
      return parse_comparison( parse_bitwise_xor )

    method parse_comparison( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_eq))
        consume_eols
        return parse_comparison( CmdCompareEQ(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.keyword_is))
        consume_eols
        return parse_comparison( CmdCompareIs(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.symbol_ne))
        consume_eols
        return parse_comparison( CmdCompareNE(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.keyword_isNot))
        consume_eols
        return parse_comparison( CmdCompareIsNot(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.symbol_lt))
        consume_eols
        return parse_comparison( CmdCompareLT(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.symbol_gt))
        consume_eols
        return parse_comparison( CmdCompareGT(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.symbol_le))
        consume_eols
        return parse_comparison( CmdCompareLE(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.symbol_ge))
        consume_eols
        return parse_comparison( CmdCompareGE(t, lhs, parse_bitwise_xor) )
      elseIf (consume(Token.keyword_instanceOf))
        consume_eols
        return CmdInstanceOf( t, lhs, parse_type )
      elseIf (consume(Token.keyword_notInstanceOf))
        consume_eols
        return CmdLogicalNot( t, CmdInstanceOf( t, lhs, parse_type ) )
      endIf
      return lhs

    method parse_bitwise_xor->Cmd
      return parse_bitwise_xor( parse_bitwise_or )

    method parse_bitwise_xor( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_bitwise_xor))
        consume_eols
        return parse_bitwise_xor( CmdBitwiseXor(t,lhs,parse_bitwise_or) )
      endIf
      return lhs

    method parse_bitwise_or->Cmd
      return parse_bitwise_or( parse_bitwise_and )

    method parse_bitwise_or( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_bitwise_or))
        consume_eols
        return parse_bitwise_or( CmdBitwiseOr(t,lhs,parse_bitwise_and) )
      endIf
      return lhs

    method parse_bitwise_and->Cmd
      return parse_bitwise_and( parse_bitwise_shift )

    method parse_bitwise_and( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_ampersand))
        consume_eols
        return parse_bitwise_and( CmdBitwiseAnd(t,lhs,parse_bitwise_shift) )
      endIf
      return lhs

    method parse_bitwise_shift->Cmd
      return parse_bitwise_shift( parse_add_subtract )

    method parse_bitwise_shift( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_shl))
        consume_eols
        return parse_add_subtract( CmdBitwiseSHL(t,lhs,parse_add_subtract) )
      elseIf (consume(Token.symbol_shr))
        consume_eols
        return parse_add_subtract( CmdBitwiseSHR(t,lhs,parse_add_subtract) )
      elseIf (consume(Token.symbol_shrx))
        consume_eols
        return parse_add_subtract( CmdBitwiseSHRX(t,lhs,parse_add_subtract) )
      endIf
      return lhs
      }#

    method parse_add_subtract->Cmd
      return parse_add_subtract( parse_multiply_divide_mod )

    method parse_add_subtract( lhs:Cmd )->Cmd
      local t = peek
      if (consume(TokenType.symbol_plus))
        consume_eols
        return parse_add_subtract( CmdAdd(t,lhs,parse_multiply_divide_mod) )
      elseIf (consume(TokenType.symbol_minus))
        consume_eols
        return parse_add_subtract( CmdSubtract(t,lhs,parse_multiply_divide_mod) )
      endIf
      return lhs

    method parse_multiply_divide_mod->Cmd
      return parse_pre_unary
      #{
      return parse_multiply_divide_mod( parse_power )

    method parse_multiply_divide_mod( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_times))
        consume_eols
        return parse_multiply_divide_mod( CmdMultiply(t,lhs,parse_power) )
      elseIf (consume(Token.symbol_divide))
        consume_eols
        return parse_multiply_divide_mod( CmdDivide(t,lhs,parse_power) )
      elseIf (consume(Token.symbol_percent))
        consume_eols
        return parse_multiply_divide_mod( CmdMod(t,lhs,parse_power) )
      endIf
      return lhs

    method parse_power->Cmd
      return parse_power( parse_pre_unary )

    method parse_power( lhs:Cmd )->Cmd
      local t = peek
      if (consume(Token.symbol_power))
        consume_eols
        return parse_power( CmdPower(t,lhs,parse_pre_unary) )
      endIf
      return lhs
      }#

    method parse_pre_unary->Cmd
      local t = peek
      if (consume(TokenType.symbol_plus_plus))
        consume_eols
        local operand = parse_pre_unary
        operand.premodify(1)
        return operand

      elseIf (consume(TokenType.symbol_minus_minus))
        consume_eols
        local operand = parse_pre_unary
        operand.premodify(-1)
        return operand

      #{
      if (consume(Token.keyword_not))
        consume_eols
        return CmdLogicalNot( t, parse_pre_unary )
      elseIf (consume(Token.symbol_minus))
        consume_eols
        return CmdNegate( t, parse_pre_unary )
      elseIf (consume(Token.symbol_bitwise_not))
        consume_eols
        return CmdBitwiseNot( t, parse_pre_unary )
      }#
      endIf
      return parse_post_unary

    method parse_post_unary->Cmd
      return parse_post_unary( parse_delegate_access )

    method parse_post_unary( operand:Cmd )->Cmd
      local t = peek
      #{
      if (consume(TokenType.symbol_question_mark))
        return parse_post_unary( CmdLogicalize(t,operand) )
        }#
      if (consume(TokenType.symbol_plus_plus))
        parse_post_unary( operand.postmodify(1) )
      elseIf (consume(TokenType.symbol_minus_minus))
        parse_post_unary( operand.postmodify(-1) )
      endIf
      return operand


    method parse_delegate_access->Cmd
      return parse_delegate_access( parse_member_access )

    method parse_delegate_access( lhs:Cmd )->Cmd
      #{
      local t = peek
      if(consume(Token.symbol_scope))
        local cmd_delegate : CmdDelegate

        local delegate_method_name = peek->String
        must_consume( Token.identifier )

        if (not next_is(Token.symbol_open_paren)) return CmdUnqualifiedDelegateSelector( t, lhs, delegate_method_name )

        local buffer        = StringBuilder()
        local sig_buffer    = StringBuilder()
        local param_types = Type[]
        local ret_type : Type

        sig_buffer.print( delegate_method_name )
        if (consume( Token.symbol_open_paren ))
          sig_buffer.print( "(" )
          if (consume( Token.symbol_close_paren ))
            sig_buffer.print( ")" )
          else
            param_types.add( parse_type )
            buffer.print( param_types.last->String )
            sig_buffer.print( param_types.last->String )

            while (consume( Token.symbol_comma ))
              buffer.print( "_" )
              sig_buffer.print(",")
              param_types.add( parse_type )
              buffer.print( param_types.last->String )
              sig_buffer.print( param_types.last->String )
            endWhile
            must_consume( Token.symbol_close_paren )
            sig_buffer.print( ")" )

          endIf
        else
          sig_buffer.print("()")
        endIf

        if (consume( Token.symbol_arrow ))
          ret_type = parse_type
          buffer.print( "__" + ret_type.name )
          sig_buffer.print( "->" + ret_type.name )
        endIf

        local base_class_name = "Delegate__"
        if (buffer.count?) base_class_name += buffer->String

        # if (not ret_type?) base_class_name += "NORETURN"
        local extended_class_name = "Delegate__" + lhs.type + "__" + ...
                                           delegate_method_name + ...
                                           "__" + buffer->String

        cmd_delegate = CmdDelegate( t, lhs, delegate_method_name, ...
                                    sig_buffer->String, base_class_name, ...
                                    extended_class_name, param_types, ret_type )
        return cmd_delegate

      endIf
      }#

      return lhs


    method parse_member_access->Cmd
      return parse_member_access( parse_term )

    method parse_member_access( context:Cmd )->Cmd
      local t = peek

      if (consume(TokenType.symbol_dot))
        # Part access e.g. obj.value
        local access = parse_access( t )
        access.context = context
        return parse_member_access( access )

      #{
      elseIf (consume(TokenType.symbol_open_bracket))
        # Parse obj[index]
        consume_eols
        local access = CmdElementAccess( t, context )
        local first = true
        while (first or consume(TokenType.symbol_comma))
          first = false
          access.args.add( parse_expression )
          consume_eols
        endWhile
        consume_eols
        must_consume( TokenType.symbol_close_bracket )
        return parse_member_access( access )

      elseIf (consume(TokenType.symbol_arrow))
        # Conversion operation e.g. value->Integer
        consume_eols
        local to_type = parse_type
        local args = parse_args

        if (args?)
          # context->Type(args) -> context.to(args)->Type
          return parse_member_access( CmdConvertToType( t, CmdAccess(t,context,"to_"+to_type,args), to_type ) )
        endIf

        return parse_member_access( CmdConvertToType(t,context,to_type) )

      elseIf (consume(TokenType.keyword_as))
        # Recast operation e.g. 65 as Character
        consume_eols
        local as_type = parse_type
        return parse_member_access( CmdRecastAsType(t,context,as_type) )
      }#

      endIf

      return context

    method parse_access( t:Token )->CmdAccess
      consume_eols

      local direct_access = consume( TokenType.symbol_at )

      local name = read_identifier
      #name = parse_delegate_or_task_type_name( t, name )
      #if (next_is(Token.symbol_open_specialize)) name += parse_specialization_string

      while (consume(TokenType.symbol_empty_brackets)) name += "[]"

      if (direct_access) name = "@" + name

      local access = CmdAccess( t, name )
      access.args = parse_args
      return access

    # TODO: Add multi-line handling
    method parse_args(start_type=TokenType.symbol_open_paren:TokenType,end_type=TokenType.symbol_close_paren:TokenType)->CmdArgs
      if (not consume(start_type)) return null
      consume_eols

      local args = CmdArgs()
      if (not consume(end_type))
        local first = true
        while (first or consume(TokenType.symbol_comma))
          consume_eols
          first = false
          args.add( parse_expression )
        endWhile
        consume_eols
        must_consume( end_type )
      endIf

      return args

      #{
    method parse_specialization_string->String
      if (not next_is(Token.symbol_open_specialize)) return ""

      string_buffer.clear
      consume( Token.symbol_open_specialize )
      string_buffer.print( "<<" )
      local nesting_level = 1
      while (reader.has_another)
        if (next_is(Token.eol))
          throw peek.error( "Closing '>>' expected before end of line." )
        elseIf (consume(Token.symbol_open_specialize))
          string_buffer.print("<<")
          ++nesting_level
        elseIf (consume(Token.symbol_close_specialize))
          --nesting_level
          if (nesting_level == 0)
            escapeWhile
          else
            string_buffer.print( ">>" )
          endIf
        else
          string_buffer.print( read->String )
        endIf
      endWhile
      string_buffer.print( ">>" )

      return string_buffer->String
      }#

    method parse_term->Cmd
      local t = peek
      if (consume(TokenType.symbol_open_paren))
        consume_eols
        if (next_is(TokenType.symbol_close_paren))
          throw t.error( "Value expected, found empty parentheses ()." )
        endIf
        local result = parse_expression
        consume_eols
        must_consume( TokenType.symbol_close_paren )
        return result

      elseIf (next_is(TokenType.identifier) or next_is(TokenType.symbol_at))
        local result = parse_access( t )
        return result

      elseIf (consume(TokenType.literal_string))

        #{
        if (consume(Token.symbol_open_paren))
          local first = true
          local args = CmdArgs()
          while (first or consume(Token.symbol_comma))
            first = false
            args.add( parse_expression )
          endWhile
          must_consume( Token.symbol_close_paren )
          return CmdFormattedString( t, t->String, args )
        endIf
        }#

        return CmdLiteralString( t, t->String )

        #{
      elseIf (consume(Token.keyword_null))
        return CmdLiteralNull(t)
        }#

      elseIf (consume(TokenType.literal_real))
        return CmdLiteralReal( t, t->Real )

      elseIf (consume(TokenType.literal_integer))
        local value = t->Integer
        return CmdLiteralInteger( t, value )

      elseIf (consume(TokenType.literal_character))
        local value = t->Character
        return CmdLiteralCharacter( t, value->Character )

      elseIf (consume(TokenType.keyword_true))
        return CmdLiteralLogical( t, true )

      elseIf (consume(TokenType.keyword_false))
        return CmdLiteralLogical( t, false )

      #{
      elseIf (consume(Token.keyword_this))
        return CmdThis( t, this_type )
      elseIf (consume(Token.keyword_function))
        return parse_function( t )
      elseIf (consume(Token.keyword_pi))
        return CmdLiteralReal( t, pi )

      elseIf (consume(Token.symbol_open_bracket))
        # [ literal, list ]
        if (parsing_properties?)
          local cmd = CmdNewObject( t, Program.get_type_reference(t,"PropertyList") ) : Cmd

          local first = true
          while (first or consume(Token.symbol_comma))
            first = false
            local value = parse_expression
            cmd = CmdAccess( value.t, cmd, "add", CmdArgs(value) )
            consume_eols
          endWhile
          must_consume( Token.symbol_close_bracket )

          return cmd

        else
          local list = CmdLiteralList(t)
          consume_eols
          if (not consume(Token.symbol_close_bracket))
            local first = true
            while (first or consume(Token.symbol_comma))
              first = false
              list.args.add( parse_expression )
              consume_eols
            endWhile
            must_consume( Token.symbol_close_bracket )
          endIf
          return list
        endIf

      elseIf (consume(Token.symbol_open_brace))
        # { key:value, key:value, ... }
        local table = CmdLiteralTable(t)
        consume_eols
        if (not consume(Token.symbol_close_brace))
          local first = true
          while (first or consume(Token.symbol_comma))
            first = false
            if (peek.type == Token.identifier)
              local kt = read
              table.keys.add( CmdLiteralTableKey(kt, kt->String) )
            else
              ++parsing_properties
              table.keys.add( parse_expression )
              --parsing_properties
            endIf
            must_consume( Token.symbol_colon )
#local expr = parse_expression
#trace expr
#table.values.add( expr )
            ++parsing_properties
            table.values.add( parse_expression )
            --parsing_properties
            consume_eols
          endWhile
          must_consume( Token.symbol_close_brace )
        endIf
        return table

      elseIf (consume(Token.symbol_empty_braces))
        return CmdNewObject( t, Program.get_type_reference( t, "PropertyTable" ) )

      elseIf (consume(Token.symbol_empty_brackets))
        return CmdNewObject( t, Program.get_type_reference( t, "PropertyList" ) )

      elseIf (consume(Token.keyword_prior))
        consume_eols
        must_consume( Token.symbol_dot )
        consume_eols
        local name = read_identifier
        local args = parse_args
        return CmdPriorCall( t, name, args )

      elseIf (next_is(Token.keyword_delegate))
        return parse_delegate

      elseIf (consume(Token.alias_arg_index))
        return alias_args[ t->Integer ].clone
        }#

      else
        #throw peek.error( "Syntax error: unexpected '$'." (peek) )
        throw peek.error( "Syntax error: unexpected '" + peek + "'." )
      endIf

      #{
    method parse_function( t:Token )->Cmd
      local fn_cmd = CmdFunction( t )

      if (consume(Token.symbol_open_paren))
        # parameter names
        consume_eols
        if (next_is(Token.identifier))
          fn_cmd.parameter_names.add( read_identifier )
          while (consume(Token.symbol_comma))
            consume_eols
            fn_cmd.parameter_names.add( read_identifier )
          endWhile
        endIf
        consume_eols
        must_consume( Token.symbol_close_paren )
      endIf

      if (consume_eols)
        # multi-line
        parse_multi_line_statements( fn_cmd.body )
        must_consume( Token.keyword_endFunction )

      else
        # implicit-result-expression
        must_consume( Token.symbol_fat_arrow )

        consume( Token.keyword_return )
        local expr = parse_expression
        fn_cmd.body.add( CmdReturnValue(expr.t,expr) )
      endIf

      return fn_cmd
      }#
endClass

