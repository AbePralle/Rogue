$[include "Attributes.bard"]
$[include "CPPWriter.bard"]
$[include "Scope.bard"]
$[include "TypeTemplate.bard"]

class Program [requisite singleton]
  PROPERTIES
    code_prefix  = "Rogue"
    program_name = "rogue_program"

    template_list   = TypeTemplate[]                 : TypeTemplate[]
    template_lookup = Table<<String,TypeTemplate>>() : Table<<String,TypeTemplate>>

    explicit_main_class_t    : Token
    explicit_main_class_name : String
    implicit_main_class_t    : Token
    implicit_main_class_name : String
    main_class               : Type

    type_list       = Type[]                 : Type[]
    type_lookup     = Table<<String,Type>>() : Table<<String,Type>>

    type_Real       : Type
    type_Float      : Type
    type_Long       : Type
    type_Integer    : Type
    type_Character  : Type
    type_Byte       : Type
    type_Logical    : Type

    type_Object     : Type
    type_String     : Type

    literal_string_lookup = Table<<String,Integer>>() : Table<<String,Integer>>
    literal_string_list   = String[]

  METHODS
    method configure
      type_Real      = create_built_in_type( "Real" )
      type_Float     = create_built_in_type( "Float" )
      type_Long      = create_built_in_type( "Long" )
      type_Integer   = create_built_in_type( "Integer" )
      type_Character = create_built_in_type( "Character" )
      type_Byte      = create_built_in_type( "Byte" )
      type_Logical   = create_built_in_type( "Logical" )

      type_Object    = create_built_in_type( "Logical" )
      type_String    = create_built_in_type( "String" )

    method find_type( name:String )->Type
      local type = type_lookup[ name ]
      if (type?) return type

      local template = template_lookup[ name ]
      if (template?)
        type = Type( template.t, name )
        type_lookup[name] = type
        return type
      endIf

      return null

    method get_type_reference( t:Token, name:String )->Type
      local type = type_lookup[ name ]
      if (type?) return type

      type = Type( t, name )
      type_lookup[name] = type

      return type

    method create_built_in_type( name:String )->Type
      local t = TokenType("Internal").create_token( "[Built-in Type]", 0, 0 )
      local type = get_type_reference( t, name )
      type.attributes |= Attributes.flag_native
      return type

    method resolve
      if (explicit_main_class_t?)
        main_class = get_type_reference( explicit_main_class_t, explicit_main_class_name )
      elseIf (implicit_main_class_t?)
        main_class = get_type_reference( implicit_main_class_t, implicit_main_class_name )
      else
        throw RogueError( "No candidates for main class." )
      endIf

      main_class.resolve
      local m = main_class.find_method( "init()" )
      if (m?) m.resolve

    method validate_cpp_name( name:String )->String
      return name

    method write_cpp( filepath:String )
      forEach (type in type_list) type.assign_cpp_name

      forEach (type in type_list)
        forEach (m in type.method_list)
          m.assign_cpp_name
        endForEach
      endForEach


      # .H header -------------------------------------------------------------
      local writer = CPPWriter( filepath + ".h" )
      writer.println

      writer.println //#pragma  once//
      writer.println //#include "Rogue.h"//
      writer.println

      # XType forward declarations
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct " ).print( type.cpp_name ).println( "Type;" );
        endIf
      endForEach
      writer.println

      # RogueProgram object
      writer.println( "struct RogueProgram : RogueProgramCore" )
      writer.println( "{" )
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "  " ).print( type.cpp_name ).print( "Type* type_" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println
      writer.println( "  void init();" )
      writer.println( "  ~RogueProgram();" )
      writer.println( "};" )
      writer.println

      writer.println( "extern RogueProgram rogue_program;" );

      writer.close

      # .CPP implementation ---------------------------------------------------
      writer = CPPWriter( filepath + ".cpp" )
      writer.println

      local base_filename = filepath
      if (base_filename.contains('/')) base_filename = base_filename.after_last('/')
      writer.println //#include <stdio.h>//
      writer.println //#include "$.h"// (base_filename)
      writer.println

      # XObject forward declarations
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct " ).print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      # XObject definitions
      forEach (type in type_list)
        if (not type.is_native)
          type.print_definition( writer )
          writer.println
        endIf
      endForEach
      writer.println

      # XType definitions
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct " ).print( type.cpp_name ).println( "Type : RogueType" )
          writer.println( "{" )

          # create_object()
          writer.print(   "  " ).print( type.cpp_name ).println( "* create_object()" )
          writer.println( "  {" )
          writer.print(   "    return (" ).print( type.cpp_name ).print( "*) rogue_program.allocate_object( this, sizeof(" )
          writer.print( type.cpp_name ).println( ") );" )
          writer.println( "  }" )
          writer.println

          # name()
          writer.print( "  const char* name() { return \"" ).print( type.name ).println( "\"; }" )
          writer.println

          # trace()
          #writer.print(   "  " ).print( type.cpp_name ).println( "Object* create_object()" )
          #writer.println( "  {" )
          #writer.print(   "    return (" ).print( type.cpp_name ).print( "Object*) rogue.allocate_object( this, sizeof(" )
          #writer.print( type.cpp_name ).println( "Object) );" )
          #writer.println( "  }" )

          writer.println( "};" )
          writer.println
        endIf
      endForEach
      writer.println

      # "extern XType type_X;" declarations
      #{
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "extern Rogue" ).print( type.cpp_name ).print( "Type type_" ).print( type.cpp_name ).println(";")
          writer.println
        endIf
      endForEach
      writer.println
      }#

      # "XType type_X;" declarations
      #{
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( type.cpp_name ).print( "Type type_" ).print( type.cpp_name ).println(";")
          writer.println
        endIf
      endForEach
      writer.println
      }#

      forEach (type in type_list) type.print_method_prototypes( writer )
      writer.println

      forEach (type in type_list) type.print_method_definitions( writer )
      writer.println

      # configure() method
      writer.println( "void RogueProgram::init()" )
      writer.println( "{" )
      forEach (type in type_list)
        if (not type.is_native)
          writer.print("  type_").print(type.cpp_name).print(" = new ").print(type.cpp_name).println("Type();")
        endIf
      endForEach
      writer.println
      writer.print(   "  literal_string_count = " ).print( Program.literal_string_list.count ).println( ";" )
      writer.println( "  literal_strings = new RogueString*[literal_string_count];" )
      forEach (i of Program.literal_string_list)
        writer.print(   "  literal_strings[" ).print(i).print("] = (RogueString*) RogueString::create( ")
        writer.print_string_utf8( Program.literal_string_list[i] )
        writer.println( " )->retain(); " )
      endForEach
      writer.println
      writer.print(   "  rogue_program.main_object = rogue_program.type_").print(main_class.cpp_name).println( "->create_object();" )

      # call init() on main object
      local m = main_class.find_method( "init()" )
      if (m?)
        writer.print("  ").print(m.cpp_name).print("( (").print(main_class.cpp_name).println("*)rogue_program.main_object );")
      endIf

      writer.println( "}" )
      writer.println

      # Rogue destructor
      writer.println( "RogueProgram::~RogueProgram()" )
      writer.println  "{"
      forEach (type in type_list)
        if (not type.is_native)
          writer.print("  delete type_").print(type.cpp_name).println(";")
        endIf
      endForEach
      writer.println  "}"
      writer.println
      writer.println "RogueProgram rogue_program;"


      writer.close
endClass

