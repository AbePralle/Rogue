$[include "Attributes.bard"]
$[include "CPPWriter.bard"]
$[include "TypeTemplate.bard"]

class Program [requisite singleton]
  PROPERTIES
    code_prefix = "Rogue"

    template_list   = TypeTemplate[]                 : TypeTemplate[]
    template_lookup = Table<<String,TypeTemplate>>() : Table<<String,TypeTemplate>>

    explicit_main_class_t    : Token
    explicit_main_class_name : String
    implicit_main_class_t    : Token
    implicit_main_class_name : String
    main_class               : Type

    type_list       = Type[]                 : Type[]
    type_lookup     = Table<<String,Type>>() : Table<<String,Type>>

    type_Real       : Type
    type_Float      : Type
    type_Long       : Type
    type_Integer    : Type
    type_Character  : Type
    type_Byte       : Type
    type_Logical    : Type

    type_Object     : Type
    type_String     : Type

  METHODS
    method configure
      type_Real      = create_built_in_type( "Real" )
      type_Float     = create_built_in_type( "Float" )
      type_Long      = create_built_in_type( "Long" )
      type_Integer   = create_built_in_type( "Integer" )
      type_Character = create_built_in_type( "Character" )
      type_Byte      = create_built_in_type( "Byte" )
      type_Logical   = create_built_in_type( "Logical" )

      type_Object    = create_built_in_type( "Logical" )
      type_String    = create_built_in_type( "String" )

    method get_type_reference( t:Token, name:String )->Type
      local type = type_lookup[ name ]
      if (type?) return type

      type = Type( t, name )
      type_lookup[name] = type

      return type

    method create_built_in_type( name:String )->Type
      local t = TokenType("Internal").create_token( "[Built-in Type]", 0, 0 )
      local type = get_type_reference( t, name )
      type.attributes |= Attributes.flag_native
      return type

    method resolve
      if (explicit_main_class_t?)
        main_class = get_type_reference( explicit_main_class_t, explicit_main_class_name )
      elseIf (implicit_main_class_t?)
        main_class = get_type_reference( implicit_main_class_t, implicit_main_class_name )
      else
        throw RogueError( "No candidates for main class." )
      endIf

      main_class.resolve
      local m = main_class.find_method( "init()" )
      if (m?) m.resolve

    method validate_cpp_name( name:String )->String
      return name

    method write_cpp( filepath:String )
      forEach (type in type_list) type.assign_cpp_name

      forEach (type in type_list)
        forEach (m in type.method_list)
          m.assign_cpp_name
        endForEach
      endForEach


      # .H header
      local writer = CPPWriter( filepath + ".h" )
      writer.println

      writer.println //#pragma  once//
      writer.println //#include "Rogue.h"//
      writer.println

      # XType forward declarations
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct Rogue" ).print( type.cpp_name ).println( "Type;" );
        endIf
      endForEach
      writer.println

      # Rogue object
      writer.println( "struct Rogue : RogueCore" )
      writer.println( "{" )
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "  Rogue" ).print( type.cpp_name ).print( "Type* type_" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println
      writer.println( "  void init();" )
      writer.println( "};" )
      writer.println

      #writer.print( "#define ROGUE_TYPE_COUNT " ).println( type_list.count )
      #writer.println( "extern RogueType  Rogue_types[ROGUE_TYPE_COUNT];" )
      #writer.println

      #forEach (type in type_list) type.print_method_prototypes( writer )
      #writer.println
      writer.println( "extern Rogue rogue;" );

      writer.close

      # .CPP implementation
      writer = CPPWriter( filepath + ".cpp" )
      writer.println

      local base_filename = filepath
      if (base_filename.contains('/')) base_filename = base_filename.after_last('/')
      writer.println //#include <stdio.h>//
      writer.println //#include "$.h"// (base_filename)
      writer.println //#include "RogueAllocator.h"//
      writer.println

      # XObject forward declarations
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct Rogue" ).print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      # XObject definitions
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct Rogue" ).print( type.cpp_name ).println( " : RogueObject" );
          writer.println( "{" )
          writer.println( "};" )
          writer.println
        endIf
      endForEach
      writer.println
      writer.println "extern Rogue rogue;"

      # XType definitions
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "struct Rogue" ).print( type.cpp_name ).println( "Type : RogueType" )
          writer.println( "{" )

          # create_object()
          writer.print(   "  Rogue" ).print( type.cpp_name ).println( "* create_object()" )
          writer.println( "  {" )
          writer.print(   "    return (Rogue" ).print( type.cpp_name ).print( "*) rogue.allocate_object( this, sizeof(Rogue" )
          writer.print( type.cpp_name ).println( ") );" )
          writer.println( "  }" )
          writer.println

          # name()
          writer.print( "  const char* name() { return \"" ).print( type.name ).println( "\"; }" )
          writer.println

          # trace()
          #writer.print(   "  " ).print( type.cpp_name ).println( "Object* create_object()" )
          #writer.println( "  {" )
          #writer.print(   "    return (" ).print( type.cpp_name ).print( "Object*) rogue.allocate_object( this, sizeof(" )
          #writer.print( type.cpp_name ).println( "Object) );" )
          #writer.println( "  }" )

          writer.println( "};" )
          writer.println
        endIf
      endForEach
      writer.println

      # "extern XType type_X;" declarations
      #{
      forEach (type in type_list)
        if (not type.is_native)
          writer.print( "extern Rogue" ).print( type.cpp_name ).print( "Type type_" ).print( type.cpp_name ).println(";")
          writer.println
        endIf
      endForEach
      writer.println
      }#

      # "XType type_X;" declarations
      #{
      forEach (type in type_list)
        if (not type.is_native)
          writer.print("Rogue").print( type.cpp_name ).print( "Type type_" ).print( type.cpp_name ).println(";")
          writer.println
        endIf
      endForEach
      writer.println
      }#

      # configure() method
      writer.println( "void Rogue::init()" )
      writer.println( "{" )
      forEach (type in type_list)
        if (not type.is_native)
          writer.print("  type_").print(type.cpp_name).print(" = new Rogue").print(type.cpp_name).print("Type();")
        endIf
      endForEach
      writer.println
      writer.print(   "  rogue.main_object = rogue.type_").print(main_class.cpp_name).println( "->create_object();" )
      writer.println( "}" )
      writer.println
      writer.println "Rogue rogue;"


      writer.close
endClass

