$[include "Attributes.bard"]
$[include "CPPWriter.bard"]
$[include "TypeTemplate.bard"]

class Program [requisite singleton]
  PROPERTIES
    code_prefix = "Rogue"

    template_list   = TypeTemplate[]                 : TypeTemplate[]
    template_lookup = Table<<String,TypeTemplate>>() : Table<<String,TypeTemplate>>

    explicit_main_class_t    : Token
    explicit_main_class_name : String
    implicit_main_class_t    : Token
    implicit_main_class_name : String
    main_class               : Type

    type_list       = Type[]                 : Type[]
    type_lookup     = Table<<String,Type>>() : Table<<String,Type>>

    type_Real       : Type
    type_Float      : Type
    type_Long       : Type
    type_Integer    : Type
    type_Character  : Type
    type_Byte       : Type
    type_Logical    : Type

    type_Object     : Type
    type_String     : Type

  METHODS
    method configure
      type_Real      = create_built_in_type( "Real" )
      type_Float     = create_built_in_type( "Float" )
      type_Long      = create_built_in_type( "Long" )
      type_Integer   = create_built_in_type( "Integer" )
      type_Character = create_built_in_type( "Character" )
      type_Byte      = create_built_in_type( "Byte" )
      type_Logical   = create_built_in_type( "Logical" )

      type_Object    = create_built_in_type( "Logical" )
      type_String    = create_built_in_type( "String" )

    method get_type_reference( t:Token, name:String )->Type
      local type = type_lookup[ name ]
      if (type?) return type

      type = Type( t, name )
      type_list.add( type )
      type_lookup[name] = type

      return type

    method create_built_in_type( name:String )->Type
      local t = TokenType("Internal").create_token( "[Built-in Type]", 0, 0 )
      local type = get_type_reference( t, name )
      type.attributes |= Attributes.flag_native
      return type

    method resolve
      if (explicit_main_class_t?)
        main_class = get_type_reference( explicit_main_class_t, explicit_main_class_name )
      elseIf (implicit_main_class_t?)
        main_class = get_type_reference( implicit_main_class_t, implicit_main_class_name )
      else
        throw RogueError( "No candidates for main class." )
      endIf

      main_class.resolve
      local m = main_class.find_method( "init()" )
      if (m?) m.resolve

    method validate_cpp_name( name:String )->String
      return name

    method write_cpp( filepath:String )
      forEach (type in type_list) type.assign_cpp_name

      forEach (type in type_list)
        forEach (m in type.method_list)
          m.assign_cpp_name
        endForEach
      endForEach


      # .H header
      local writer = CPPWriter( filepath + ".h" )
      writer.println

      writer.println //#include "RogueTypes.h"//
      writer.println

      forEach (type in type_list) type.print_type_declaration( writer )
      writer.println

      forEach (type in type_list) type.print_method_prototypes( writer )
      writer.println

      writer.close


      # .CPP implementation
      writer = CPPWriter( filepath + ".cpp" )
      writer.println

      local base_filename = filepath
      if (base_filename.contains('/')) base_filename = base_filename.after_last('/')
      writer.println //#include <stdio.h>//
      writer.println //#include "$.h"// (base_filename)
      writer.println //#include "RogueMM.h"//
      writer.println

      forEach (type in type_list) type.print_type_definition( writer )
      writer.println

      forEach (type in type_list) type.print_method_definitions( writer )
      writer.println

      writer.close
endClass

