$[include "Attributes.bard"]
$[include "CPPWriter.bard"]
$[include "Scope.bard"]
$[include "Template.bard"]

class Program [requisite singleton]
  PROPERTIES
    code_prefix  = "Rogue"
    program_name = "rogue_program"

    next_unique_id : Integer

    template_list   = Template[]                 : Template[]
    template_lookup = Table<<String,Template>>() : Table<<String,Template>>

    explicit_main_class_t    : Token
    explicit_main_class_name : String
    implicit_main_class_t    : Token
    implicit_main_class_name : String
    main_class               : Type

    type_list       = Type[]                 : Type[]
    type_lookup     = Table<<String,Type>>() : Table<<String,Type>>

    type_Real       : Type
    type_Float       : Type
    type_Long        : Type
    type_Integer     : Type
    type_Character   : Type
    type_Byte        : Type
    type_Logical     : Type

    type_Object      : Type
    type_String      : Type
    type_NativeArray : Type

    literal_string_lookup = Table<<String,Integer>>() : Table<<String,Integer>>
    literal_string_list   = String[]

    string_buffer = StringBuilder()

  METHODS
    method configure
      type_Real        = create_built_in_type( "Real",      Attribute.is_native | Attribute.is_primitive )
      type_Float       = create_built_in_type( "Float",     Attribute.is_native | Attribute.is_primitive )
      type_Long        = create_built_in_type( "Long",      Attribute.is_native | Attribute.is_primitive )
      type_Integer     = create_built_in_type( "Integer",   Attribute.is_native | Attribute.is_primitive )
      type_Character   = create_built_in_type( "Character", Attribute.is_native | Attribute.is_primitive )
      type_Byte        = create_built_in_type( "Byte",      Attribute.is_native | Attribute.is_primitive )
      type_Logical     = create_built_in_type( "Logical",   Attribute.is_native | Attribute.is_primitive )

      type_Object      = create_built_in_type( "Object", Attribute.is_native | Attribute.is_class )
      type_String      = create_built_in_type( "String", Attribute.is_native | Attribute.is_class | Attribute.is_functional )
      type_NativeArray = create_built_in_type( "NativeArray", Attribute.is_native | Attribute.is_class )

    method create_unique_id->String
      ++next_unique_id
      return "_auto_" + (next_unique_id-1)

    method find_type( name:String )->Type
      local type = type_lookup[ name ]
      if (type?) return type

      local template = template_lookup[ name.before_first('<') ]
      if (template?)
        type = Type( template.t, name )
        type_lookup[name] = type
        return type
      endIf

      return null

    method get_type_reference( t:Token, name:String )->Type
      local type = type_lookup[ name ]
      if (type?) return type

      type = Type( t, name )
      type_lookup[name] = type

      return type

    method create_built_in_type( name:String, attributes=0:Integer )->Type
      local t = TokenType("Internal").create_token( "[Built-in Type]", 0, 0 )
      local type = get_type_reference( t, name )
      type.attributes.add( attributes )
      return type

    method resolve
      if (explicit_main_class_t?)
        main_class = get_type_reference( explicit_main_class_t, explicit_main_class_name )
      elseIf (implicit_main_class_t?)
        main_class = get_type_reference( implicit_main_class_t, implicit_main_class_name )
      else
        throw RogueError( "No candidates for main class." )
      endIf

      main_class.resolve
      local m = main_class.find_method( "init()" )
      if (m?) m.resolve

      type_NativeArray.resolve

    method validate_cpp_name( name:String )->String
      local i1 = name.locate("<<")
      while (i1 != -1)
        local i2 = name.locate_last(">>")
        if (i2 == -1) escapeWhile

        local before = name.substring(0,i1-1)
        local after  = name.substring(i2+2)
        local middle = name.substring(i1+2,i2-1)

        #name = "$_of_$$" (before,middle,after)

        name = "$$$" (validate_cpp_name(middle),before,after)
        # Example:
        #   Table<<String,Integer>>[] -> StringIntegerTable[]

        i1 = name.locate("<<")
      endWhile

      #   StringIntegerTable[] -> StringIntegerTableList
      i1 = name.locate("[]")
      while (i1 != -1)
        name = name.substring(0,i1-1) + "List" + name.substring(0,i1+2)
        i1 = name.locate("[]")
      endWhile

      string_buffer.clear
      forEach (ch in name)
        if (ch.is_alphanumeric) string_buffer.print( ch )
        else                    string_buffer.print( '_' )
      endForEach

      return string_buffer->String

    method write_cpp( filepath:String )
      forEach (type in type_list) type.assign_cpp_name

      forEach (type in type_list)
        forEach (m in type.method_list)
          m.assign_cpp_name
        endForEach
      endForEach


      # .H header -------------------------------------------------------------
      local writer = CPPWriter( filepath + ".h" )
      writer.println

      writer.println //#pragma  once//
      writer.println //#include "Rogue.h"//
      writer.println //#include <cmath>//
      writer.println

      # XType forward declarations
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print( "struct " ).print( type.cpp_name ).println( "Type;" );
        endIf
      endForEach
      writer.println

      # RogueProgram object
      writer.println( "struct RogueProgram : RogueProgramCore" )
      writer.println( "{" )
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print( "  " ).print( type.cpp_name ).print( "Type* type_" );
          writer.print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println
      writer.println( "  void init();" )
      writer.println( "  ~RogueProgram();" )
      writer.println( "};" )
      writer.println

      writer.println( "extern RogueProgram rogue_program;" );

      writer.close

      # .CPP implementation ---------------------------------------------------
      writer = CPPWriter( filepath + ".cpp" )
      writer.println

      local base_filename = filepath
      if (base_filename.contains('/')) base_filename = base_filename.after_last('/')
      writer.println //#include <stdio.h>//
      writer.println //#include "$.h"// (base_filename)
      writer.println

      # XObject forward declarations
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print( "struct " ).print( type.cpp_name ).println( ";" );
        endIf
      endForEach
      writer.println

      # XObject definitions
      forEach (type in type_list)
        if (not type.omit_output)
          type.print_data_definition( writer )
          writer.println
        endIf
      endForEach
      writer.println

      # create_object() forward declarations
      forEach (type in type_list)
        if (not type.omit_output)
          local m = type.find_method( "init_object()" )
          if (m?)
            writer.print( type ).print( " " ).print( m.cpp_name ).print( "( " );
            writer.print( type )
            writer.println( " THIS );" )
          endIf
        endIf
      endForEach
      writer.println

      # XType definitions
      forEach (type in type_list)
        type.print_type_definition( writer )
      endForEach
      writer.println

      # "extern XType type_X;" declarations
      #{
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print( "extern Rogue" ).print( type.cpp_name ).print( "Type type_" ).print( type.cpp_name ).println(";")
          writer.println
        endIf
      endForEach
      writer.println
      }#

      # "XType type_X;" declarations
      #{
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print( type.cpp_name ).print( "Type type_" ).print( type.cpp_name ).println(";")
          writer.println
        endIf
      endForEach
      writer.println
      }#

      forEach (type in type_list) type.print_method_prototypes( writer )
      writer.println

      forEach (type in type_list) type.print_method_definitions( writer )
      writer.println

      # configure() method
      writer.println( "void RogueProgram::init()" )
      writer.println( "{" )

      # Create types
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print("  type_").print(type.cpp_name).print(" = new ").print(type.cpp_name).println("Type();")
        endIf
      endForEach
      writer.println

      # Configure types
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print("  type_").print(type.cpp_name).println("->configure();" )
        endIf
      endForEach
      writer.println

      writer.print(   "  literal_string_count = " ).print( Program.literal_string_list.count ).println( ";" )
      writer.println( "  literal_strings = new RogueString*[literal_string_count];" )
      forEach (i of Program.literal_string_list)
        writer.print(   "  literal_strings[" ).print(i).print("] = (RogueString*) RogueString::create( ")
        writer.print_string_utf8( Program.literal_string_list[i] )
        writer.println( " )->retain(); " )
      endForEach
      writer.println
      writer.print(   "  rogue_program.main_object = rogue_program.type_").print(main_class.cpp_name).println( "->create_object();" )

      # call init() on main object
      local m = main_class.find_method( "init()" )
      if (m?)
        writer.print("  ").print(m.cpp_name).print("( (").print(main_class.cpp_name).println("*)rogue_program.main_object );")
      endIf

      writer.println( "}" )
      writer.println

      # Rogue destructor
      writer.println( "RogueProgram::~RogueProgram()" )
      writer.println  "{"
      forEach (type in type_list)
        if (not type.omit_output)
          writer.print("  delete type_").print(type.cpp_name).println(";")
        endIf
      endForEach
      writer.println  "}"
      writer.println
      writer.println "RogueProgram rogue_program;"


      writer.close
endClass

