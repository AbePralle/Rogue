$[include "InlineArgs.bard"]

class Scope
  PROPERTIES
    this_type   : Type
    this_method : Method

    local_list = Local[]
    locals_by_name = Table<<String,Local>>() : Table<<String,Local>>

  METHODS
    method init( this_type, this_method )

    method find_local( name:String )->Local
      return locals_by_name[ name ]

    method push_local( v:Local )
      local existing = find_local( v.name )
      if (existing?) throw v.t.error( //A local variable named "$" already exists.// (v.name) ) 
      local_list.add( v )
      locals_by_name[v.name] = v

    method pop_local
      if (locals_by_name.count == 0) throw RogueError( "[INTERNAL] Scope::pop_local() called when local list is empty." )
      locals_by_name.remove( local_list.remove_last.name )

    method resolve_call( type_context:Type, access:CmdAccess, error_on_fail:Logical )->Cmd
      local m = find_method( type_context, access, error_on_fail )
      if (not m) return null

      local t = access.t

      local context = access.context
      if (not context) context = CmdReadThis( t, type_context )

      local args = access.args
      if (not args) args = CmdArgs()

      local cmd : Cmd
      if (m.is_native)
        if (type_context.is_array)
          which (m.name)
            case "count"
              if (args? and args.count?) throw t.error( "Invalid arguments to array count." )
              return CmdReadArrayCount( t, context ).resolve( this )
            others
              throw t.error( "[INTERNAL] No compiler support for native Array call $." (m.signature) )
          endWhich
        endIf

        if (m.native_code?)
          cmd = CmdInlineNativeCall( t, context, m, args )
        else
          throw t.error( "[INTERNAL] TODO: support native methods." )
        endIf

      elseIf (m.is_inline)
        local inline_args = InlineArgs( m, context, args )
        local inline_statements = CmdStatementList()
        forEach (statement in m.statements)
          local inline_statement = statement.clone( inline_args )
          if (inline_statement?) inline_statements.add( inline_statement )
        endForEach

        inline_statements.resolve( this )
        if (inline_statements.count == 1) return inline_statements.first

        trace
        throw t.error( "TODO: multi-line inline statements" )
        
      else
        cmd = CmdStaticCall( t, context, m, args )
      endIf
      return cmd.set_modifiers(access).resolve( this )

    method find_method( type_context:Type, access:CmdAccess, error_on_fail:Logical )->Method
      local candidates = CandidateMethods( access, error_on_fail )

      local list = type_context.method_lookup_by_name[ access.name ]
      if (list?)
        forEach (m in list)
          candidates.available.add( m )
        endForEach
      endIf
      if (not candidates.update_available) return null

      local arg_count = 0
      if (access.args?) arg_count = access.args.count
      forEach (m in candidates.available)
        if (m.accepts_arg_count(arg_count)) candidates.compatible.add( m )
      endForEach
      if (not candidates.update_matches) return null

      if (candidates.has_match) return candidates.match

      candidates.update_matches
      return null
endClass

class CandidateMethods
  PROPERTIES
    access              : CmdAccess
    available=Method[]  : Method[]
    compatible=Method[] : Method[]
    error_on_fail       : Logical

  METHODS
    method init( access, error_on_fail )

    method has_match->Logical
      return (available.count == 1)

    method match->Method
      if (available.count != 1) return null
      return available[0]

    method update_available->Logical
      return update( false )

    method update_matches->Logical
      return update( true )

    method update( require_compatible:Logical )->Logical
      if (compatible.count == 0)

        if (available.count == 0)
          if (not error_on_fail) return false
          throw access.t.error( //No such method or variable "$" exists in the current scope.// (access.name) )

        elseIf (require_compatible)
          if (not error_on_fail) return false

          local buffer = StringBuilder()
          if (available.count > 1)
            buffer.print( //Multiple methods match ambiguous call to "$":\n// (access.name) )
          else
            buffer.print( //Call to "$" uses arguments that are incompatible with the existing definition:\n// (access.name) )
          endIf
          forEach (m in available)
            buffer.print("  ").println(m.signature)
          endForEach
          throw access.t.error( buffer->String )

        endIf

        # We didn't find any compatible methods; just keep our available methods
        # for the next refinement.
        return true
      endIf

      available.clear
      available.add( compatible )
      compatible.clear

      return true
endClass
