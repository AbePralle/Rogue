class Template
  PROPERTIES
    t                  : Token
    name               : String
    tokens=Token[]     : Token[]
    attributes         : Integer
    type_parameters    : TypeParameter[]
    type_specializers  : Table<<String,TypeSpecializer>>

  METHODS
    method init( t, name, attributes=0 )

    method add_type_parameter( p_t:Token, p_name:String )->TypeParameter
      if (type_parameters is null) type_parameters = TypeParameter[]
      local param = TypeParameter( p_t, p_name )
      type_parameters.add( param )
      return param

    method instantiate( type:Type )
      type.t = t
      # replace location of first reference to type with location of type definition

      type.attributes |= attributes

      local instance_tokens = tokens

      if (type_parameters?)
        type_specializers = Table<<String,TypeSpecializer>>()

        local parser = Parser( t, type.name, type.name.from_first('<') )
        parser.read  # '<<'

        local buffer = StringBuilder()
        local first = true
        while (first or parser.consume(TokenType.symbol_comma))
          first = false
          local specializer_tokens = Token[]
          buffer.clear
          parser.parse_specializer( buffer.clear, specializer_tokens )

          local index = type_specializers.count
          if (index >= type_parameters.count) throw t.error( "Too many type specializers given." )

          local param = type_parameters[index]
          local specializer = TypeSpecializer( param.name, index )
          type_specializers[specializer.name] = specializer

          local is_generic = false
          if (param.generic_mapping?)
            param.generic_mapping.resolve
            local specializer_type = Program.find_type( buffer->String )
            if (specializer_type?)
              specializer.type = specializer_type
              specializer_type.resolve
              if (specializer_type.instance_of(param.generic_mapping))
                is_generic = true
              endIf
            endIf
          endIf

          if (is_generic)
            specializer.generic_mapping = param.generic_mapping
          else
            specializer.tokens = specializer_tokens
          endIf

        endWhile

        # Create specialized instance tokens
        instance_tokens = Token[]( tokens.count * 2 )
        forEach (template_t in tokens)
          if (template_t.type is TokenType.placeholder_id)
            local specializer = type_specializers[ template_t->String ]
            if (specializer?)
              if (specializer.tokens?)
                # Insert template copy of tokens
                forEach (specializer_t in specializer.tokens)
                  instance_tokens.add( specializer_t )
                endForEach
              else
                # Insert type identifier for generic mapping
                local from_type = specializer.type
                local to_type = specializer.generic_mapping
                instance_tokens.add( TokenType.type_identifier.create_token(template_t,from_type,to_type) )
              endIf
            else
              instance_tokens.add( template_t )
            endIf
          else
            instance_tokens.add( template_t )
          endIf
        endForEach

      elseIf (type.name.contains('<'))
        throw t.error( "Type parameters given for non-template type." )
      endIf

      Parser(instance_tokens).parse_type_def( type )

endClass


class TypeParameter
  PROPERTIES
    t               : Token
    name            : String
    generic_mapping : Type    # optional
 
  METHODS
    method init( t, name )
endClass


class TypeSpecializer
  PROPERTIES
    name            : String
    index           : Integer

    tokens          : Token[]  # for templates

    # For Generics
    type            : Type
    generic_mapping : Type

  METHODS
    method init( name, index )
endClass

