class Test
  METHODS
    method init
      local words = String[]
      local reader = LineReader( File.read("dictionary.txt") )
      forEach (word in reader)
        if (word.count > 1) words.add( word )
      endForEach
      println "Word count: " + words.count
endClass



#{
class Pair<<$FirstType:Object,$SecondType:Object>> #( first:$FirstType, second:$SecondType )
  PROPERTIES
    first:$FirstType
    second:$SecondType

  METHODS
    method init( first, second )
    method to->String
      return "(" + first + "," + second + ")"
endClass
}#

class Number<<$DataType:Object>>
  PROPERTIES
    value : $DataType

  METHODS
    method init
      local list = $DataType[]
endClass

#{

compound XY( x:Real, y:Real )
endCompound
}#

class Console [singleton]
  METHODS
    method print( value:String )
      native_print( value )

    method print( value:StringBuilder )
      native_print( value )

    method native_print( value:String )
      $if ("C++") nativeInline 'RogueString::print( $value )'

    method native_print( value:StringBuilder )
      $if ("C++") nativeInline 'RogueString::print( $value->characters->data->characters, $value->characters->count )'
endClass

class File
  ROUTINES
    routine exists( filepath:String )->String [native]

    routine load( filepath:String )->String [native]

    routine read( filepath:String )->FileReader
      return FileReader( filepath )

    routine save( filepath:String, data:String )->Logical [native]

    routine write( filepath:String )->FileWriter
      return FileWriter( filepath )
endClass

aspect Reader<<$DataType>>
  METHODS
    method has_another->Logical

    method peek->$DataType

    method read->$DataType

    method marco->String
      return "polo"
endAspect


class LineReader : Reader<<String>>
  PROPERTIES
    source : Reader<<Character>>
    next   : String
    buffer = StringBuilder()

  METHODS
    method init( source )
      next = prepare_next

    method has_another->Logical
      return next?

    method peek->String
      return next

    method prepare_next->String
      if (not source.has_another) return null

      buffer.clear
      while (source.has_another)
        local ch = source.read
        if (ch == '\n') return buffer->String
        buffer.print( ch )
      endWhile

      return buffer->String

    method read->String
      local result = next
      next = prepare_next
      return result
endClass


class FileReader : Reader<<Character>> [native]
  ROUTINES
    routine create( filepath:String )->this [native]
    
  METHODS
    method close->FileReader [native]

    method count->Integer [native]

    method has_another->Logical [native]

    method open( filepath:String )->Logical [native]

    method peek->Character [native]

    method position->Integer [native]

    method read->Character [native]

    method remaining->Integer
      return count - position

    method set_position( new_position:Integer )->this [native]
endClass

class FileWriter [native]
  ROUTINES
    routine create( filepath:String )->this [native]
    
  METHODS
    method close->FileWriter [native]

    method count->Integer [native]

    method flush->FileWriter [native]

    method open( filepath:String )->Logical [native]

    method write( ch:Character )->this [native]
endClass

class Global [singleton]
  PROPERTIES
    global_output_buffer = StringBuilder()
    standard_output      = Console

  METHODS
    method add_indent( spaces:Integer )->this
      global_output_buffer.add_indent( spaces )
      return this

    method flush->this
      if (global_output_buffer.count?)
        standard_output.print( global_output_buffer )
        global_output_buffer.clear
      endIf
      return this

    method print( value:Byte )->this
      global_output_buffer.print( value )
      return this

    method print( value:Character )->this
      global_output_buffer.print( value )
      if (value == '\n') return flush
      return this

    method print( value:Integer )->this
      global_output_buffer.print( value )
      return this

    method print( value:Logical )->this
      global_output_buffer.print( value )
      return this

    method print( value:Object )->this
      global_output_buffer.print( value )
      return this

    method print( value:Real )->this
      global_output_buffer.print( value )
      return this

    method print( value:String )->this
      global_output_buffer.print( value )
      return this

    method println->this
      global_output_buffer.print( '\n' )
      return flush

    method println( value:Byte )->this
      return print( value ).println

    method println( value:Character )->this
      return print( value ).println

    method println( value:Integer )->this
      return print( value ).println

    method println( value:Logical )->this
      return print( value ).println

    method println( value:Real )->this
      return print( value ).println

    method println( value:Object )->this
      return print( value ).println

    method println( value:String )->this
      return print( value ).println
endClass

class Math
  ROUTINES
    routine atan( slope:Real )->Real
      $if ("C++") nativeInline 'atan((double)$n)'

    routine atan2( y:Real, x:Real )->Real
      $if ("C++") nativeInline 'atan2((double)$y,(double)$x)'

    routine ceil( n:Real )->Real
      $if ("C++") nativeInline 'ceil((double)$n)'

    routine cos( n:Real )->Real
      $if ("C++") nativeInline 'cos((double)$n)'

    routine exp( n:Real )->Real
      $if ("C++") nativeInline 'exp((double)$n)'

    routine floor( n:Real )->Real
      $if ("C++") nativeInline 'floor((double)$n)'

    routine log( n:Real )->Real
      $if ("C++") nativeInline 'log((double)$n)'

    routine log2( n:Real )->Real
      $if ("C++") nativeInline 'log2((double)$n)'

    routine log10( n:Real )->Real
      $if ("C++") nativeInline 'log10((double)$n)'

    routine sin( n:Real )->Real
      $if ("C++") nativeInline 'sin((double)$n)'

    routine sqrt( n:Real )->Real
      $if ("C++") nativeInline 'sqrt((double)$n)'

    routine tan( n:Real )->Real
      $if ("C++") nativeInline 'tan((double)$n)'
endClass

primitive Real
  ROUTINES
    routine create( high:Integer, low:Integer )->Real [native]

  METHODS
    method high_bits->Integer [native]
    method low_bits->Integer  [native]
    #{
    method hash_code->Integer
      return this
      }#
endPrimitive

primitive Float
#{
  METHODS
    method hash_code->Integer
      return (this->Real).as_high_bits
}#
endPrimitive

primitive Long
#{
  METHODS
    method hash_code->Integer
      return this
}#
endPrimitive

primitive Integer
  METHODS
    method hash_code->Integer
      return this
endPrimitive

primitive Character
  METHODS
    method hash_code->Integer
      return this->Integer
endPrimitive

primitive Byte
  METHODS
    method hash_code->Integer
      return this->Integer
endPrimitive

primitive Logical
  METHODS
    method hash_code->Integer
      if (this) return 1
      else      return 0
endPrimitive

class Object
  METHODS
    method operator==( other:Object )->Logical
      return false  # FIXME: this is other

    method to->String
      return "(Object)"
endClass

class String [native functional]
  ROUTINES
    routine create( characters:Character[] )->String
      $if ("C++") nativeInline 'RogueString::create( $characters )'

    routine create( characters:StringBuilder )->String
      return create( characters.characters )

  METHODS
    method after_any( ch:Character )->String
      local i = locate( ch )
      if (i == -1) return this
      return substring( i+1 )

    method after_any( st:String )->String
      local i = locate( st )
      if (i == -1) return this
      return substring( i+st.count )

    method after_first( ch:Character )->String
      local i = locate( ch )
      if (i == -1) return ""
      return substring( i+1 )

    method after_first( st:String )->String
      local i = locate( st )
      if (i == -1) return ""
      return substring( i+st.count )

    method after_last( ch:Character )->String
      local i = locate_last( ch )
      if (i == -1) return ""
      return substring( i+1 )

    method after_last( st:String )->String
      local i = locate_last( st )
      if (i == -1) return ""
      return substring( i+st.count )

    method before_first( ch:Character )->String
      local i = locate( ch )
      if (i == -1) return this
      return substring( 0, i-1 )

    method before_first( st:String )->String
      local i = locate( st )
      if (i == -1) return this
      return substring( 0, i-1 )

    method before_last( ch:Character )->String
      local i = locate_last( ch )
      if (i == -1) return this
      return substring( 0, i-1 )

    method before_last( st:String )->String
      local i = locate_last( st )
      if (i == -1) return this
      return substring( 0, i-1 )

    method begins_with( ch:Character )->Logical
      return (count? and this[0] == ch)

    method begins_with( other:String )->Logical
      local other_count = other.count
      return (count >= other_count and contains(other,0))

    method contains( substring:String )->Logical
      return locate(substring) >= 0

    method contains( substring:String, at_index:Integer )->Logical
      $if ("C++") nativeInline '$this->contains($substring,$at_index)'

    method count->Integer
      $if ("C++") nativeInline '$this->count'

    method from_first( ch:Character )->String
      local i = locate( ch )
      if (i == -1) return ""
      return substring( i )

    method from_first( st:String )->String
      local i = locate( st )
      if (i == -1) return ""
      return substring( i )

    method from_last( ch:Character )->String
      local i = locate_last( ch )
      if (i == -1) return ""
      return substring( i )

    method from_last( st:String )->String
      local i = locate_last( st )
      if (i == -1) return ""
      return substring( i )

    method get( index:Integer )->Character
      $if ("C++") nativeInline '$this->characters[$index]'

    method hash_code->Integer
      $if ("C++") nativeInline '$this->hash_code'

    method last->Character
      return this[ count-1 ]

    method locate( ch:Character, i1=0:Integer )->Integer
      $if ("C++") nativeInline '$this->locate($ch,$i1)'

    method locate( other:String, i1=0:Integer )->Integer
      $if ("C++") nativeInline '$this->locate($other,$i1)'

    method locate_last( ch:Character )->Integer
      return locate_last( ch, count-1 )

    method locate_last( ch:Character, starting_index:Integer )->Integer
      $if ("C++") nativeInline '$this->locate_last($ch,$starting_index)'

    method locate_last( other:String )->Integer
      return locate_last( other, count-other.count )

    method locate_last( other:String, starting_index:Integer )->Integer
      $if ("C++") nativeInline '$this->locate_last($other,$starting_index)'

    method operator+( value:Character )->String
      $if ("C++") nativeInline '$this->plus($value)'

    method operator+( value:Integer )->String
      $if ("C++") nativeInline '$this->plus($value)'

      #{
    method operator+( value:Object )->String
      if (value?) return this + value->String
      else        return this + "null"
      }#

    method operator<>( other:String )->Integer
      $if ("C++") nativeInline '$this->compare_to($other)'

    method operator+( value:Logical )->String
      if (value) return this + "true"
      else       return this + "false"

    method operator+( value:Object )->String
      if (value?) return this + value->String
      else        return this + "null"

    method operator+( value:Real )->String
      $if ("C++") nativeInline '$this->plus($value)'

    method operator+( value:String )->String
      $if ("C++") nativeInline '$this->plus($value)'

    method reverse->String
      local buffer = StringBuilder(count)
      forEach (ch in this step -1)
        buffer.print( ch )
      endForEach
      return buffer->String

    method substring( i1:Integer, i2=-1:Integer )->String
      $if ("C++") nativeInline '$this->substring($i1,$i2)'

endClass

class NativeArray [native]
  METHODS
    method count->Integer [native]

    method element_size->Integer
      $if ("C++") nativeInline '$this->element_size'

    method set( i1:Integer, other:NativeArray, other_i1=0:Integer, other_i2=-1:Integer )->NativeArray
      $if ("C++") nativeInline '$this->set($i1,$other,$other_i1,$other_i2)'
endClass

class Array<<$DataType>> : NativeArray [native]
  METHODS
    method get( index:Integer )->$DataType
      inline this[ index ]
endClass

class GenericList
endClass

class List<<$DataType:Object>> : GenericList
  PROPERTIES
    data  : Array<<$DataType>>
    count : Integer

  METHODS
    method init
      init( 10 )

    method init( initial_capacity:Integer )
      data = Array<<$DataType>>( initial_capacity )

    method init( initial_capacity:Integer, initial_value:$DataType )
      data = Array<<$DataType>>( initial_capacity )
      forEach (i in 1..initial_capacity) add( initial_value )

    method clone->$DataType[]
      local result = $DataType[]( count )
      forEach (value in this)
        result.add( value )
      endForEach
      return result

    method add( value:$DataType )->$DataType[]
      reserve(1)[count] = value
      ++count
      return this

    method capacity->Integer
      if (not data) return 0
      return data.count

    method clear->$DataType[]
      count = 0
      return this

    method first->$DataType
      inline this.data[0]

    method get( index:Integer )->$DataType
      inline this.data[index]

    method last->$DataType
      return this.data[ count - 1 ]

    method locate( value:$DataType )->Integer
      forEach (i of this)
        if (data[i] == value) return i
      endForEach
      return -1

    method locate_last( value:$DataType )->Integer
      forEach (i of this step -1)
        if (data[i] == value) return i
      endForEach
      return -1

    method reserve( additional_count:Integer )->$DataType[]
      local required_capacity = count + additional_count

      if (not data)
        data = Array<<$DataType>>( 10 )
      elseIf (required_capacity > data.count)
        local x2 = capacity + capacity
        if (required_capacity < x2) required_capacity = x2 
        local new_data = Array<<$DataType>>( required_capacity )
        new_data.set( 0, data )
        data = new_data
      endIf

      return this

    method remove( value:$DataType )->$DataType
      local index = locate( value )
      if (index == -1)
        local zero_value : $DataType
        return zero_value
      endIf
      return remove_at( index )

    method remove_at( index:Integer )->$DataType
      local result = this[ index ]
      data.set( index, data, index+1 )
      local zero_value : $DataType
      data[count--] = zero_value
      return result

    method set( xyz:Integer, new_value:$DataType )->$DataType[]
      inline this.data[ xyz ] = new_value

    method to->String
      local buffer = "["
      local first = true
      forEach (value in this)
        if (first) first = false
        else       buffer += ","
        buffer += value
      endForEach
      buffer += "]"
      return buffer
endClass


class StringBuilder
  PROPERTIES
    characters   : Character[]
    indent       : Integer
    at_newline   = true

  METHODS
    method init
      init( 40 )

    method init( initial_capacity:Integer )
      characters = Character[]( initial_capacity )

    method add_indent( spaces:Integer )->this
      indent += spaces
      return this

    method capacity->Integer
      inline this.characters.capacity

    method clear->this
      characters.clear
      at_newline = true
      return this

    method count->Integer
      inline this.characters.count

    method needs_indent->Logical
      return (at_newline and indent > 0)

    method print( value:Byte )->this
      return print( value->Integer )

    method print( value:Character )->this
      if (value == '\n')    at_newline = true
      elseIf (needs_indent) print_indent
      characters.add( value )
      return this

    method print( value:Integer )->this [native]

    method print( value:Logical )->this
      if (value) return print( "true" )
      else       return print( "false" )

    method print( value:Object )->this
      if (value?) return print( value->String )
      return print( "null" )

    method print( value:Real, decimal_places=4:Integer )->this [native]

    method print( value:String )->this
      if (value?)
        if (indent?)
          forEach (ch in value) print( ch )
        else
          forEach (ch in value) characters.add( ch )
          if (value.count? and value.last == '\n') at_newline = true
        endIf
        return this
      else
        return print( "null" )
      endIf

    method print_indent
      if (not needs_indent or indent == 0) return
      forEach (i in 1..indent) characters.add( ' ' )
      at_newline = false

    method println( value:Byte )->this
      print( value->Integer )
      return print( '\n' )

    method println( value:Character )->this
      print( value )
      return print( '\n' )

    method println( value:Integer )->this
      print( value )
      return print( '\n' )

    method println( value:Logical )->this
      print( value )
      return print( '\n' )

    method println( value:Real, decimal_places=4:Integer )->this
      print( value, decimal_places )
      return print( '\n' )

    method println( value:Object )->this
      print( value )
      return print( '\n' )

    method println( value:String )->this
      print( value )
      return print( '\n' )

    method reserve( additional_count:Integer )->this
      characters.reserve( additional_count )
      return this

    method to->String
      return String( characters )
endClass

class Table<<$KeyType:Object,$ValueType:Object>>
  PROPERTIES
    bin_mask : Integer
    bins     : TableEntry<<$KeyType,$ValueType>>[]
    keys     : $KeyType[]

  METHODS
    method init
      init( 16 )

    method init( bin_count:Integer )
      local bins_power_of_2 = 1
      while (bins_power_of_2 < bin_count) bins_power_of_2 = bins_power_of_2 :<<: 1
      bin_count = bins_power_of_2
      bin_mask = bin_count - 1

      bins = TableEntry<<$KeyType,$ValueType>>[]( bin_count, null )
      keys = $KeyType[]

    method init( other:Table<<$KeyType,$ValueType>> )
      bin_mask = other.bin_mask
      bins = other.bins.clone
      keys = other.keys.clone

    method add( other:Table<<$KeyType,$ValueType>> )->Table<<$KeyType,$ValueType>>
      forEach (key in other.keys) this[key] = other[key]
      return this

    method at( index:Integer )->$ValueType
      return get( keys[index] )

    method clear
      forEach (i of bins) bins[i] = null
      keys.clear

    method clone->Table<<$KeyType,$ValueType>>
      return Table<<$KeyType,$ValueType>>( this )

    method contains( key:$KeyType )->Logical
      return find(key)?

    method count->Integer
      return keys.count

    method find( key:$KeyType )->TableEntry<<$KeyType,$ValueType>>
      local hash = key.hash_code
      local entry = bins[ hash & bin_mask ]

      while (entry?)
        if (entry.hash == hash and entry.key == key) return entry
        entry = entry.next_entry
      endWhile

      return null

    method get( key:$KeyType )->$ValueType
      local entry = find( key )
      if (entry?)
        return entry.value
      else
        local default_value : $ValueType
        return default_value
      endIf

    method remove( key:$KeyType )->$ValueType
      local hash = key.hash_code
      local index = hash & bin_mask
      local entry = bins[ index ]

      keys.remove( key )

      if (entry.hash == hash and entry.key == key)
        # First item in hash bin
        bins[index] = entry.next_entry
        return entry.value
      endIf

      local next_entry = entry.next_entry
      while (next_entry?)
        # Later item in hash bin
        if (next_entry.hash == hash and next_entry.key == key)
          local result = entry.value
          entry.next_entry = next_entry.next_entry
          return result
        endIf
        entry = next_entry
        next_entry = entry.next_entry
      endWhile

      local default_zero_value : $ValueType
      return default_zero_value

    method set( key:$KeyType, value:$ValueType )
      local hash = key.hash_code
      local index = hash & bin_mask
      local entry = bins[ index ]

      while (entry?)
        if (entry.hash == hash and entry.key == key)
          entry.value = value
          return
        endIf
        entry = entry.next_entry
      endWhile

      entry = TableEntry<<$KeyType,$ValueType>>( key, value, hash )
      entry.next_entry = bins[ index ]
      bins[index] = entry

      keys.add( key )


    #alias set_keys( key_list, value_fn ) => TableOps<<$KeyType,$ValueType>>.set_keys( this, key_list, value_fn )
    #alias set_values( value_list, key_fn ) => TableOps<<$KeyType,$ValueType>>.set_values( this, value_list, key_fn )

    method to->String
      return print_to( StringBuilder() )->String

    method print_to( buffer:StringBuilder )->StringBuilder
      buffer.print( '{' )
      local i = 0
      while (i < keys.count)
        if (i > 0) buffer.print( ',' )
        local key = keys[i]
        buffer.print( key )
        buffer.print( ':' )
        buffer.print( this[key] )
        ++i
      endWhile
      buffer.print( '}' )
      return buffer

endClass

class TableEntry<<$KeyType:Object,$ValueType:Object>>
  PROPERTIES
    key        : $KeyType
    value      : $ValueType
    next_entry : TableEntry<<$KeyType,$ValueType>>
    hash       : Integer

  METHODS
    method init( _key:$KeyType, _value:$ValueType, _hash:Integer )
      key = _key
      value = _value
      hash = _hash
endClass

