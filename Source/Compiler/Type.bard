class Type
  PROPERTIES
    t          : Token
    name       : String
    attributes : Integer
    index      = -1

    defined    : Logical
    organized  : Logical
    resolved   : Logical
    visiting   : Logical

    base_class : Type
    base_types = Type[]

    property_list   = Property[]
    property_lookup = Table<<String,Property>>() : Table<<String,Property>>

    method_list                = Method[]                   : Method[]
    method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    cpp_name : String

  METHODS
    method init( t, name )

    method add_method( m_t:Token, m_name:String )->Method
      local m = Method( m_t, this, m_name )
      method_list.add( m )
      local list = method_lookup_by_name[ m_name ]
      if (not list)
        list = Method[]
        method_lookup_by_name[ m_name ] = list
      endIf
      list.add( m )
      return m

    method add_property( p_t:Token, p_name:String )->Property
      local p = Property( p_t, this, p_name )
      property_list.add( p )
      property_lookup[p_name] = p
      return p

    method assign_cpp_name
      cpp_name = Program.validate_cpp_name( Program.code_prefix + name )
      forEach (p in property_list)
        p.cpp_name = Program.validate_cpp_name( "p_" + p.name )
      endForEach

    method extends_object->Logical
      return instance_of( Program.type_Object )

    method find_method( signature:String )->Method
      local m = method_lookup_by_signature[signature]
      if (m?) return m

      return null

    method find_property( name:String )->Property
      return property_lookup[name]

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true

      forEach (base_type in base_types)
        if (base_type.instance_of(ancestor_type)) return true
      endForEach

      return false

    method is_direct->Logical
      return not is_reference

    method is_class->Logical
      return (attributes & Attribute.type_mask) == Attribute.is_class

    method is_functional->Logical
      return (attributes & Attribute.is_functional)?

    method is_native->Logical
      return (attributes & Attribute.is_native)?

    method is_primitive->Logical
      return (attributes & Attribute.type_mask) == Attribute.is_primitive

    method is_reference->Logical
      which (attributes & Attribute.type_mask)
        case Attribute.is_class
          return true
        others
          return false
      endWhich

    method organize->Type
      if (organized) return this
      organized = true

      if (not defined)
        defined = true
        local base_name = name.before_first( "<<" )
        local template = Program.template_lookup[ base_name ]
        if (template?)
          template.instantiate( this )
        else
          throw t.error( "Reference to undefined type '$'." (name) )
        endIf
      endIf

      forEach (base_type in base_types)
        base_type.organize

        if (base_type.instance_of(this))
          throw t.error( "Cyclic inheritance attempted - $ cannot extend $ because $ already extends $." ...
              (this,base_type,base_type,this) )
        endIf
      endForEach

      if (is_class)
        forEach (base_type in base_types)
          if (base_type.is_class)
            if (base_class? and base_class isNot base_type)
              throw t.error( "Class $ can only have one base class ($ and $ are both specified as base classes)." (name,base_class,base_type) )
            else
              println "base class of $ is $" (name,base_type)
              base_class = base_type
            endIf
          endIf
        endForEach
      endIf

      forEach (m in method_list) m.organize

      return this

    method resolve->Type
      if (resolved) return this
      resolved = true

      index = Program.type_list.count
      Program.type_list.add( this )

      organize

      forEach (p in property_list) p.type.resolve

      #{
      local need_init_object = false
      forEach (p in property_list)
        if (p.initial_value?)
          need_init_object = true
          escapeForEach
        endIf
      endForEach
      }#

      forEach (m in method_list)
        m.resolve
      endForEach

      return this

    method print_data_definition( writer:CPPWriter )
      if (is_native) return

      writer.print( "struct " ).print( cpp_name ).println( " : RogueObject" );
      writer.println( "{" )
      writer.indent += 2
      forEach (p in property_list)
        writer.print( p.type ).print(" ").print( p.cpp_name ).println(";")
      endForEach
      writer.indent -= 2
      writer.println( "};" )

    method print_type_definition( writer:CPPWriter )
      if (is_native) return

      writer.print( "struct " ).print( cpp_name ).println( "Type : RogueType" )
      writer.println( "{" )

      # create_object()
      writer.print(   "  " ).print( cpp_name ).println( "* create_object()" )
      writer.println( "  {" )
      writer.print(   "    return (" ).print( cpp_name ).print( "*) rogue_program.allocate_object( this, sizeof(" )
      writer.print( cpp_name ).println( ") );" )
      writer.println( "  }" )
      writer.println

      # name()
      writer.print( "  const char* name() { return \"" ).print( name ).println( "\"; }" )
      writer.println

      # trace()
      local has_references = false
      forEach (p in property_list)
        if (p.type.is_reference) has_references = true; escapeForEach
      endForEach

      if (has_references)
        writer.println(   "  void trace( RogueObject* THIS )" )
        writer.println( "  {" )
        forEach (p in property_list)
          if (p.type.is_reference)
            writer.print( "    ROGUE_TRACE( ((")
            writer.print(this)  # cast RogueObject* ref to actual type
            writer.print(")THIS)->" ).print( p.cpp_name ).println( " );" )
          endIf
        endForEach
        writer.println( "  }" )
      endIf

      writer.println( "};" )
      writer.println

    method print_method_prototypes( writer:CPPWriter )
      if (is_native) return

      forEach (m in method_list) m.print_prototype( writer )

    method print_method_definitions( writer:CPPWriter )
      if (is_native) return

      forEach (m in method_list)
        m.print_definition( writer )
      endForEach

    method print_type_configuration( writer:CPPWriter )
      if (is_native) return
      writer.print( "  type_" ).print( cpp_name ).print( " = Rogue_types[" ).print( index )
      writer.print( "].init( " ).print( index ).print( ", \"" ).print( cpp_name ).print( "\", sizeof(Class" )
      writer.print( cpp_name ).println( ") );" )

    method to->String
      return name

endClass
