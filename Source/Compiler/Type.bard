class Type
  PROPERTIES
    t          : Token
    name       : String
    attributes : Integer
    index      = -1

    defined    : Logical
    organized  : Logical
    resolved   : Logical
    visiting   : Logical

    base_class : Type
    base_types = Type[]
    flat_base_types = Type[]

    property_list   = Property[]
    property_lookup = Table<<String,Property>>() : Table<<String,Property>>

    method_list                = Method[]                   : Method[]
    method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    cpp_name : String

  METHODS
    method init( t, name )

    method add_method( m_t:Token, m_name:String )->Method
      local m = Method( m_t, this, m_name )
      method_list.add( m )
      local list = method_lookup_by_name[ m_name ]
      if (not list)
        list = Method[]
        method_lookup_by_name[ m_name ] = list
      endIf
      list.add( m )
      return m

    method add_property( p_t:Token, p_name:String )->Property
      local p = Property( p_t, this, p_name )
      property_list.add( p )
      property_lookup[p_name] = p
      return p

    method assign_cpp_name
      cpp_name = Program.validate_cpp_name( Program.code_prefix + name )
      forEach (p in property_list)
        p.cpp_name = Program.validate_cpp_name( "p_" + p.name )
      endForEach

    method extends_object->Logical
      return instance_of( Program.type_Object )

    method find_method( signature:String )->Method
      local m = method_lookup_by_signature[signature]
      if (m?) return m

      return null

    method find_property( name:String )->Property
      return property_lookup[name]

    method instance_of( ancestor_type:Type )->Logical
      if (this is ancestor_type) return true

      forEach (base_type in base_types)
        if (base_type.instance_of(ancestor_type)) return true
      endForEach

      return false

    method is_direct->Logical
      return not is_reference

    method is_class->Logical
      return (attributes & Attribute.type_mask) == Attribute.is_class

    method is_functional->Logical
      return (attributes & Attribute.is_functional)?

    method is_native->Logical
      return (attributes & Attribute.is_native)?

    method is_primitive->Logical
      return (attributes & Attribute.type_mask) == Attribute.is_primitive

    method is_reference->Logical
      which (attributes & Attribute.type_mask)
        case Attribute.is_class
          return true
        others
          return false
      endWhich

    method organize->Type
      if (organized) return this
      organized = true

      if (not defined)
        defined = true
        local base_name = name.before_first( "<<" )
        local template = Program.template_lookup[ base_name ]
        if (template?)
          template.instantiate( this )
        else
          throw t.error( "Reference to undefined type '$'." (name) )
        endIf
      endIf

      forEach (base_type in base_types)
        base_type.organize

        if (base_type.instance_of(this))
          throw t.error( "Cyclic inheritance attempted - $ cannot extend $ because $ already extends $." ...
              (this,base_type,base_type,this) )
        endIf
      endForEach

      if (is_class)
        forEach (base_type in base_types)
          if (base_type.is_class)
            if (base_class? and base_class isNot base_type)
              throw t.error( "Class $ can only have one base class ($ and $ are both specified as base classes)." (name,base_class,base_type) )
            else
              base_class = base_type
            endIf
          endIf
        endForEach
        
        if (not base_class and not is_functional and this isNot Program.type_Object)
          Program.type_Object.resolve
          base_class = Program.type_Object; base_types.insert( base_class )
        endIf
      endIf

      # Collect flat list base types while removing duplicates
      if (base_class?) base_class.collect_base_types( flat_base_types )
      forEach (base_type in base_types)
        base_type.collect_base_types( flat_base_types )
      endForEach

      # Inherit properties
      local full_property_list = Property[]
      property_lookup.clear
      inherit_properties( full_property_list, property_lookup )
      property_list = full_property_list

      # Organize methods and create signatures
      forEach (m in method_list) m.organize

      # Create init_object() method to initialize properties
      local m = find_method( "init_object()" )
      if (not m) m = add_method( t, "init_object" ).organize
      m.return_type = this
      m.statements.add( CmdReturn(t,CmdReadThis(t,this)) )

      # Insert property initializations
      local i = property_list.count - 1
      while (i >= 0)
        local p = property_list[i]
        if (p.initial_value?)
          m.statements.insert( CmdWriteProperty(p.t, CmdReadThis(p.t,p.type_context), p, p.initial_value.clone) )
        endIf
        --i
      endWhile

      return this

    method collect_base_types( list:Type[] )
      if (list.contains(this)) return
      list.add( this )
      forEach (base_type in base_types)
        base_type.collect_base_types( list )
      endForEach

    method inherit_properties( list:Property[], lookup:Table<<String,Property>> )
      forEach (base_type in base_types) base_type.inherit_properties( list, lookup )

      forEach (p in property_list)
        local existing_p = lookup[ p.name ]
        if (existing_p?)
          local i = list.locate( existing_p )

          if (p.type_context is existing_p.type_context)
            throw p.t.error( //A property named "$" already exists.// (p.name) )
          else
            if (p.type is existing_p.type)
              if (p.initial_value?)
                if (existing_p.initial_value?)
                  if (p.type.instance_of(existing_p.type))
                    # Use the new declaration with its updated initial value
                    list[i] = p
                    lookup[p.name] = p
                  else
                    throw p.t.error( //Conflicting initial values are given for property "$" in unrelated types $ and $.// ...
                        (p.name,p.type_context,existing_p.type_context) )
                  endIf
                else
                  # Use newer property with its existing value instead of old property without a value
                  list[i] = p
                  lookup[p.name] = p
                endIf

                # Else either the original property is the one with the initial value or neither of them
                # has an initial value.  In either case leave the original property definition as the one
                # in the list.
              endIf
            else
              throw p.t.error( //Conflicting types given for property "$" - $:$ in $ and $:$ in $.// ...
                (p.name,p.name,p.type,p.type_context,p.name,existing_p.type,existing_p.type_context) )
            endIf
          endIf

        else
          list.add( p )
          lookup[p.name] = p
        endIf
      endForEach

    method resolve->Type
      if (resolved) return this
      resolved = true

      index = Program.type_list.count
      Program.type_list.add( this )

      organize

      forEach (p in property_list) p.type.resolve

      #{
      local need_init_object = false
      forEach (p in property_list)
        if (p.initial_value?)
          need_init_object = true
          escapeForEach
        endIf
      endForEach
      }#

      forEach (m in method_list)
        m.resolve
      endForEach

      return this

    method print_data_definition( writer:CPPWriter )
      if (is_native) return

      writer.print( "struct " ).print( cpp_name ).println( " : RogueObject" );
      writer.println( "{" )
      writer.indent += 2
      forEach (p in property_list)
        writer.print( p.type ).print(" ").print( p.cpp_name ).println(";")
      endForEach
      writer.indent -= 2
      writer.println( "};" )

    method print_type_definition( writer:CPPWriter )
      if (is_native) return

      writer.print( "struct " ).print( cpp_name ).println( "Type : RogueType" )
      writer.println( "{" )
      writer.indent += 2

      # configure()
      writer.println( "void configure()" )
      writer.println( "{" )
      writer.indent += 2;

      if (base_types.count?)
        writer.print( "base_type_count = " ).print( base_types.count ).println( ";" )
        writer.println( "base_types = new RogueType*[ base_type_count ];" )
        forEach (i of base_types)
          writer.print( "base_types[" ).print( i ).print( "] = rogue_program.type_" )
          writer.print( base_types[i].cpp_name ).println( ";" )
        endForEach
      endIf

      writer.indent -= 2;
      writer.println( "}" )
      writer.println()

      # create_object()
      writer.print( cpp_name ).println( "* create_object()" )
      writer.println( "{" )
      writer.print(   "  return " )
      local m_init_object = find_method( "init_object()" )
      if (m_init_object?)
        writer.print( m_init_object.cpp_name )
        writer.print( "( " )
      endIf
      writer.print(   "(" ).print( cpp_name ).print( "*) rogue_program.allocate_object( this, sizeof(" )
      writer.print( cpp_name ).print( ") )" )
      if (m_init_object?) writer.print( " )" )
      writer.println( ";" )
      writer.println( "}" )
      writer.println

      # name()
      writer.print( "const char* name() { return \"" ).print( name ).println( "\"; }" )
      writer.println

      # trace()
      local has_references = false
      forEach (p in property_list)
        if (p.type.is_reference) has_references = true; escapeForEach
      endForEach

      if (has_references)
        writer.println(   "void trace( RogueObject* THIS )" )
        writer.println( "{" )
        forEach (p in property_list)
          if (p.type.is_reference)
            writer.print( "  ROGUE_TRACE( ((")
            writer.print(this)  # cast RogueObject* ref to actual type
            writer.print(")THIS)->" ).print( p.cpp_name ).println( " );" )
          endIf
        endForEach
        writer.println( "}" )
      endIf

      writer.indent -= 2
      writer.println( "};" )
      writer.println

    method print_method_prototypes( writer:CPPWriter )
      if (is_native) return

      forEach (m in method_list) m.print_prototype( writer )

    method print_method_definitions( writer:CPPWriter )
      if (is_native) return

      forEach (m in method_list)
        m.print_definition( writer )
      endForEach

    method print_type_configuration( writer:CPPWriter )
      if (is_native) return
      writer.print( "  type_" ).print( cpp_name ).print( " = Rogue_types[" ).print( index )
      writer.print( "].init( " ).print( index ).print( ", \"" ).print( cpp_name ).print( "\", sizeof(Class" )
      writer.print( cpp_name ).println( ") );" )

    method to->String
      return name

endClass
