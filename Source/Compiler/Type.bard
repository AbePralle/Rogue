class Type
  PROPERTIES
    t          : Token
    name       : String
    attributes : Integer
    index      = -1

    defined    : Logical
    organized  : Logical
    resolved   : Logical

    method_list                = Method[]                   : Method[]
    method_lookup_by_name      = Table<<String,Method[]>>() : Table<<String,Method[]>>
    method_lookup_by_signature = Table<<String,Method>>()   : Table<<String,Method>>

    cpp_name : String

  METHODS
    method init( t, name )

    method assign_cpp_name
      cpp_name = Program.validate_cpp_name( Program.code_prefix + name )

    method find_method( signature:String )->Method
      local m = method_lookup_by_signature[signature]
      if (m?) return m

      return null

    method is_native->Logical
      return (attributes & Attributes.flag_native)?

    method organize->Type
      if (organized) return this
      organized = true

      if (not defined)
        defined = true
        local base_name = name.before_first( "<<" )
        local template = Program.template_lookup[ base_name ]
        if (template?)
          template.instantiate( this )
        else
          throw t.error( "Reference to undefined type '$'." (name) )
        endIf
      endIf

      forEach (m in method_list) m.organize

      return this

    method resolve->Type
      if (resolved) return this
      resolved = true

      index = Program.type_list.count
      Program.type_list.add( this )

      organize

      forEach (m in method_list)
        m.resolve
      endForEach

      return this

    method print_method_prototypes( writer:CPPWriter )
      if (is_native) return

      forEach (m in method_list) m.print_prototype( writer )

    method print_method_definitions( writer:CPPWriter )
      if (is_native) return

      forEach (m in method_list) m.print_definition( writer )

    method print_type_configuration( writer:CPPWriter )
      if (is_native) return
      writer.print( "  type_" ).print( cpp_name ).print( " = Rogue_types[" ).print( index )
      writer.print( "].init( " ).print( index ).print( ", \"" ).print( cpp_name ).print( "\", sizeof(Class" )
      writer.print( cpp_name ).println( ") );" )

    method print_type_definition( writer:CPPWriter )
      if (is_native or index == -1) return
      writer.print( "struct Class" ).print( cpp_name )
      writer.print " : RogueObject"
      writer.println
      writer.println( "{" )
      writer.println( "};" )

endClass
