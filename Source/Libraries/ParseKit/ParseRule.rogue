module ParseKit

class ParseRule<<$Language>>( name:String )
  PROPERTIES
    parser          : Parser<<$Language>>
    next            : ParseRule<<$Language>>
    handlers        : Table<<TokenType<<$Language>>,(Function(ParseRule<<$Language>>)->Cmd<<$Language>>)>>
    default_handler : Function(ParseRule<<$Language>>)->Cmd<<$Language>>

  METHODS
    method init( name, default_handler )

    method consume( token_type:TokenType<<$Language>> )->Logical [macro]
      this.parser.reader.consume( token_type )

    method has_another->Logical [macro]
      this.parser.reader.has_another

    method parse->Cmd<<$Language>>
      if (handlers)
        local handler = handlers[ peek.type ]
        if (handler) return handler( this )
        if (default_handler) return default_handler( this )
      endIf
      return parse_next

    method parse_next->Cmd<<$Language>>
      if (next) return next.parse
      throw ParseError<<$Language>>( ''[Internal] Parse rule $ attempting to call non-existent next parse rule.'' (name) )

    method peek->Token<<$Language>> [macro]
      this.parser.reader.peek

    method peek( lookahead:Int32 )->Token<<$Language>> [macro]
      this.parser.reader.peek( lookahead )

    method read->Token<<$Language>> [macro]
      this.parser.reader.read

    method extend( type:TokenType<<$Language>>, fn:Function(ParseRule<<$Language>>)->Cmd<<$Language>> )->this
      ensure handlers
      handlers[ type ] = fn
      return this

    method extend( type:TokenType<<$Language>>, type_info:TypeInfo )->this
      throw UnsupportedOperationError()

    method on_default( fn:Function(ParseRule<<$Language>>)->Cmd<<$Language>> )->this
      default_handler = fn
      return this

endClass


class BinaryParseRule<<$Language>> : ParseRule<<$Language>>
  PROPERTIES
    lookup = Table<<TokenType<<$Language>>,TypeInfo>>()

  METHODS
    method parse->Cmd<<$Language>>
      return parse( parse_next )

    method parse( context:Cmd<<$Language>> )->Cmd<<$Language>>
      local t = peek
      local entry = lookup.find( t.type )
      if (entry)
        read
        return parse( entry.value.create_object<<CmdBinary<<$Language>>>>.init(t,context,parse_next) )
      else
        return context
      endIf

    method extend( type:TokenType<<$Language>>, type_info:TypeInfo )->this
      lookup[ type ] = type_info
      return this

endClass

