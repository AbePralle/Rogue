$module Boss

class VM
  ENUMERATE
    REAL_ID    = 1
    INTEGER_ID = 2
    LOGICAL_ID = 3
    STRING_ID  = 4

  PROPERTIES
    global_dispatch  = Method[]
    context_dispatch = Table<<Int32,Method>>[]
    id_lookup        = Table<<String,Int32>>()

    free_tasks    = Task[]
    active_tasks  = Task[]

    native_return = Cmd[]

  METHODS
    method init
      native_return.add( CmdPopFrame(Token()) )

      name_to_id( "Real" )     # id 1
      name_to_id( "Integer" )  # id 2
      name_to_id( "Logical" )  # id 3
      name_to_id( "String" )   # id 4

    method execute( source:String, filepath="[Internal]":String )->Result
      return execute_new_task( source, filepath ).result

    method execute_new_task( source:String, filepath="[Internal]":String )->Task
      # Internal use.
      local task : Task

      if (free_tasks.count) task = free_tasks.remove_last
      else                  task = Task( this )

      task.reset
      task.result = Result()
      task.load( source, filepath )
      if (task.execute) 
        # Did not finish immediately
        active_tasks.add( task )
      else
        free_tasks.add( task )
      endIf
      return task

    method evaluate( source:String )->Value
      local task = execute_new_task( source )
      if (not task.is_finished)
        throw task.error( "Code cannot be evaluated because it contains a blocking call." )
      endIf
      return task.result.value

    method evaluate_integer( source:String )->Int32 [macro]
      this.evaluate( source )->Int32

    method name_to_id( name:String )->Int32
      local entry = id_lookup.find( name )
      if (entry) return entry.value
      
      local id_value = id_lookup.count + 1
      id_lookup[ name ] = id_value
      return id_value

    method register( name:String, min_param_count:Int32, on_call:Function(Task) )
      local dot = name.locate( '.' )
      if (dot.exists)
        # TypeName.method_name
        local context_id = name_to_id( name.before_first('.') )
        local m_id = name_to_id( name.after_first('.') )

        local lookup = context_dispatch.expand_to_include( context_id )[ context_id ]
        if (not lookup)
          lookup = Table<<Int32,Method>>()
          context_dispatch[ context_id ] = lookup
        endIf
        lookup[ m_id ] = Method( this, name, min_param_count, on_call )

      else
        # Global method
        local m_id = name_to_id( name )
        global_dispatch.expand_to_include( m_id )[ m_id ] = Method( this, name, min_param_count, on_call )
      endIf

    method update->Logical
      local write_i = 0
      forEach (task in active_tasks)
        if (task.execute)
          active_tasks[write_i] = task
          ++write_i
        else
          free_tasks.add( task )
        endIf
      endForEach
      active_tasks.discard_from( write_i )
      return (write_i > 0)
endClass

class Result
  PROPERTIES
    value    : Value
    is_ready : Logical
endClass

class Error : ::Error
  PROPERTIES
    filepath : String
    line     : Int32
    column   : Int32

  METHODS
    method init( t:Token, message )
      filepath = t.filepath
      line = t.line
      column = t.column

    method to->String
      local builder = StringBuilder()
      local m = message.word_wrapped(79).joined
      if (filepath)
        builder.println( "===============================================================================" )
        builder.print( ''ERROR in "'' ).print( File.filename(filepath) )
        builder.print( ''"  line '' ).print( line ).print( ", column " ).println( column )
        builder.println
        builder.println( m )
        builder.println( "===============================================================================" )
      else
        builder.println( "===============================================================================" )
        builder.print( "ERROR" )
        builder.println
        builder.println( m )
        builder.println( "===============================================================================" )
      endIf
      return builder->String

endClass

class Frame
  PROPERTIES
    ip          : Int32
    fp          : Int32
    arg_count   : Int32
    commands    : Cmd[]
    method_info : Method
    locals      : Value[]

  METHODS
    method init
      commands = Cmd[]

    method init( commands )

    method init( method_info )
      commands = method_info.commands

    method create_local( index:Int32, initial_value:Value )
      if (not locals) locals = Value[]
      locals.expand_to_include( index )[ index ] = initial_value
endClass

class TaskStatus
  ENUMERATE
    INITIALIZING
    RUNNING
    SUSPENDED
    FINISHED
endClass

class Task
  PROPERTIES
    vm          : VM
    stack       = Value[]
    frame       = Frame()
    frames      = Frame[]

    commands    = Cmd[]

    status    : Int32
    result    : Result
    filepath  : String

  METHODS
    method init( vm )

    method reset->Task
      stack.clear
      stack.add( NullValue() )  # default 'this'

      frames.clear
      status = TaskStatus.INITIALIZING
      frame = Frame( commands )

      return this

    method arg( index:Int32 )->Value
      return stack[ frame.fp + index ]

    method real_arg( index:Int32 )->Real64
      return stack[ frame.fp + index ]->Real64

    method integer_arg( index:Int32 )->Int32
      return stack[ frame.fp + index ]->Int32

    method object_arg( index:Int32 )->Object
      return stack[ frame.fp + index ]->Object

    method string_arg( index:Int32 )->String
      return stack[ frame.fp + index ]->String

    method arg_count->Int32 [macro]
      this.frame.arg_count

    method ensure_arg_count( n:Int32 )->this
      while (arg_count < n)
        stack.add( NullValue() )
        ++frame.arg_count
      endWhile
      return this

    method error( message:String )->Error
      local t : Token
      if (frame.commands.count) t = frame.commands[frame.ip].t
      else                      t = Token().set_info( filepath, 0, 0 )
      throw t.error( message )

    method is_finished->Logical
      return (status == TaskStatus.FINISHED)

    method load( source:String, filepath )->this
      try
        commands.add( Parser(this).parse(source,filepath) )
      catch (err:Error)
        println err
      endTry
      return this

    method execute->Logical
      # Returns false if the task is finished
      if (frame.commands.count == 0) return false

      if (status == TaskStatus.INITIALIZING)
        resolve_commands
        status = TaskStatus.RUNNING
      endIf

      try
        if (status == TaskStatus.RUNNING)
          local cmd = frame.commands[frame.ip]
          ++frame.ip
          while (cmd.execute(this))
            cmd = frame.commands[frame.ip]
            ++frame.ip
          endWhile
        endIf
      catch (err:Error)
        println err
      endTry

      if (is_finished)
        result.value = pop
        return false
      else
        return true
      endIf

    method pop->Value
      if (stack.count) return stack.remove_last
      else              return NullValue()

    method pop_integer->Int32
      if (stack.count) return stack.remove_last->Int32
      else             return 0

    method pop_object->Object
      if (stack.count) return stack.remove_last->Object
      else             return null

    method pop_real->Real64
      if (stack.count) return stack.remove_last->Real64
      else             return 0

    method push_integer( value:Int32 )->this
      stack.add( IntegerValue(value) )
      return this

    method push_object( value:Object, object_type_name=null:String )->this
      if (value)
        if (not object_type_name) object_type_name = value.type_name
        stack.add( ObjectValue(value,vm.name_to_id(object_type_name)) )
      else
        stack.add( NullValue() )
      endIf
      return this

    method push_string( value:String )->this
      stack.add( StringValue(value) )
      return this

    method push_real( value:Real64 )->this
      stack.add( RealValue(value) )
      return this

    method push_this->this
      return push( stack[frame.fp] )

    method push( value:Value )->this
      if (value) stack.add( value )
      else       stack.add( NullValue() )
      return this

    method push_generic_frame( new_arg_count:Int32 )->Frame
      frames.add( frame )  # save current frame
      frame = Frame( null as Cmd[] )
      frame.fp = stack.count - (new_arg_count+1)  # +1 includes 'this'
      frame.arg_count = new_arg_count
      return frame

    method push_native_frame( new_arg_count:Int32 )->Frame
      frames.add( frame )  # save current frame
      frame = Frame( vm.native_return )  # vm.native_return[0] has a pop frame command
      frame.fp = stack.count - (new_arg_count+1)  # +1 includes 'this'
      frame.arg_count = new_arg_count
      return frame

    method pop_frame
      local result = stack.last
      stack.discard_from( frame.fp )
      stack.add( result )

      frame = frames.remove_last

    method resolve_commands
      local builder = CmdBuilder( commands )
      forEach (cmd in builder)
        cmd.resolve( this, builder )
      endForEach

    method resume->this
      status = TaskStatus.RUNNING
      return this

    method suspend->this
      status = TaskStatus.SUSPENDED
      return this

endClass

class Type
  PROPERTIES
    vm        : VM
    name      : String
    on_create : Function(Task)

  METHODS
    method init( vm, name, on_create )
endClass


class Method
  PROPERTIES
    vm              : VM
    name            : String
    fn              : Function(Task)
    min_param_count : Int32
    commands        : Cmd[]

  METHODS
    method init( vm, name, min_param_count, fn )
endClass

class Value
  ENUMERATE
    TYPE_NULL
    TYPE_REAL
    TYPE_INTEGER
    TYPE_LOGICAL
    TYPE_OBJECT
    TYPE_STRING

  PROPERTIES
    type : Int32

  METHODS
    method init( type )

    method id->Int32
      return 0

    method operator+( other:Value )->Value
      return RealValue(0)

    method operator*( other:Value )->Value
      return RealValue(0)

    method to->Int32
      return 0

    method to->Object
      return null

    method to->Real64
      return 0

endClass


class IntegerValue : Value
  PROPERTIES
    value : Int32

  METHODS
    method init( value )
      type = TYPE_INTEGER

    method id->Int32
      return VM.INTEGER_ID

    method operator+( other:Value )->Value
      which (other.type)
        case TYPE_REAL:    return RealValue( value + other->Real64 )
        case TYPE_INTEGER: return IntegerValue( value + other->Int32 )
        case TYPE_STRING:  return StringValue( value + other->String )
        others:            return IntegerValue( 0 )
      endWhich

    method operator*( other:Value )->Value
      which (other.type)
        case TYPE_REAL:    return RealValue( value * other->Real64 )
        case TYPE_INTEGER: return IntegerValue( value * other->Int32 )
        case TYPE_STRING:  return StringValue( value * other->String )
        others:            return IntegerValue( 0 )
      endWhich

    method to->Int32
      return value

    method to->Real64
      return value

    method to->String
      return value->String
endClass


class NullValue : Value
  METHODS
    method init
      type = TYPE_NULL

    method to->String
      return "null"
endClass


class ObjectValue : Value
  PROPERTIES
    value   : Object
    type_id : Int32

  METHODS
    method init( value, type_id )
      type = TYPE_OBJECT

    method id->Int32
      return type_id

    method to->Object
      return value

    method to->String
      return value->String
endClass


class RealValue : Value
  PROPERTIES
    value : Real64

  METHODS
    method init( value )
      type = TYPE_REAL

    method id->Int32
      return VM.REAL_ID

    method operator+( other:Value )->Value
      which (other.type)
        case TYPE_REAL:    return RealValue( value + other->Real64 )
        case TYPE_INTEGER: return RealValue( value + other->Int32 )
        case TYPE_STRING:  return StringValue( value->Int32 + other->String )
        others:            return IntegerValue( 0 )
      endWhich

    method operator*( other:Value )->Value
      which (other.type)
        case TYPE_REAL:    return RealValue( value * other->Real64 )
        case TYPE_INTEGER: return RealValue( value * other->Int32 )
        case TYPE_STRING:  return StringValue( value->Int32 * other->String )
        others:            return IntegerValue( 0 )
      endWhich

    method to->Int32
      return value->Int32

    method to->Real64
      return value

    method to->String
      return value->String
endClass

class StringValue : Value
  PROPERTIES
    value : String

  METHODS
    method init( value )
      type = TYPE_STRING

    method id->Int32
      return VM.LOGICAL_ID

    method operator+( other:Value )->Value
      return StringValue( value + other->String )

    method operator*( other:Value )->Value
      which (other.type)
        case TYPE_REAL:    return StringValue( value * other->Int32 )
        case TYPE_INTEGER: return StringValue( value * other->Int32 )
        others:            return IntegerValue( 0 )
      endWhich

    method to->String
      return value
endClass

class TokenType [requisite]
  ENUMERATE
    INVALID
    EOL
    LITERAL_INTEGER
    LITERAL_REAL
    LITERAL_NULL
    LITERAL_STRING
    IDENTIFIER
    KEYWORD_LOCAL
    SYMBOL_CLOSE_PAREN
    SYMBOL_COMMA
    SYMBOL_DOT
    SYMBOL_EQ
    SYMBOL_EQUALS
    SYMBOL_FAT_ARROW
    SYMBOL_OPEN_PAREN
    SYMBOL_PLUS
    SYMBOL_PLUS_EQUALS
    SYMBOL_PLUS_PLUS
    SYMBOL_SEMICOLON
    SYMBOL_TIMES
    SYMBOL_TIMES_EQUALS

  GLOBAL PROPERTIES
    type_to_name = Table<<Int32,String>>()

  GLOBAL METHODS
    method init_class
      type_to_name[ EOL ]                 = "\n"
      type_to_name[ LITERAL_INTEGER ]     = "literal integer"
      type_to_name[ LITERAL_REAL ]        = "literal real"
      type_to_name[ LITERAL_NULL ]        = "literal null"
      type_to_name[ LITERAL_STRING ]      = "literal string"
      type_to_name[ IDENTIFIER ]          = "identifier"
      type_to_name[ SYMBOL_CLOSE_PAREN ]  = ")"
      type_to_name[ SYMBOL_COMMA ]        = ","
      type_to_name[ SYMBOL_DOT ]          = "."
      type_to_name[ SYMBOL_EQ ]           = "=="
      type_to_name[ SYMBOL_EQUALS ]       = "="
      type_to_name[ SYMBOL_FAT_ARROW ]    = "=>"
      type_to_name[ SYMBOL_OPEN_PAREN ]   = "("
      type_to_name[ SYMBOL_PLUS ]         = "+"
      type_to_name[ SYMBOL_PLUS_EQUALS ]  = "+="
      type_to_name[ SYMBOL_PLUS_PLUS ]    = "++"
      type_to_name[ SYMBOL_SEMICOLON ]    = ";"
      type_to_name[ SYMBOL_TIMES]         = "*"
      type_to_name[ SYMBOL_TIMES_EQUALS ] = "*="

    method display_name( type:Int32 )->String
      which (type)
        case EOL:             return "[end of line]"
        case LITERAL_INTEGER: return "literal integer"
        others:               return "'$'" (type_to_name[type])
      endWhich

    method name( type:Int32 )->String
      local result = type_to_name[ type ]
      if (result) return result
      return "(???)"

endClass

class Token
  PROPERTIES
    filepath : String
    line     : Int32
    column   : Int32
    type     : Int32

  METHODS
    method init( type )

    method error( message:String )->Error
      return Error( this, message )

    method set_info( filepath, line, column )->this
      return this

    method to->Int32
      return 0

    method to->Real64
      return 0

    method to->String
      return TokenType.display_name( type )

endClass

class IntegerToken : Token
  PROPERTIES
    value : Int32

  METHODS
    method init( value )
      type = TokenType.LITERAL_INTEGER

    method to->Int32
      return value

    method to->String
      return value->String
endClass

class RealToken : Token
  PROPERTIES
    value : Real64

  METHODS
    method init( value )
      type = TokenType.LITERAL_REAL

    method to->Int32
      return value->Real64

    method to->Real64
      return value

    method to->String
      return value->String
endClass

class StringToken : Token
  PROPERTIES
    value : String

  METHODS
    method init( type, value )

    method to->String
      return value->String
endClass

class Parser
  PROPERTIES
    vm               : VM
    task             : Task
    tokens           : Token[]
    token_index      : Int32
    token_count      : Int32

    commands         = Cmd[]

    next_local_index = 0
    local_lookup     = Table<<String,Int32>>[] [null]

  METHODS
    method init( task )
      vm = task.vm

    method add( command:Cmd )
      commands.add( command )

    method add_local( name:String )->Int32
      if (not local_lookup.last)
        local_lookup[ local_lookup.count - 1 ] = Table<<String,Int32>>()
      endIf
      local_lookup.last[name] = next_local_index
      ++next_local_index
      return next_local_index - 1

    method consume( token_type:Int32 )->Logical
      if (token_index == token_count) return false
      local t = tokens[ token_index ]
      if (t.type != token_type) return false
      ++token_index
      return true

    method consume_eols->Logical
      local found_any = false
      while (consume(TokenType.EOL)) found_any = true
      return found_any

    method consume_end_command->Logical
      return (consume_eols or consume(TokenType.SYMBOL_SEMICOLON) or not has_another)

    method error( message:String )->Error
      if (token_index < token_count)
        return tokens[ token_index ].error( message )
      else
        if (token_count == 0) return Token().error( message )
        else                  return tokens.last.error( message )
      endIf

    method find_local( name:String )->Int32?
      local i = local_lookup.count
      while (i > 0)
        --i
        local scope = local_lookup[i]
        if (scope)
          local entry = scope.find( name )
          if (entry) return entry.value
        endIf
      endWhile
      return null

    method has_another->Logical
      return (token_index < token_count)

    method must_consume( token_type:Int32 )
      if (consume(token_type)) return

      throw error( "$ expected, found $." (TokenType.display_name(token_type),peek->String) )

    method must_consume_end_command
      if (consume_end_command) return
      throw error( "End of line or ';' expected, found $." (peek->String) )

    method read_identifier->String
      local t = peek
      must_consume( TokenType.IDENTIFIER )
      return t->String

    method next_is( token_type:Int32 )->Logical
      if (token_index == token_count) return false
      local t = tokens[ token_index ]
      return (t.type == token_type)

    method next_is_end_command->Logical
      return (next_is(TokenType.EOL) or next_is(TokenType.SYMBOL_SEMICOLON))

    method parse( source:String, filepath:String )->Cmd[]
      tokens = Tokenizer( filepath, source ).tokenize
      token_count = tokens.count
      parse_elements
      add( CmdHalt(Token()) )
      return commands

    method parse_elements
      consume_eols
      while (has_another)
        parse_statements
      endWhile

    method parse_statements
      while (has_another)
        parse_statement
        must_consume_end_command
      endWhile

    method parse_statement
      consume_eols
      if (not has_another) return

      local t = peek

      if (consume(TokenType.KEYWORD_LOCAL))
        local first = true
        while (first or consume(TokenType.SYMBOL_COMMA))
          first = false
          local name = read_identifier
          local declaration = CmdDeclareLocal( t, add_local(name) )
          if (consume(TokenType.SYMBOL_EQUALS))
            declaration.has_initial_value = true
            parse_expression
          endIf
          commands.add( declaration )
        endWhile
        return
      endIf

      local i1 = commands.count
      parse_expression
      if (not next_is_end_command and commands.count > i1)
        local access = commands.last as CmdAccess
        if (access and access.arg_count == 0)
          # add no-parens args
          commands.remove_last
          access.arg_count = parse_args( false )
          commands.add( access )
        endIf
      endIf

    method parse_expression
      consume_eols
      parse_add_subtract

    method parse_add_subtract
      parse_multiply_divide
      parse_add_subtract_rhs

    method parse_add_subtract_rhs
      local t = peek
      if (consume(TokenType.SYMBOL_PLUS))
        parse_multiply_divide
        add( CmdAdd(t) )
        parse_add_subtract_rhs
      endIf

    method parse_multiply_divide
      parse_member_access
      parse_multiply_divide_rhs

    method parse_multiply_divide_rhs
      local t = peek
      if (consume(TokenType.SYMBOL_TIMES))
        parse_member_access
        add( CmdMultiply(t) )
        parse_multiply_divide_rhs
      endIf

    method parse_member_access
      parse_term
      parse_member_access_rhs

    method parse_member_access_rhs
      local t = peek
      if (consume(TokenType.SYMBOL_DOT))
        local name = read_identifier
        commands.add( CmdContextAccess(t, name, parse_args) )
        parse_member_access_rhs
      endIf

    method parse_term
      local t = read
      which (t.type)
        case TokenType.LITERAL_INTEGER
          commands.add( CmdLiteralInteger(t, t->Int32) )

        case TokenType.LITERAL_REAL
          commands.add( CmdLiteralReal(t, t->Real64) )

        case TokenType.LITERAL_NULL
          commands.add( CmdLiteralNull(t) )

        case TokenType.LITERAL_STRING
          commands.add( CmdLiteralString(t,t->String) )

        case TokenType.IDENTIFIER
          local name = t->String

          # Check for local access
          local index = find_local( name )
          if (index.exists)
            commands.add( CmdReadLocal(t,index.value) )
            return
          endIf

          commands.add( CmdReadGlobalContext(t) )
          commands.add( CmdAccess(t, name, parse_args) )

        case TokenType.SYMBOL_OPEN_PAREN
          parse_expression
          must_consume( TokenType.SYMBOL_CLOSE_PAREN )

        others
          throw t.error( "Syntax error - unexpected $." (t) )

      endWhich

    method parse_args( require_parens=true:Logical )->Int32
      if (require_parens)
        if (not consume(TokenType.SYMBOL_OPEN_PAREN)) return 0
        if (consume(TokenType.SYMBOL_CLOSE_PAREN))    return 0
      endIf

      local arg_count = 0
      local first = true
      while (has_another and (first or consume(TokenType.SYMBOL_COMMA)))
        first = false
        parse_expression
        ++arg_count
      endWhile

      if (require_parens) must_consume( TokenType.SYMBOL_CLOSE_PAREN )
      return arg_count

    method peek( skip=0:Int32 )->Token
      local peek_index = token_index + skip
      if (peek_index >= token_count) return Token( TokenType.INVALID )
      return tokens[ peek_index ]

    method push_scope
      local_lookup.add( null )

    method pop_scope
      local_lookup.remove_last

    method read->Token
      if (token_index == token_count)
        throw error( "Unexpected end of input." )
      endIf
      ++token_index
      return tokens[ token_index - 1 ]
endClass

class Keywords [singleton]
  PROPERTIES
    table : Table<<String,Int32>>

  METHODS
    method get( id:String )->Int32?
      if (not table)
        table = Table<<String,Int32>>()
        table[ "null" ]  = TokenType.LITERAL_NULL
        table[ "local" ] = TokenType.KEYWORD_LOCAL
      endIf

      if (table.contains(id)) return table[ id ]
      return null
endClass

class Tokenizer
  PROPERTIES
    reader   : ParseReader
    tokens   : Token[]
    buffer   = StringBuilder()
    filepath : String
    line     : Int32
    column   : Int32

  METHODS
    method init( filepath, source:String )
      reader = ParseReader( source, 2 )

    method add_token( type:Int32 )->Logical
      tokens.add( Token(type).set_info(filepath,line,column) )
      return true

    method add_integer_token( value:Int32 )->Logical
      tokens.add( IntegerToken(value).set_info(filepath,line,column) )
      return true

    method add_real_token( value:Real64 )->Logical
      tokens.add( RealToken(value).set_info(filepath,line,column) )
      return true

    method add_string_token( type:Int32, value:String )->Logical
      tokens.add( StringToken(type,value).set_info(filepath,line,column) )
      return true

    method consume( ch:Character )->Logical [macro]
      this.reader.consume( ch )

    method error( message:String )->Error
      return Token().set_info( filepath, line, column ).error( message )

    method tokenize->Token[]
      tokens = Token[]

      while (tokenize_another) noAction

      return tokens

    method tokenize_another->Logical
      reader.consume_spaces

      line = reader.line
      column = reader.column

      if (not reader.has_another) return false

      local ch = reader.peek

      if (ch >= '0' and ch <= '9')
        which (reader.peek(1))
          case 'b': return tokenize_integer_in_base(2)
          case 'c': return tokenize_integer_in_base(8)
          case 'x': return tokenize_integer_in_base(16)
          others:   return tokenize_number
        endWhich

      elseIf (ch.is_letter or ch.is_number)
        tokenize_identifier
        return true

      elseIf (ch == 10)
        reader.read
        add_token( TokenType.EOL )
        return true

      elseIf (ch == '"')
        return tokenize_string( ch )

      else
        # Either a symbol or a decimal like ".1".
        if (ch == '.')
          local next = reader.peek(1)
          if (next >= '0' and next <= '9') return tokenize_number
        endIf

        # Symbol
        local token_type = scan_symbol_token_type
        if (token_type == -1) return true  # something else is happening; it's fine
        return add_token( token_type )
      endIf

    method tokenize_identifier
      buffer.clear.print( reader.read )
      local ch = reader.peek
      while (ch.is_identifier)
        buffer.print( reader.read )
        ch = reader.peek
      endWhile

      local name = buffer->String
      local keyword_type = Keywords[ name ]
      if (keyword_type.exists)
        add_token( keyword_type.value )
      else
        add_string_token( TokenType.IDENTIFIER, name )
      endIf

    method tokenize_integer_in_base( base:Int32 )->Logical
      reader.read  # '0'
      reader.read  # [b,c,x] = [2,8,16]

      local count = 0
      local n = 0
      local digit = reader.peek.to_number( base )
      while (reader.has_another and digit != -1)
        if (digit >= base) throw error( "Digit out of range for base " + base + "." )
        ++count
        n = n * base + digit
        reader.read
        digit = reader.peek.to_number( base )
      endWhile

      if (count == 0) throw error( "One or more digits expected." )

      tokens.add( IntegerToken(TokenType.LITERAL_INTEGER).set_info(filepath,line,column) )
      return true

    method tokenize_number->Logical
      local is_negative = consume('-')

      local i = 0
      while (reader.has_another(i+1) and reader.peek(i).is_number()) ++i
      local ch = reader.peek(i)
      local is_real = ((ch == '.' and reader.peek(i+1).is_number) or ch == 'e' or ch == 'E')

      if (is_real)
        # We have a real number
        local n = scan_real
        ch = reader.peek

        if (ch == '.')
          ch = reader.peek(1)
          if (ch >= '0' and ch <= '9')
            reader.read
            local start_pos = reader.position
            local fraction = scan_real
            n += fraction / 10.0^(reader.position - start_pos)
          elseIf (ch == '.')
            # Start of range
            if (is_negative) n = -n
            return add_integer_token( n->Int32 )
          elseIf ((ch >= 'a' and ch <= 'z') or (ch >= 'A' and ch <= 'Z') or ch == '_')
            # E.g. 5.hash_code is (5).hash_code, not 5.0hashcode
            return add_integer_token( n->Int32 )
          else
            if (is_negative) n = -n
            return add_real_token( n )
          endIf
        endIf

        if (consume('E') or consume('e'))
          local negative_exponent = consume('-')
          if (not negative_exponent) consume('+')
          local power = scan_real
          if (negative_exponent) n /= 10.0^power
          else                   n *= 10.0^power
        endIf

        if (is_negative) n = -n;
        return add_real_token( n )

      else
        # Int32 or Real64
        local n = scan_long
        if (is_negative) n = -n;

        if (n == n->Int32)
          return add_integer_token( n->Int32 )
        else
          return add_real_token( n )
        endIf
      endIf

    method scan_real->Real64
      local n = 0.0
      local ch = reader.peek
      while (ch >= '0' and ch <= '9')
        local intval = reader.read->Int32 - '0'
        n = n * 10 + intval
        ch = reader.peek
      endWhile
      return n

    method scan_long->Int64
      local n = 0 : Int64
      local ch = reader.peek
      while (ch >= '0' and ch <= '9')
        local intval = reader.read->Int32 - '0'
        n = n * 10 + intval
        ch = reader.peek
      endWhile
      return n

    method tokenize_string( terminator:Character )->Logical
      buffer.clear
      reader.read
      while (reader.has_another)
        local ch = reader.peek
        if (ch == terminator)
          reader.read
          add_string_token( TokenType.LITERAL_STRING, buffer->String )
          return true
        else
          scan_character
        endIf
      endWhile

      throw error( "End of input reached while looking for end of string." )

    method tokenize_verbatim_string->Logical
      buffer.clear
      reader.read
      reader.read
      while (reader.has_another)
        local ch = reader.read
        if (ch == 10)
          reader.consume_spaces
          if (consume('|'))
            buffer.print( ch )
          else
            add_string_token( TokenType.LITERAL_STRING, buffer->String )
            return add_token( TokenType.EOL )
          endIf
        else
          buffer.print( ch )
        endIf
      endWhile

      throw error( "End of File reached while looking for end of verbatim string." )

    method scan_character
      # Adds a character to a buffer while handling any escape sequences.
      if (not reader.has_another) throw error( "Character expected." )

      local ch = reader.peek
      if (ch == '\n') throw error( "Character expected; found end of line." )

      if (ch == '\\')
        reader.read
        if (not reader.has_another) throw error( "Escaped character expected; found end of input." )

        local value : Int32
        if     (consume('b')) value = 8
        elseIf (consume('f')) value = 12
        elseIf (consume('n')) value = '\n'
        elseIf (consume('r')) value = '\r'
        elseIf (consume('t')) value = '\t'
        elseIf (consume('v')) value = 11
        elseIf (consume('0')) value = '\0'
        elseIf (consume('/')) value = '/'
        elseIf (consume('\''))value = '\''
        elseIf (consume('\\'))value = '\\'
        elseIf (consume('"')) value = '"'
        elseIf (consume('x')) value = scan_hex_value(2)
        elseIf (consume('u')) value = scan_hex_value(4)
        elseIf (consume('s')) value = scan_hex_value(6)
        # supplementary - 6-digit Unicode converted to a surrogate pair if needed
        else throw error( "Invalid escape sequence.  Supported: \\n \\r \\s \\t \\0 \\/ \\' \\\\ \\\" \\" + "uXXXX \\" + "xXX." )

        if (value < 0x10000)
          # Standard Unicode
          buffer.print( value->Character )
        else
          # Surrogate pair
          value -= 0x10000
          buffer.print( (0xd800 + ((value:>>:10)&0x3ff))->Character )
          buffer.print( (0xdc00 + (value&0x3ff))->Character )
        endIf

      else
        local value = reader.read->Int32
        if ((value & 0x80) != 0)
          # Handle UTF8 encoding
          local ch2 = reader.read->Int32

          if ((value & 0x20) == 0)
            # %110xxxxx 10xxxxxx
            value = value & 0x1f
            ch2 = value & 0x3f
            buffer.print( ((value:<<:6) | ch2)->Character )
          else
            # %1110xxxx 10xxxxxx 10xxxxxx
            local ch3 = reader.read->Int32
            value = value & 15
            ch2 = ch2 & 0x3f
            ch3 = ch3 & 0x3f
            buffer.print( ((value:<<:2) | (ch2:<<:6) | ch3)->Character )
          endIf

        else
          buffer.print( value->Character )
        endIf

      endIf

    method next_is_hex_digit->Logical
      local ch = reader.peek
      return (ch >= '0' and ch <= '9') or (ch >= 'a' and ch <= 'f') or (ch >= 'A' and ch <= 'F')

    method scan_hex_value( digits:Int32 )->Int32
      local value = 0
      local i = 1
      while (i <= digits)
        if (not reader.has_another) throw error( digits + "-digit hex value expected; found end of file." )
        if (not next_is_hex_digit)
          local ch = reader.peek
          local error_buffer = StringBuilder()
          error_buffer.print( "Invalid hex digit " )
          if (ch < ' ' or ch->Int32 == 127) error_buffer.print( ch->Int32 )
          else error_buffer.print( "'" + ch + "'" )
          error_buffer.print('.')
          throw error( error_buffer->String )
        endIf
        local intval = reader.read.to_number(16)
        value = (value:<<:4) + intval
        ++i
      endWhile
      return value

    method scan_symbol_token_type->Int32
      local ch = reader.read

      #{
      if (ch == '!')
        if (consume('=')) return TokenType.symbol_ne
        else              return TokenType.symbol_exclamation_point

      elseIf (ch == '$' )
        local id = read_identifier
        which (id)
          case "define":              add_new_token( TokenType.directive_define )
          case "include":             add_new_token( TokenType.directive_include )
          case "includeNativeCode":   add_new_token( TokenType.directive_includeNativeCode )
          case "includeNativeHeader": add_new_token( TokenType.directive_includeNativeHeader )
          case "if":                  add_new_token( TokenType.directive_if )
          case "elseIf":              add_new_token( TokenType.directive_elseIf )
          case "else":                add_new_token( TokenType.directive_else )
          case "endIf":               add_new_token( TokenType.directive_endIf )
          case "module":              add_new_token( TokenType.directive_module )
          case "requisite":           add_new_token( TokenType.directive_requisite )
          case "using":               add_new_token( TokenType.directive_using )
          others
            add_new_token( TokenType.placeholder_id, "$" + id )
        endWhich
        return null

      elseIf (ch == '%')
        if     (consume('=')) return TokenType.symbol_percent_equals
        else                  return TokenType.symbol_percent


      elseIf (ch == '&' )
        if     (consume('&')) throw error( "Use 'and' instead of '&&'." )
        elseIf (consume('=')) return TokenType.symbol_ampersand_equals
        else                  return TokenType.symbol_ampersand
        }#

      if (ch == '(')
        return TokenType.SYMBOL_OPEN_PAREN

      elseIf (ch == ')')
        return TokenType.SYMBOL_CLOSE_PAREN

      elseIf (ch == '*')
        if     (consume('=')) return TokenType.SYMBOL_TIMES_EQUALS
        else                  return TokenType.SYMBOL_TIMES

      elseIf (ch == '+')
        if     (consume('=')) return TokenType.SYMBOL_PLUS_EQUALS
        elseIf (consume('+')) return TokenType.SYMBOL_PLUS_PLUS
        else                  return TokenType.SYMBOL_PLUS

      elseIf (ch == ',')
        return TokenType.SYMBOL_COMMA

        #{
      elseIf (ch == '-')
        if     (consume('='))  return TokenType.symbol_minus_equals
        elseIf (consume('-'))  return TokenType.symbol_minus_minus
        elseIf (reader.peek(0) == '>' and reader.peek(1) == '>') return TokenType.symbol_minus
        elseIf (consume('>'))  return TokenType.symbol_arrow
        else                   return TokenType.symbol_minus
        }#

      elseIf (ch == '.' )
        #{
        if (consume('.'))
          if (consume('.'))
            # ellipsis
            while (consume(' ')) noAction
            if (not consume('\n')) throw error( "End of line expected after '...'." )
            return null 
          elseIf (consume('<'))
            return TokenType.symbol_upToLessThan
          elseIf (consume('>'))
            return TokenType.symbol_downToGreaterThan
          else
            return TokenType.symbol_upTo
          endIf
        elseIf (consume('='))
          return TokenType.symbol_dot_equals
        else
        }#
          return TokenType.SYMBOL_DOT
        #endIf

        #{
      elseIf (ch == '/')
        if (consume('='))
          return TokenType.symbol_slash_equals
        else
          return TokenType.symbol_slash
        endIf

      elseIf (ch == ':')
        if (consume(':'))
          add_new_token( TokenType.identifier, "::" + read_identifier )
          return null
        endIf

        if (consume("<<:"))  return TokenType.symbol_shift_left
        elseIf (consume(">>:"))  return TokenType.symbol_shift_right
        elseIf (consume(">>>:")) return TokenType.symbol_shift_right_x
        return TokenType.symbol_colon
      }#

      elseIf (ch == ';')
        return TokenType.SYMBOL_SEMICOLON

      #{
      elseIf (ch == '<' )
        if     (consume('<')) return TokenType.symbol_open_specialize
        elseIf (consume('=')) return TokenType.symbol_le
        elseIf (consume('>')) return TokenType.symbol_compare
        else                  return TokenType.symbol_lt
        }#

      elseIf (ch == '=' )
        if (consume('='))     return TokenType.SYMBOL_EQ
        elseIf (consume('>')) return TokenType.SYMBOL_FAT_ARROW
        else                  return TokenType.SYMBOL_EQUALS

        #{
      elseIf (ch == '>' )
        if      (consume('=')) return TokenType.symbol_ge
        elseIf  (consume('>')) return TokenType.symbol_close_specialize
        else                   return TokenType.symbol_gt

      elseIf (ch == '?')
        return TokenType.symbol_question_mark

      elseIf (ch == '@' )
        return TokenType.symbol_at

      elseIf (ch == '[')
        if (consume(']')) return TokenType.symbol_empty_brackets
        return TokenType.symbol_open_bracket

      elseIf (ch == '\\')
        return TokenType.symbol_backslash

      elseIf (ch == ']')
        return TokenType.symbol_close_bracket

      elseIf (ch == '^')
        if     (consume('=')) return TokenType.symbol_caret_equals
        else                  return TokenType.symbol_caret

      elseIf (ch == '{')
        if (consume('}')) return TokenType.symbol_empty_braces
        return TokenType.symbol_open_brace

      elseIf (ch == '|' )
        if     (consume('|')) throw error( "Use 'or' instead of '||'." )
        elseIf (consume('=')) return TokenType.symbol_vertical_bar_equals
        else                  return TokenType.symbol_vertical_bar

      elseIf (ch == '}' )
        if     (consume('#')) return TokenType.symbol_close_comment # used for error reporting
        else                  return TokenType.symbol_close_brace

      elseIf (ch == '~')
        if     (consume('=')) return TokenType.symbol_tilde_equals
        else                  return TokenType.symbol_tilde
      }#

      else
        throw error( "Unexpected character '"+ch+"'." )
      endIf
endClass

class CmdBuilder : ListRebuilder<<Cmd>>
endClass

class Cmd
  PROPERTIES
    t : Token

  METHODS
    method init( t )

    method execute( task:Task )->Logical
      throw t.error( "No execute() defined for $." (type_name) )

    method resolve( task:Task, builder:CmdBuilder )
      builder.write( this )
endClass

class CmdHalt : Cmd
  METHODS
    method execute( task:Task )->Logical
      task.status = TaskStatus.FINISHED
      --task.frame.ip  # stay at the HALT
      return false
endClass

class CmdLiteralInteger : Cmd
  PROPERTIES
    value : Int32

  METHODS
    method init( t, value )

    method execute( task:Task )->Logical
      task.push( IntegerValue(value) )
      return true
endClass

class CmdLiteralReal : Cmd
  PROPERTIES
    value : Real64

  METHODS
    method init( t, value )

    method execute( task:Task )->Logical
      task.push( RealValue(value) )
      return true
endClass

class CmdLiteralNull : Cmd
  METHODS
    method execute( task:Task )->Logical
      task.push( NullValue() )
      return true
endClass

class CmdLiteralString : Cmd
  PROPERTIES
    value : String

  METHODS
    method init( t, value )

    method execute( task:Task )->Logical
    task.push( StringValue(value) )
      return true
endClass

class CmdReadThis : Cmd
  METHODS
    method execute( task:Task )->Logical
      task.push( task.arg(0) )
      return true
endClass

class CmdReadGlobalContext : Cmd
  METHODS
    method execute( task:Task )->Logical
      task.push( task.arg(0) )
      return true
endClass

class CmdAdd : Cmd
  PROPERTIES

  METHODS
    method execute( task:Task )->Logical
      local b = task.pop
      local a = task.pop
      task.push( a + b )
      return true
endClass

class CmdMultiply : Cmd
  PROPERTIES

  METHODS
    method execute( task:Task )->Logical
      local b = task.pop
      local a = task.pop
      task.push( a * b )
      return true
endClass

class CmdAccess : Cmd
  PROPERTIES
    name      : String
    arg_count : Int32

  METHODS
    method init( t, name, arg_count )

    method resolve( task:Task, builder:CmdBuilder )
      local m_id = task.vm.name_to_id( name )
      contingent
        necessary (m_id < task.vm.global_dispatch.count)
        local m = task.vm.global_dispatch[ m_id ]
        necessary (m)
        CmdGlobalNativeCall(t, m, arg_count).resolve( task, builder )
      unsatisfied
        throw t.error( ''No such type, method, or variable "$".'' (name) )
      endContingent
endClass

class CmdGlobalNativeCall : Cmd
  PROPERTIES
    method_info : Method
    arg_count   : Int32

  METHODS
    method init( t, method_info, arg_count )

    method execute( task:Task )->Logical
      task.push_native_frame( arg_count )
      task.ensure_arg_count( method_info.min_param_count )

      method_info.fn( task )
      return (task.status == TaskStatus.RUNNING)
endClass

class CmdContextAccess : Cmd
  PROPERTIES
    name      : String
    m_id      : Int32
    arg_count : Int32

  METHODS
    method init( t, name, arg_count )

    method resolve( task:Task, builder:CmdBuilder )
      m_id = task.vm.name_to_id( name )
      builder.write( this )

    method execute( task:Task )->Logical
      task.push_generic_frame( arg_count )

      local context_id = task.arg(0).id
      if (context_id < task.vm.context_dispatch.count)
        local m = task.vm.context_dispatch[ context_id ][ m_id ]
        if (m)
          task.ensure_arg_count( m.min_param_count )
          if (m.fn)
            task.frame.commands = task.vm.native_return
            m.fn( task )
            return (task.status == TaskStatus.RUNNING)
          endIf
        endIf
      endIf

      # Error - push a null result and continue
      task.push( null )
      task.pop_frame
      return true
endClass

class CmdPopFrame : Cmd
  PROPERTIES
    arg_count   : Int32

  METHODS
    method init( t )

    method execute( task:Task )->Logical
      task.pop_frame
      return true
endClass

class CmdDeclareLocal : Cmd
  PROPERTIES
    index             : Int32
    has_initial_value : Logical

  METHODS
    method init( t, index )

    method execute( task:Task )->Logical
      if (has_initial_value) task.frame.create_local( index, task.pop )
      else                   task.frame.create_local( index, NullValue() )
      return true
endClass

class CmdReadLocal : Cmd
  PROPERTIES
    index             : Int32

  METHODS
    method init( t, index )

    method execute( task:Task )->Logical
      task.push( task.frame.locals[index] )
      return true
endClass

