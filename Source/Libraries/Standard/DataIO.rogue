#==============================================================================
# DataIO.rogue
#==============================================================================

class DataReader : Reader<<Byte>>
  PROPERTIES
    source : Reader<<Byte>>

  METHODS
    method init

    method init( source )

    method init( file:File )
      init( file.reader )

    method init( list:Byte[] )
      init( list.reader )

    method has_another->Logical
      return source.has_another

    method position->Int32
      return source.position

    method peek->Byte
      if (not source.has_another) return 0
      return source.peek

    method read->Byte
      if (not source.has_another) return 0
      return source.read

    method read_real64->Real64
      return read_int64.real_bits

    method read_real32->Real32
      return read_int32.real_bits

    method read_int64->Int64
      local result = read_int32 : Int64
      return (result :<<: 32) | read_int32->Int64(&unsigned)

    method read_int64x->Int64
      # Reads a variable-length encoded value that is stored in 1..9 bytes.
      # Encoded values are treated as signed.
      #
      # - If the first two bits are not "10" then the first byte is cast to
      #   a signed integer value and returned. This allows for the range
      #   -64..127 using the following bit patterns:
      #
      #     0xxxxxxx    0 .. 127
      #     11xxxxxx  -64 ..  -1
      #
      # - If the first two bits are "10", then the next 3 bits + 1 are the
      #   number of following bytes. The final 3 bits of the first byte
      #   are the most significant 3 bits of the encoded value. This results
      #   in the following bit patterns and ranges:
      #
      #     10000xxx xxxxxxxx*1  (11-bit signed data,                 -400 ..                 3FF)
      #     10001xxx xxxxxxxx*2  (19-bit signed data,               -40000 ..               3FFFF)
      #     10010xxx xxxxxxxx*3  (27-bit signed data,             -4000000 ..             3FFFFFF)
      #     10011xxx xxxxxxxx*4  (35-bit signed data,          -4_00000000 ..          3_FFFFFFFF)
      #     10100xxx xxxxxxxx*5  (43-bit signed data,        -400_00000000 ..        3FF_FFFFFFFF)
      #     10101xxx xxxxxxxx*6  (51-bit signed data,      -40000_00000000 ..      3FFFF_FFFFFFFF)
      #     10110xxx xxxxxxxx*7  (59-bit signed data,    -4000000_00000000 ..    3FFFFFF_FFFFFFFF)
      #     10111xxx xxxxxxxx*8  (67-bit signed data, -4_00000000_00000000 .. 3_FFFFFFFF_FFFFFFFF)
      #
      # - The upper 3 bits of the 67-bit value are not intended to contain meaningful information,
      #   but they reflect the negative or non-negative value of the overall number with 111 or 000
      #   so that a general encoding and decoding alogorithm can be used.
      local b = read : Int32
      if ((b & 0xc0) != 0x80) return b->Byte.signed

      local n = ((b:>>>:3) & 0b111) + 1
      local result = (b & 0b111) : Int64   #  0..7 (unsigned)
      if (result >= 4) result -= 8         # -4..3 (signed)

      loop (n) result = (result :<<: 8) | read

      return result

    method read_int32->Int32
      local result = read : Int32
      result = (result:<<:8) | read
      result = (result:<<:8) | read
      return (result:<<:8) | read

    method read_int32x->Int32
      return read_int64x->Int32

    method read_byte->Byte [macro]
      return this.read

    method read_logical->Logical
      return (read != 0)

    method read_string->String
      return read_string( StringBuilder() )->String

    method read_string( buffer:StringBuilder )->StringBuilder
      local count = read_int32x
      forEach (1..count)
        local ch = read_int32x
        buffer.print( ch->Character )
      endForEach
      return buffer

    method reset->this
      source.reset
      return this

    method seek( pos:Int32 )->this
      source.seek( pos )
      return this

    method skip( n:Int32 )->this
      source.skip( n )
      return this

endClass

class BufferedDataReader : DataReader
  PROPERTIES
    buffer : Byte[]

  METHODS
    method init
      buffer = Byte[]
      prior.init( buffer )

    method init( buffer )
      prior.init( buffer )
endClass

class DataWriter : Writer<<Byte>>
  PROPERTIES
    output : Writer<<Byte>>

  METHODS
    method init( output )

    method init( file:File )
      init( file.writer )

    method init( list:Byte[] )
      init( list.writer )

    method close->this
      output.close
      return this

    method flush->this
      output.flush
      return this

    method position->Int32
      return output.position

    method reset->this
      output.reset
      return this

    method seek( pos:Int32 )->this
      output.seek( pos )
      return this

    method seek_end()->this
      output.seek_end
      return this

    method skip( n:Int32 )->this
      output.skip( n )
      return this

    method write( value:Byte )->this
      output.write( value )
      return this

    method write_real64( value:Real64 )->this
      return write_int64( value.integer_bits )

    method write_real32( value:Real32 )->this
      return write_int32( value.integer_bits )

    method write_int64( value:Int64 )->this
      write_int32( value:>>>:32 )
      return write_int32( value )

    method write_int64x( value:Int64 )->this
      # Writes 'value' in 1..9 bytes using a variable-length encoding scheme.
      # Encoded values are treated as signed.
      #
      # - Values -64..127 are written as-is using a single byte. The first two bits
      #   will not be "10":
      #
      #     0xxxxxxx    0 .. 127
      #     11xxxxxx  -64 ..  -1
      #
      # - Otherwise a header byte is written in the form "10nnnxxx", where (nnn+1)
      #   indicates the following number of bytes 1..8 and "xxx" is the most
      #   significant 3 bits of the encoded value. This results in the following
      #   bit patterns and ranges:
      #
      #     10000xxx xxxxxxxx*1  (11-bit signed data,                 -400 ..                 3FF)
      #     10001xxx xxxxxxxx*2  (19-bit signed data,               -40000 ..               3FFFF)
      #     10010xxx xxxxxxxx*3  (27-bit signed data,             -4000000 ..             3FFFFFF)
      #     10011xxx xxxxxxxx*4  (35-bit signed data,          -4_00000000 ..          3_FFFFFFFF)
      #     10100xxx xxxxxxxx*5  (43-bit signed data,        -400_00000000 ..        3FF_FFFFFFFF)
      #     10101xxx xxxxxxxx*6  (51-bit signed data,      -40000_00000000 ..      3FFFF_FFFFFFFF)
      #     10110xxx xxxxxxxx*7  (59-bit signed data,    -4000000_00000000 ..    3FFFFFF_FFFFFFFF)
      #     10111xxx xxxxxxxx*8  (67-bit signed data, -4_00000000_00000000 .. 3_FFFFFFFF_FFFFFFFF)
      #
      # - The upper 3 bits of the 67-bit value are not intended to contain meaningful information,
      #   but they reflect the negative or non-negative value of the overall number with 111 or 000
      #   so that a general encoding and decoding alogorithm can be used.
      if (value >= -64 and value < 128)
        return write( value )
      else
        local extra_bytes = 1
        local shift = 8
        local min = -0x400
        local max =  0x3FF
        loop 7
          if (value >= min and value <= max) escapeLoop
          ++extra_bytes
          shift += 8
          min = min :<<: 8
          max = (max :<<: 8) | 0xFF
        endLoop
        write( 0b10_000_000 | ((extra_bytes-1):<<:3) | ((value:>>>:shift)&0b111) )
        loop extra_bytes
          shift -= 8
          write( (value:>>>:shift) & 0xFF )
        endLoop
      endIf
      return this

    method write_int32( value:Int32 )->this
      write( value:>>>:24 )
      write( value:>>>:16 )
      write( value:>>>:8 )
      return write( value )

    method write_int32x( value:Int32 )->this
      return write_int64x( value->Int64 )

    method write_byte( value:Byte )->this [macro]
      return this.write( value )

    method write_logical( value:Logical )->this
      if (value) return write( 1 )
      else       return write( 0 )

    method write_string( value:String )->this
      if (not value) value = ""
      write_int32x( value.count )
      forEach (ch in value) write_int32x( ch )
      return this
endClass

class BufferedDataWriter : DataWriter
  PROPERTIES
    buffer : Byte[]

  METHODS
    method init
      buffer = Byte[]
      prior.init( buffer )

    method init( buffer )
      prior.init( buffer )

    method clear->BufferedDataWriter
      buffer.clear
      output.reset
      return this

    method write( list:Byte[] )->this
      buffer.reserve( list.count ).data.set( position, list.data, 0, list.count )
      skip( list.count )
      return this
endClass

