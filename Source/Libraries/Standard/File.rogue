class File
  ROUTINES
    routine absolute_filepath( filepath:String )->String
      native @|if ( !$filepath ) return 0;
              |
              |char c_filepath[ PATH_MAX ];
              |$filepath->to_c_string( c_filepath, PATH_MAX );
              |
              |#if defined(_WIN32)
              |{
              |  char long_name[PATH_MAX+4];
              |  char full_name[PATH_MAX+4];
              |
              |  if (GetLongPathName(c_filepath, long_name, PATH_MAX+4) == 0)
              |  {
              |    strcpy_s( long_name, PATH_MAX+4, c_filepath );
              |  }
              |
              |  if (GetFullPathName(long_name, PATH_MAX+4, full_name, 0) == 0)
              |  {
              |    // bail with name unchanged 
              |    return $filepath;
              |  }
              |
              |  return RogueString::create( full_name );
              |}
              |#else
              |
              |bool is_folder = RogueFile__is_folder( $filepath );
              |
              |{
              |  int original_dir_fd;
              |  int new_dir_fd;
              |  char filename[PATH_MAX];
              |
              |  // A way to get back to the starting folder when finished.
              |  original_dir_fd = open( ".", O_RDONLY );  
              |
              |  if (is_folder)
              |  {
              |    filename[0] = 0;
              |  }
              |  else
              |  {
              |    // fchdir only works with a path, not a path+filename (c_filepath).
              |    // Copy out the filename and null terminate the filepath to be just a path.
              |    int i = (int) strlen( c_filepath ) - 1;
              |    while (i >= 0 && c_filepath[i] != '/') --i;
              |    strcpy( filename, c_filepath+i+1 );
              |    c_filepath[i] = 0;
              |  }
              |  new_dir_fd = open( c_filepath, O_RDONLY );
              |
              |  if (original_dir_fd >= 0 && new_dir_fd >= 0)
              |  {
              |    fchdir( new_dir_fd );
              |    getcwd( c_filepath, PATH_MAX );
              |    if ( !is_folder ) 
              |    {
              |      strcat( c_filepath, "/" );
              |      strcat( c_filepath, filename );
              |    }
              |    fchdir( original_dir_fd );
              |  }
              |  if (original_dir_fd >= 0) close( original_dir_fd );
              |  if (new_dir_fd >= 0) close( new_dir_fd );
              |
              |  return RogueString::create( c_filepath );
              |}
              |#endif

    routine exists( filepath:String )->Logical
      native @|if ( !$filepath ) return false;
              |
              |char c_filepath[ PATH_MAX ];
              |$filepath->to_c_string( c_filepath, PATH_MAX );
              |
              |FILE* fp = fopen( c_filepath, "rb" );
              |if ( !fp ) return false;
              |
              |fclose( fp );
              |return true;

    routine filename( filepath:String )->String
      local i = filepath.locate_last( '/' )
      if (not i?) i = filepath.locate_last( '\\' )
      if (not i?) return filepath
      return filepath.from( i.value+1 )

    routine is_folder( filepath:String )->Logical
      native @|if ( !$filepath ) return false;
              |
              |char c_filepath[ PATH_MAX ];
              |$filepath->to_c_string( c_filepath, PATH_MAX );
              |
              |#if defined(_WIN32)
              |  char filepath_copy[PATH_MAX];
              |  strcpy( filepath_copy, c_filepath );
              |
              |  int path_len = strlen( c_filepath );
              |  int i = strlen(filepath_copy)-1;
              |  while (i > 0 && (filepath_copy[i] == '/' || filepath_copy[i] == '\\')) filepath_copy[i--] = 0;
              |
              |  // Windows allows dir\* to count as a directory; guard against.
              |  for (i=0; filepath_copy[i]; ++i)
              |  {
              |    if (filepath_copy[i] == '*' || filepath_copy[i] == '?') return 0;
              |  }
              |
              |  WIN32_FIND_DATA entry;
              |  HANDLE dir = FindFirstFile( filepath_copy, &entry );
              |  if (dir != INVALID_HANDLE_VALUE)
              |  {
              |    if (entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
              |    {
              |      FindClose( dir );
              |      return 1;
              |    }
              |  }
              |  FindClose( dir );
              |  return 0;
              |
              |#else
              |  DIR* dir = opendir( c_filepath );
              |  if ( !dir ) return 0;
              |
              |  closedir( dir );
              |  return 1;
              |#endif

    routine load_as_bytes( filepath:String )->Byte[]
      local count = size( filepath )
      local bytes = Byte[]( count )
      local infile = reader( filepath )
      forEach (1..count) bytes.add( infile.read )
      infile.close
      return bytes

    routine load_as_string( filepath:String )->String
      local count = size( filepath )
      local buffer = StringBuilder( count )
      local infile = reader( filepath )
      forEach (1..count) buffer.print( infile.read )
      infile.close
      return buffer->String

    routine path( filepath:String )->String
      local i = filepath.locate_last( '/' )
      if (not i?) i = filepath.locate_last( '\\' )
      if (not i?) return ""
      return filepath.from( 0, i!-1 )

    routine reader( filepath:String )->FileReader
      return FileReader( filepath )

    routine save( filepath:String, data:String )->Logical
      local outfile = writer( filepath )
      forEach (ch in data) outfile.write( ch )
      outfile.close
      return true

    routine size( filepath:String )->Integer
      native @|if ( !$filepath ) return 0;
              |
              |char c_filepath[ PATH_MAX ];
              |$filepath->to_c_string( c_filepath, sizeof(c_filepath) );
              |
              |FILE* fp = fopen( c_filepath, "rb" );
              |if ( !fp ) return 0;
              |
              |fseek( fp, 0, SEEK_END );
              |RogueInteger size = (RogueInteger) ftell( fp );
              |fclose( fp );
              |
              |return size;

    routine writer( filepath:String )->FileWriter
      return FileWriter( filepath )

  PROPERTIES
    filepath : String

  METHODS
    method init( filepath )

    method absolute_filepath->String
      inline File.absolute_filepath( this.filepath )

    method exists->Logical
      inline File.exists( this.filepath )

    method filename->String
      return filename( filepath )

    method is_folder->Logical
      inline File.is_folder( this.filepath )

    method load_as_bytes->Byte[]
      inline File.load_as_bytes( this.filepath )

    method load_as_string->String
      inline File.load_as_string( this.filepath )

    method path->String
      inline File.path( this.filepath )

    method reader->FileReader
      inline File.reader( this.filepath )

    method save( data:String )->Logical
      inline File.save( this.filepath, data )

    method size->Integer
      inline File.size( this.filepath )

    method writer->FileWriter
      inline File.writer( this.filepath )

    method to->String
      return filepath
endClass

class FileReader : Reader<<Character>>
  PROPERTIES
    filepath        : String
    buffer_count    : Integer
    buffer_position : Integer
    count           : Integer
    position        : Integer
    native "FILE* fp;"
    native "unsigned char buffer[1024];"

  METHODS
    method init( _filepath:String )
      open( _filepath )

    method close->this
      native @|if ($this->fp)
              |{
              |  fclose( $this->fp );
              |  $this->fp = 0;
              |}

      position = 0
      count = 0
      return this

    method has_another->Logical
      return (position < count)

    method open( filepath )->Logical
      close

      native @|char path[ PATH_MAX ];
              |$filepath->to_c_string( path, PATH_MAX );
              |
              |$this->fp = fopen( path, "rb" );
              |if ($this->fp)
              |{
              |  fseek( $this->fp, 0, SEEK_END );
              |  $count = (RogueInteger) ftell( $this->fp );
              |  fseek( $this->fp, 0, SEEK_SET );
              |}

      # Always close after the last byte is read
      if (count == 0) close
      
      return (position < count)

    method peek->Character
      if (position == count) return 0

      if (buffer_position == buffer_count)
        native @|$buffer_count = (RogueInteger) fread( $this->buffer, 1, sizeof($this->buffer), $this->fp );
        buffer_position = 0
      endIf

      native @|return $this->buffer[ $buffer_position ];

    method read->Character
      if (position == count) return 0

      local result = peek

      ++position
      ++buffer_position
      if (position == count) close

      return result

    method remaining->Integer
      return count - position

    method set_position( @position )->this
      native @|if ($this->fp)
              |{
              |  fseek( $this->fp, $position, SEEK_SET );
              |}

      buffer_position = 0
      buffer_count = 0
      return this
endClass


class FileWriter
  PROPERTIES
    filepath        : String
    buffer_position : Integer
    count           : Integer
    native "FILE* fp;"
    native "unsigned char buffer[1024];"

  METHODS
    method init( _filepath:String )
      open( _filepath )

    method close->FileWriter
      flush

      native @|if ($this->fp)
              |{
              |  fclose( $this->fp );
              |  $this->fp = 0;
              |}

      return this

    method flush->FileWriter
      native @|if ( !$buffer_position || !$this->fp ) return $this;
              |
              |fwrite( $this->buffer, 1, $buffer_position, $this->fp );

      buffer_position = 0
      return this

    method open( filepath )->Logical
      close

      native @|char path[ PATH_MAX ];
              |$filepath->to_c_string( path, PATH_MAX );
              |$this->fp = fopen( path, "wb" );
              |
              |return !!$this->fp;

    method write( ch:Character )->this
      native @|if ( !$this->fp ) return 0;
              |
              |$this->buffer[ $buffer_position ] = (unsigned char) $ch;

      ++buffer_position
      if (buffer_position == 1024) return flush

      return this
endClass


