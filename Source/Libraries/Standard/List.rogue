class GenericList
endClass

class List<<$DataType>> : GenericList
  PROPERTIES
    data      : Array<<$DataType>>
    count     : Int32

  METHODS
    method init
      init( 10 )

    method init( initial_capacity:Int32 )
      data = Array<<$DataType>>( initial_capacity )

    method init( initial_capacity:Int32, initial_value:$DataType )
      data = Array<<$DataType>>( initial_capacity )
      forEach (i in 1..initial_capacity) add( initial_value )

    method apply( fn:Function($DataType) )->this
      forEach (item in this) fn( item )
      return this

    method clone->$DataType[]
      local result = $DataType[]( count )
      forEach (value in this)
        result.add( value )
      endForEach
      return result

    method add( value:$DataType )->$DataType[]
      reserve(1)[count] = value
      ++count
      return this

    method add( other:$DataType[] )->$DataType[]
      reserve(other.count)
      forEach (value in other) add( value )
      return this

    method capacity->Int32
      if (not data) return 0
      return data.count

    method clear->$DataType[]
      count = 0
      return this

    method contains( value:$DataType )->Logical [macro]
      this.locate( value )?

    method ensure_capacity( desired_capacity:Int32 )->this
      return reserve( desired_capacity - count )

    method expand_to_count( minimum_count:Int32 )->this
      # Expands the list if necessary to have at least 'minimum_count' elements.
      if (count < minimum_count)
        ensure_capacity( minimum_count )
        count = minimum_count
      endIf
      return this

    method expand_to_include( index:Int32 )->this
      # Expands the list if necessary to include the specified index.
      return expand_to_count( index + 1 )

    method first->$DataType [macro]
      this.data[0]

    method from( i1:Int32 )->ListReader<<$DataType>>
      return ListReader<<$DataType>>( this, i1 )

    method from( i1:Int32, i2:Int32 )->ListReader<<$DataType>>
      return ListReader<<$DataType>>( this, i1, i2 )

    method discard( i1:Int32, n=1:Int32 )
      local i2 = i1 + n
      data.set( i1, data, i2, (count-i2) )
      discard_from( count-n )

    method discard_from( index:Int32 )
      local zero_value : $DataType
      local c = count
      while (c > index)
        --c
        data[c] = zero_value
      endWhile
      count = c

    method filter( fn:Function($DataType)->Logical )->this
      local write_pos = 0
      forEach (i of this)
        local value = this[i]
        if (fn(value)) this[write_pos] = value; ++write_pos
      endForEach
      discard_from( write_pos )
      return this

    method get( index:Int32 )->$DataType [macro]
      this.data[index]

    method heapsort( compare_fn:Function($DataType,$DataType)->Logical )->this [macro]
      Heapsort<<$DataType>>.sort( this, compare_fn )

    method insert( value:$DataType, before_index=0:Int32 )->this
      if (before_index < 0) before_index = 0

      if (before_index >= count)
        return add( value )
      else
        reserve( 1 )

        # Shift everything over
        data.set( before_index+1, data, before_index, (count-before_index) )
        ++count

        # Copy in the new value
        data[ before_index ] = value
      endIf
      return this

    method insert( other:$DataType[], before_index=0:Int32 )->this
      if (before_index < 0) before_index = 0
      if (other.count == 0) return this

      if (before_index >= count)
        return add( other )
      else
        reserve( other.count )

        # Shift everything over
        data.set( before_index+other.count, data, before_index, (count-before_index) )
        count += other.count

        # Copy in the new values
        forEach (value in other.data)
          data[ before_index ] = value
          ++before_index
        endForEach
      endIf
      return this

    method insertion_sort( compare_fn:Function($DataType,$DataType)->Logical )->this [macro]
      InsertionSort<<$DataType>>.sort( this, compare_fn )

    method last->$DataType
      return this.data[ count - 1 ]

    method locate( value:$DataType )->Int32?
      forEach (i of this)
        if (value == this[i]) return i
      endForEach
      return null

    method locate_last( value:$DataType )->Int32?
      forEach (i of this step -1)
        if (value == this[i]) return i
      endForEach
      return null

    method modify( fn:Function($DataType)->$DataType )->this
      forEach (index of this) this[index] = fn(this[index])
      return this

    method permutation( n:Int64, output_list=null:$DataType[] )->$DataType[]
      # n           - A value between 0 and (permutation_count-1).  0 gives the
      #               original list and (permutation_count-1) gives the list in
      #               reverse order.
      # output_list - A optional existing list to store the output permutation in.
      #               Will be created dynamically if not passed in.
      if (not output_list) output_list = $DataType[]( count )
      output_list.clear
      if (count == 0) return output_list

      forEach (value in this) output_list.add( value )

      local c = count
      while (c)
        output_list.add( output_list.remove_at(n % c) )
        n /= c
        --c
      endWhile

      return output_list

    method permutation_count->Int64
      # The permutation count is the factorial of the list size
      if (count == 0) return 0

      local c = 1 : Int64
      forEach (n in 2..count)
        c *= n
      endForEach

      return c

    method quicksort( compare_fn:Function($DataType,$DataType)->Logical )->this [macro]
      Quicksort<<$DataType>>.sort( this, compare_fn )

    method random->$DataType
      # Returns an element at random
      local default_value : $DataType
      if (not count) return default_value

      return this[ Random.next_int32(this.count) ]

    method reader->ListReader<<$DataType>>
      return ListReader<<$DataType>>( this, 0 )

    method rebuilder->ListRebuilder<<$DataType>>
      return ListRebuilder<<$DataType>>( this )

    method reserve( additional_count:Int32 )->$DataType[]
      local required_capacity = count + additional_count

      if (not data)
        data = Array<<$DataType>>( 10 )
      elseIf (required_capacity > data.count)
        local x2 = capacity + capacity
        if (required_capacity < x2) required_capacity = x2 
        local new_data = Array<<$DataType>>( required_capacity )
        new_data.set( 0, data )
        data = new_data
      endIf

      return this

    method remove( value:$DataType )->$DataType
      local index = locate( value )
      if (index)
        return remove_at( index! )
      else
        local zero_value : $DataType
        return zero_value
      endIf

    method remove_at( index:Int32 )->$DataType
      local result = this[ index ]
      data.set( index, data, index+1 )
      local zero_value : $DataType
      data[count] = zero_value
      --count
      return result

    method remove_first->$DataType [macro]
      this.remove_at(0)

    method remove_last->$DataType
      return remove_at( count - 1 )

    method reverse->this
      return reverse( 0, count-1 )

    method reverse( i1:Int32, i2:Int32 )->this
      if (i1 < 0) i1 = 0
      if (i2 >= count) i2 = count - 1

      local _data = data
      while (i1 < i2)
        local temp = _data[i1]
        _data[i1] = _data[i2]
        _data[i2] = temp
        ++i1
        --i2
      endWhile

      return this

    method set( index:Int32, new_value:$DataType ) [macro]
      this.data[ index ] = new_value

    method shift( i1=0:Int32, element_count=null:Int32?, delta=0:Int32, fill=null:$DataType? )->this 
      if (delta == 0) return this

      local n : Int32
      if (element_count.exists) n = element_count.value
      else                      n = count - i1

      local dest_i2 = (i1 + delta + n) - 1
      expand_to_include( dest_i2 )
      data.set( i1+delta, data, i1, n )
      if (fill.exists)
        local value = fill.value
        if (delta > 0)
          forEach (i in i1..i1+delta-1) data[i] = value
        else
          forEach (i in i1+delta+n..i1+n-1) data[i] = value
        endIf
      endIf
      return this

    method shuffle->this
      local n = count
      forEach (i of this) swap( i, Random.next_int32(n) )
      return this

    method shuffled->$DataType[]
      return clone.shuffle

    method sort( compare_fn:Function($DataType,$DataType)->Logical )->this [macro]
      this.quicksort( compare_fn )

    method swap( i1:Int32, i2:Int32 )->this
      local temp = data[i1]
      data[i1] = data[i2]
      data[i2] = temp
      return this

    method to->String
      local buffer = StringBuilder()
      buffer.print( '[' )
      local first = true
      forEach (value in this)
        if (first) first = false
        else       buffer.print( ',' )
        if (value is null) buffer.print( "null" )
        else               buffer.print( value->String )
      endForEach
      buffer.print( ']' )
      return buffer

    method to_array->Array<<$DataType>>
      local result = Array<<$DataType>>( count )
      forEach (i of this)
        result[i] = this[i]
      endForEach
      return result

    method writer->ListWriter<<$DataType>>
      return ListWriter<<$DataType>>( this )
endClass

class ListReader<<$DataType>> : Reader<<$DataType>>
  PROPERTIES
    list       : $DataType[]
    position   : Int32
    limit      : Int32
    is_limited : Logical

  METHODS
    method init( list, position=0 )

    method init( list, position, limit )
      is_limited = true

    method has_another->Logical
      if (is_limited) return (position < limit)
      else            return (position < list.count)

    method peek->$DataType
      return list[ position ]

    method read->$DataType
      ++position
      return list[ position - 1 ]

    method reset->this
      position = 0
      if (is_limited) limit = list.count
      return this

    method seek( pos:Int32 )->this
      if (pos < 0) pos = 0

      if (is_limited)
        if (pos > limit) pos = limit
      else
        if (pos > list.count) pos = list.count
      endIf

      position = pos
      return this

endClass

class ListWriter<<$DataType>> : Writer<<$DataType>>
  PROPERTIES
    list     : $DataType[]
    position : Int32

  METHODS
    method init( list )
      position = list.count

    method close->this
      list.discard_from( position )
      return this

    method seek( pos:Int32 )->this
      if (pos < 0) pos = 0
      position = pos
      list.expand_to_count( pos )
      return this

    method seek_end()->this
      position = list.count
      return this

    method write( value:$DataType )->this
      if (position == list.count) list.add( value )
      else                        list[ position ] = value
      ++position
      return this
endClass

augment String[]
  METHODS
    method joined( separator="\n":String )->String
      local total_count = 0
      forEach (line in this) total_count += line.count

      local builder = StringBuilder( total_count )
      forEach (line in this)
        if (builder.count) builder.print( separator )
        builder.print( line )
      endForEach

      return builder->String
endAugment

class ListMap<<$FromType,$ToType>>
  GLOBAL METHODS
    method convert( list:$FromType[], map_fn:Function($FromType)->$ToType )->$ToType[]
      local result = $ToType[]( list.capacity )
      forEach (element in list) result.add( map_fn(element) )
      return result
endClass

class ListReduce<<$FromType,$ToType>>
  GLOBAL METHODS
    method convert( list:$FromType[], reduce_fn:Function(Int32,$FromType,$ToType)->$ToType )->$ToType
      local result : $ToType
      forEach (index of list)
        result = reduce_fn( index, list[index], result )
      endForEach
      return result
endClass

class ListRebuilder<<$DataType>>
  PROPERTIES
    list        : $DataType[]
    read_index  : Int32
    write_index : Int32

  METHODS
    method init( list )

    method has_another->Logical
      if (read_index < list.count)
        return true
      else
        # automatically finish up
        list.discard_from( write_index )
        return false
      endIf

      return (read_index < list.count)

    method peek( lookahead=0:Int32 )->$DataType
      return list[ read_index + lookahead ]

    method read->$DataType
      ++read_index
      return list[ read_index - 1 ]

    method reset( new_list=null:$DataType[] )->this
      if (new_list) list = new_list  # else use same as before
      read_index = 0
      write_index = 0
      return this

    method write( value:$DataType )->this
      if (write_index == read_index)
        # We're adding more items to the list then it originally had.

        # Make sure there's at least one more spot
        list.reserve( 1 )

        local unread_count = list.count - read_index

        # Shift all the unread elements over to the end of the backing array,
        # effectively inserting 1 or more empty spots for us to write
        # additional data to.
        list.data.set( list.capacity-unread_count, list.data, read_index, unread_count )

        read_index += (list.capacity - list.count)

        # Change the list count to include the shifted data
        list.count = list.capacity
      endIf

      list[ write_index ] = value
      ++write_index

      return this
endClass

