class GenericList
endClass

class List<<$DataType>> : GenericList
  PROPERTIES
    data  : Array<<$DataType>>
    count : Integer

  METHODS
    method init
      init( 10 )

    method init( initial_capacity:Integer )
      data = Array<<$DataType>>( initial_capacity )

    method init( initial_capacity:Integer, initial_value:$DataType )
      data = Array<<$DataType>>( initial_capacity )
      forEach (i in 1..initial_capacity) add( initial_value )

    method clone->$DataType[]
      local result = $DataType[]( count )
      forEach (value in this)
        result.add( value )
      endForEach
      return result

    method add( value:$DataType )->$DataType[]
      reserve(1)[count] = value
      ++count
      return this

    method add( other:$DataType[] )->$DataType[]
      reserve(other.count)
      forEach (value in other) add( value )
      return this

    method capacity->Integer
      if (not data) return 0
      return data.count

    method clear->$DataType[]
      count = 0
      return this

    method contains( value:$DataType )->Logical
      macro this.locate( value )?

    method first->$DataType
      macro this.data[0]

    method discard_from( index:Integer )
      local zero_value : $DataType
      local c = count
      while (c > index)
        --c
        data[c] = zero_value
      endWhile
      count = c

    method get( index:Integer )->$DataType
      macro this.data[index]

    method insert( value:$DataType, before_index=0:Integer )->this
      if (before_index < 0) before_index = 0

      if (before_index >= count)
        return add( value )
      else
        # Create a dummy spot at the end to size the array and update the count
        add( first )

        # Shift everything over
        data.set( before_index+1, data, before_index, count-2 )

        # Copy in the new value
        data[ before_index ] = value
      endIf
      return this

    method insert( other:$DataType[], before_index=0:Integer )->this
      if (before_index < 0) before_index = 0
      if (other.count == 0) return this

      if (before_index >= count)
        return add( other )
      else
        # Create dummy spots at the end to size the array and update the count
        reserve( other.count )

        # Shift everything over
        data.set( before_index+other.count, data, before_index, count-1 )
        count += other.count

        # Copy in the new values
        forEach (value in other.data)
          data[ before_index ] = value
          ++before_index
        endForEach
      endIf
      return this

    method last->$DataType
      return this.data[ count - 1 ]

    method locate( value:$DataType )->Integer?
      forEach (i of this)
        if (value == this[i]) return i
      endForEach
      return null

    method locate_last( value:$DataType )->Integer?
      forEach (i of this step -1)
        if (value == this[i]) return i
      endForEach
      return null

    method random->$DataType
      # Returns an element at random
      local default_value : $DataType
      if (not count) return default_value

      return this[ Random.next_integer(this.count) ]

    method reserve( additional_count:Integer )->$DataType[]
      local required_capacity = count + additional_count

      if (not data)
        data = Array<<$DataType>>( 10 )
      elseIf (required_capacity > data.count)
        local x2 = capacity + capacity
        if (required_capacity < x2) required_capacity = x2 
        local new_data = Array<<$DataType>>( required_capacity )
        new_data.set( 0, data )
        data = new_data
      endIf

      return this

    method remove( value:$DataType )->$DataType
      local index = locate( value )
      if (index)
        return remove_at( index! )
      else
        local zero_value : $DataType
        return zero_value
      endIf

    method remove_at( index:Integer )->$DataType
      local result = this[ index ]
      data.set( index, data, index+1 )
      local zero_value : $DataType
      data[count] = zero_value
      --count
      return result

    method remove_first->$DataType
      macro this.remove_at(0)

    method remove_last->$DataType
      return remove_at( count - 1 )

    method reverse->this
      return reverse( 0, count-1 )

    method reverse( i1:Integer, i2:Integer )->this
      if (i1 < 0) i1 = 0
      if (i2 >= count) i2 = count - 1

      local _data = data
      while (i1 < i2)
        local temp = _data[i1]
        _data[i1] = _data[i2]
        _data[i2] = temp
        ++i1
        --i2
      endWhile

      return this

    method set( index:Integer, new_value:$DataType )->$DataType[]
      macro this.data[ index ] = new_value

    method to->String
      local buffer = StringBuilder()
      buffer.print( '[' )
      local first = true
      forEach (value in this)
        if (first) first = false
        else       buffer.print( ',' )
        if (value is null) buffer.print( "null" )
        else               buffer.print( value->String )
      endForEach
      buffer.print( ']' )
      return buffer
endClass

augment String[]
  METHODS
    method joined( separator="\n":String )->String
      local total_count = 0
      forEach (line in this) total_count += line.count

      local builder = StringBuilder( total_count )
      forEach (line in this)
        if (builder.count) builder.print( separator )
        builder.print( line )
      endForEach

      return builder->String
endAugment

