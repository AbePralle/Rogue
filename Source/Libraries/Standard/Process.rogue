$if target("WINDOWS")
  $warning "Process is currently unimplemented on Windows."
$else
class Process
  # Loosely based on:
  # https://stackoverflow.com/questions/13893085/posix-spawnp-and-piping-child-output-to-a-string/27328610
  DEPENDENCIES
    nativeHeader #include <spawn.h>
    nativeHeader #include <poll.h>
    nativeHeader #include <sys/wait.h>

  PROPERTIES
    args          : String[]
    output_reader : ProcessReader
    error_reader  : ProcessReader
    input_writer  : FDWriter
    error         : Logical
    is_finished   : Logical
    exit_code     : Int32
    is_blocking   : Logical

    native "pid_t pid;"
    native "int cin_pipe[2];"
    native "int cout_pipe[2];"
    native "int cerr_pipe[2];"
    native "posix_spawn_file_actions_t actions;"
    native "pollfd poll_list[2];"

  GLOBAL METHODS
    method run( cmd:String )->ProcessOutput
      local process = Process( cmd, &readable, &is_blocking )
      process.finish
      local output_bytes = Byte[]
      while (process.output_reader.has_another) output_bytes.add( process.output_reader.read )
      local error_bytes = Byte[]
      while (process.error_reader.has_another) error_bytes.add( process.error_reader.read )
      return ProcessOutput( process.exit_code, output_bytes, error_bytes )

  METHODS
    method init( cmd:String, &readable, &writable, &is_blocking )
      init( ["sh","-c",cmd], &=readable, &=writable, &=is_blocking )

    method init( args, &readable, &writable, is_blocking=false )
      if (not launch(readable,writable))
        native @|if ($this->cout_pipe[0] != -1) close( $this->cout_pipe[0] );
                |if ($this->cout_pipe[1] != -1) close( $this->cout_pipe[1] );
                |if ($this->cerr_pipe[0] != -1) close( $this->cerr_pipe[0] );
                |if ($this->cerr_pipe[1] != -1) close( $this->cerr_pipe[1] );
                |if ($this->cin_pipe[0] != -1)  close( $this->cin_pipe[0] );
                |if ($this->cin_pipe[1] != -1)  close( $this->cin_pipe[1] );
                |$this->cin_pipe[0]  = $this->cin_pipe[1]  = -1;
                |$this->cout_pipe[0] = $this->cout_pipe[1] = -1;
                |$this->cerr_pipe[0] = $this->cerr_pipe[1] = -1;
        if (readable)
          output_reader = ProcessReader( this, -1 )
          error_reader = ProcessReader( this, -1 )
        endIf
        if (writable) input_writer = FDWriter( -1 )
        error = true
        is_finished = true
        exit_code = -1
      endIf

    method launch( &readable, &writable )->Logical
      native @|$this->cin_pipe[0]  = $this->cin_pipe[1]  = -1;
              |$this->cout_pipe[0] = $this->cout_pipe[1] = -1;
              |$this->cerr_pipe[0] = $this->cerr_pipe[1] = -1;
              |
              |memset(&$this->poll_list, 0, sizeof($this->poll_list));
              |$this->poll_list[0].fd = -1;
              |$this->poll_list[1].fd = -1;
              |
              |if ($readable)
              |{
              |  if (0 != pipe($this->cout_pipe) || 0 != pipe($this->cerr_pipe)) return false;
              |}
              |
              |if ($writable)
              |{
              |  if (0 != pipe($this->cin_pipe)) return false;
              |}

      local n = args.count
      native @|char** args = new char*[ $n+1 ];
              |args[ $n ] = 0;
      forEach (arg at index in args)
        native @|args[ $index ] = (char*) $arg->utf8;
      endForEach

      native @|posix_spawn_file_actions_init( &$this->actions );

      if (readable)
        # These commands run in the forked process
        native @|  posix_spawn_file_actions_addclose( &$this->actions, $this->cout_pipe[0] );
                |  posix_spawn_file_actions_addclose( &$this->actions, $this->cerr_pipe[0] );
                |  posix_spawn_file_actions_adddup2( &$this->actions, $this->cout_pipe[1], STDOUT_FILENO );
                |  posix_spawn_file_actions_adddup2( &$this->actions, $this->cerr_pipe[1], STDERR_FILENO );
                |  posix_spawn_file_actions_addclose( &$this->actions, $this->cout_pipe[1] );
                |  posix_spawn_file_actions_addclose( &$this->actions, $this->cerr_pipe[1] );
                |  $this->poll_list[0].fd = $this->cout_pipe[0];
                |  $this->poll_list[1].fd = $this->cerr_pipe[0];
                |  $this->poll_list[0].events = POLLIN;
                |  $this->poll_list[1].events = POLLIN;
      endIf

      if (writable)
        # These commands run in the forked process
        native @|  posix_spawn_file_actions_addclose( &$this->actions, $this->cin_pipe[1] );
                |  posix_spawn_file_actions_adddup2( &$this->actions, $this->cin_pipe[0], STDIN_FILENO );
                |  posix_spawn_file_actions_addclose( &$this->actions, $this->cin_pipe[0] );
      else
        native @|  posix_spawn_file_actions_addclose( &$this->actions, STDIN_FILENO );
      endIf

      native @|int result = posix_spawnp( &$this->pid, args[0], &$this->actions, NULL, &args[0], NULL );
              |delete [] args;
              |if ($this->cout_pipe[1] != -1) close( $this->cout_pipe[1] );
              |if ($this->cerr_pipe[1] != -1) close( $this->cerr_pipe[1] );
              |if ($this->cin_pipe[0] != -1)  close( $this->cin_pipe[0] );
              |$this->cout_pipe[1] = -1;
              |$this->cerr_pipe[1] = -1;
              |$this->cin_pipe[0] = -1;
              |if (0 != result) return false;

      if (readable)
        output_reader = ProcessReader( this, native("$this->cout_pipe[0]")->Int32 )
        error_reader = ProcessReader( this, native("$this->cerr_pipe[0]")->Int32 )
      endIf

      if (writable)
        input_writer = FDWriter( native("$this->cin_pipe[1]")->Int32 )
      endIf

      return true

    method close->this
      return finish

    method exit_code->Int32
      return finish.@exit_code

    method is_finished->Logical
      if (@is_finished) return true
      native @|int status;
              |if ($this->pid)
              |{
              |  int wstatus;
              |  wstatus = waitpid( $this->pid,&status,WNOHANG );
              |  if ($this->pid == wstatus && WIFEXITED(status))
              |  {
              |    $this->pid = 0;
              |    $exit_code = WEXITSTATUS( status );
                   finish
      native @|  }
              |}
      return false;

    method is_running->Logical
      return (not is_finished)

    method finish->this
      if (not @is_finished)
        is_finished = true

        if (input_writer) input_writer.close

        while (update_readers(&poll_blocks)) noAction

        native @|int status;
                |if ($this->pid)
                |{
                |  waitpid( $this->pid, &status, 0 );
                |  $exit_code = WEXITSTATUS( status );
                |  $this->pid = 0;
                |}

        if (output_reader)
          output_reader.fd_reader.close
          error_reader.fd_reader.close
        endIf

        native @|posix_spawn_file_actions_destroy( &$this->actions );
      endIf

      native @|if ($this->cout_pipe[1] != -1) close( $this->cout_pipe[1] );
              |if ($this->cerr_pipe[1] != -1) close( $this->cerr_pipe[1] );
              |if ($this->cin_pipe[0] != -1)  close( $this->cin_pipe[0] );
              |$this->cout_pipe[1] = -1;
              |$this->cerr_pipe[1] = -1;
              |$this->cin_pipe[0] = -1;
              |if ($this->cout_pipe[0] != -1) close( $this->cout_pipe[0] );
              |if ($this->cerr_pipe[0] != -1) close( $this->cerr_pipe[0] );
              |if ($this->cin_pipe[1] != -1)  close( $this->cin_pipe[1] );
              |$this->cout_pipe[0] = -1;
              |$this->cerr_pipe[0] = -1;
              |$this->cin_pipe[1] = -1;

      return this

    method on_cleanup
      finish

    method run->Int32
      return finish.@exit_code

    method update_readers( &poll_blocks )->Logical
      # Returns true if we should keep updating

      # Get the FDs to poll.  We do this because they might have
      # changed (specifically, might have gone to -1).
      local fd0 = -1 : Int
      local fd1 = -1 : Int
      if (output_reader) fd0 = output_reader.fd_reader.fd
      if (error_reader)  fd1 =  error_reader.fd_reader.fd

      # Bail out if there's nobody to poll
      if (fd0 == -1 and fd1 == -1) return false

      # Set up poll_list and actually do the poll
      #NOTE: We could probably make poll_list local
      local status : Int32
      native @|$this->poll_list[0].fd = $fd0;
              |$this->poll_list[1].fd = $fd1;
              |$status = poll( $this->poll_list, 2, ($poll_blocks?-1:0) );

      if (status > 0)
        # One or more FDs had somehting to say
        local keep_going = false
        forEach (which_fd in 0..<2)
          local has_input = native("$this->poll_list[$which_fd].revents & POLLIN")->Logical
          local has_other = native("$this->poll_list[$which_fd].revents & ~POLLIN")->Logical
          local reader = ?:{which_fd == 0: output_reader || error_reader}

          if (has_input) reader.fd_reader.buffer_more

          # Anything besides readable is "bad" (it's most likely the other end hanging up)
          if (has_other) reader.fd_reader.close

          if (reader.fd_reader.is_open) keep_going = true
        endForEach
        return keep_going # If anyone wants to keep going, we keep going
      elseIf ((status == -1) and native("errno == EINTR")->Logical)
        # poll got interrupted; try again later
        return true
      endIf

      return false

endClass


class ProcessReader : Reader<<Byte>>
  PROPERTIES
    process   : Process
    fd_reader : FDReader

  METHODS
    method init( process, fd:Int32 )
      fd_reader = FDReader( fd, &!auto_close )

    method close->this
      fd_reader.fd = -1
      position = 0
      return this

    method has_another->Logical
      if (fd_reader.buffer_position >= fd_reader.buffer.count) process.update_readers( process.is_blocking )
      return (fd_reader.buffer_position < fd_reader.buffer.count)

    method peek->Byte
      if (not has_another) return 0
      return fd_reader.peek

    method read->Byte
      if (not has_another) return 0

      ++position
      return fd_reader.read

endClass
$endIf


class ProcessOutput
  PROPERTIES
    exit_code     : Int32
    output_bytes  : Byte[]
    error_bytes   : Byte[]
    output_string : String
    error_string  : String

  METHODS
    method init( exit_code, output_bytes, error_bytes )

    method error_string->String
      if (not @error_string) @error_string = String( error_bytes )
      return @error_string

    method output_string->String
      if (not @output_string) @output_string = String( output_bytes )
      return @output_string

    method success->Logical
      return 0 == exit_code

    method to->Int32
      return exit_code

    method to->String
      return output_string
endClass

