class String [foreign]
  GLOBAL METHODS
    method create( characters:Character[] )->String [macro]
      $if ("C++") native 'RogueString_create_from_characters( $characters )'

    method create( characters:StringBuilder )->String
      return create( characters.characters )

  METHODS
    method after( index:Int32 )->String
      # Returns the substring of this string that occur after
      # the given index.
      #
      # Equivalent to ''from(index+1)''.
      return from(index+1)

    method before( index:Int32 )->String
      # Returns the substring of this string that occur before
      # the given index.
      #
      # Equivalent to ''leftmost(index)''.
      return from(0,index-1)

    method after_any( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( i.value+1 )
      else          return this

    method after_any( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( i.value+st.count )
      else          return this

    method after_first( ch:Character )->String
      local i = locate( ch )
      if (i.exists) return from( i.value+1 )
      else          return ""

    method after_first( st:String )->String
      local i = locate( st )
      if (i.exists) return from( i.value+st.count )
      else          return ""

    method after_last( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( i.value+1 )
      else          return ""

    method after_last( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( i.value+st.count )
      else          return ""

    method before_first( ch:Character )->String
      local i = locate( ch )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_first( st:String )->String
      local i = locate( st )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method begins_with( ch:Character )->Logical
      return (count and this[0] == ch)

    method begins_with( other:String )->Logical
      local other_count = other.count
      return (count >= other_count and contains_at(other,0))

    method capitalized->String
      if (count == 0) return this
      local ch = this[0]
      if (ch < 'a' or ch > 'z') return this

      return (ch + ('A'-'a'))->Character + this.from( 1 )

    method consolidated->String
      return StringConsolidationTable[ this ]

    method contains( ch:Character )->Logical
      return locate(ch)?

    method contains( substring:String )->Logical
      return locate(substring)?

    method contains_at( substring:String, at_index:Int32 )->Logical
      $if ("C++")
        native @|RogueInt32 other_count = $substring->count;
                |if ($at_index < 0 || $at_index + other_count > $this->count) return false;
                |
                |RogueCharacter* this_data  = $this->characters;
                |RogueCharacter* other_data = $substring->characters;
                |
                |int i = -1;
                |int i2 = other_count - 1;
                |while (++i <= i2)
                |{
                |  if (this_data[$at_index+i] != other_data[i]) return false;
                |}
                |
                |return true;
      $endIf


    method count->Int32 [macro]
      $if ("C++") native '$this->count'

    method decode_utf8->String
      local needs_decoding = false
      forEach (ch in this)
        if (ch >= 0x80)
          needs_decoding = true
          escapeForEach
        endIf
      endForEach
      if (not needs_decoding) return this

      local buffer = StringBuilder( count )
      local characters = reader
      while (characters.has_another)
        local value = characters.read : Int32
        if (value <= 0x7f)
          buffer.print( value->Character )
        elseIf ((value & 0xe0) == 0xc0)
          # 110xxxxx 10xxxxxx
          value = ((value & 0x1f) :<<: 6) | (characters.read & 0x3f)
          buffer.print( value->Character )
        elseIf ((value & 0xf0) == 0xe0)
          # 1110xxxx 10xxxxxx 10xxxxxx
          value = ((value & 0xf) :<<: 6) | (characters.read & 0x3f)
          value = (value :<<: 6) | (characters.read & 0x3f)
          buffer.print( value->Character )
        else
          # 11110xxx 	10xxxxxx 	10xxxxxx 	10xxxxxx
          if (characters.has_another(3))
            value = ((value & 7) :<<: 18) | ((characters.read & 0x3f) :<<: 12)
            value |= (characters.read & 0x3f) :<<: 6
            value |= (characters.read & 0x3f)
            if (value >= 0x10000)
              # surrogate pair
              value -= 0x10000
              buffer.print( (0xd800 + ((value :>>>: 10) & 0x3ff))->Character )
              buffer.print( (0xdc00 + (value & 0x3ff))->Character )
            else
              buffer.print( value->Character )
            endIf
          endIf
        endIf
      endWhile

      return buffer->String

    method ends_with( other:String )->Logical
      local other_count = other.count
      return (count >= other_count and other_count > 0 and contains_at(other,count-other_count))

    method from( i1:Int32 )->String
      return from( i1, count-1 )

    method from( i1:Int32, i2:Int32 )->String
      $if ("C++")
        native @|// Clamp i1 and i2
                |if ($i1 < 0) $i1 = 0;
                |if ($i2 >= $this->count) $i2 = $this->count - 1;
                |
                |// Return empty quotes if zero-length
                |if ($i1 > $i2) return Rogue_literal_strings[0]; // empty string
                |
                |int new_count = ($i2 - $i1) + 1;
                |
                |RogueString* result = RogueString_create_with_count( new_count );
                |
                |// Copy character substring while computing hash code.
                |RogueCharacter* dest = result->characters - 1;
                |RogueCharacter* src  = ($this->characters + $i1) - 1;
                |RogueInt32 hash_code = 0;
                |while (--new_count >= 0)
                |{
                |  RogueCharacter ch = *(++src);
                |  *(++dest) = ch;
                |  hash_code = ((hash_code << 3) - hash_code) + ch;  // hash * 7 + ch
                |}
                |
                |result->hash_code = hash_code;
                |return result;
      $endIf

    method from_first( ch:Character )->String
      local i = locate( ch )
      if (not i) return ""
      return from( i.value )

    method from_first( st:String )->String
      local i = locate( st )
      if (not i) return ""
      return from( i.value )

    method from_last( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( i.value )
      else          return ""

    method from_last( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( i.value )
      else          return ""

    method get( index:Int32 )->Character [macro]
      $if ("C++") native '$this->characters[$index]'

    method hash_code->Int32 [macro]
      $if ("C++") native '$this->hash_code'

    method indented( spaces:Int32 )->String
      local lines = split( '\n' )
      local builder = StringBuilder( count + lines.count*2 )
      forEach (line in lines)
        if (builder.count) builder.println
        if (spaces> 0)      builder.print( " ".times(spaces) ).print( line )
        elseIf (spaces < 0) builder.print( line.rightmost(spaces) )
      endForEach
      return builder->String

    method last->Character
      return this[ count-1 ]

    method left_justified( spaces:Int32 )->String
      if (count >= spaces) return this

      local buffer = StringBuilder( spaces )
      buffer.print( this )
      forEach (count..spaces) buffer.print( ' ' )

      return buffer->String

    method leftmost( n:Int32 )->String
      if (n >= 0) return from( 0, n-1 )
      else        return from( 0, (count + n) - 1 )

    method locate( ch:Character, optional_i1=null:Int32? )->Int32?
      $if ("C++")
        native @|RogueInt32    limit = $this->count;
                |RogueCharacter* data  = $this->characters;
                |RogueInt32    i1 = $optional_i1.exists ? ($optional_i1.value-1) : -1;
                |
                |while (++i1 < limit)
                |{
                |  if (data[i1] == $ch)
                |  {
                |    return RogueOptionalInt32(i1);
                |  }
                |}
                |return RogueOptionalInt32();
      $endIf

    method locate( other:String, optional_i1=null:Int32? )->Int32?
      local other_count = other.count
      if (other_count == 1) return locate( other[0], optional_i1 )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      local i1 : Int32
      if (optional_i1)
        i1 = optional_i1.value - 1
        if (i1 < -1) i1 = -1
      else
        i1 = -1
      endIf

      while (native("++$i1")->Int32 < this_limit)
        if (contains_at(other,i1)) return i1
      endWhile

      return null

    method locate_last( ch:Character, starting_index=null:Int32? )->Int32?
      $if ("C++")
        native @|RogueInt32    limit = $this->count;
                |RogueCharacter* data  = $this->characters;
                |
                |int i;
                |if ($starting_index.exists)
                |{
                |  i = $starting_index.value + 1;
                |  if (i > limit) i = limit;
                |}
                |else
                |{
                |  i = limit;
                |}
                |
                |while (--i >= 0)
                |{
                |  if (data[i] == $ch) return RogueOptionalInt32(i);
                |}
                |
                |return RogueOptionalInt32();
      $endIf

    method locate_last( other:String, starting_index=null:Int32? )->Int32?
      local other_count = other.count
      if (other_count == 1) return locate_last( other[0], starting_index )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      local i : Int32
      if (starting_index)
        i = starting_index.value + 1
        if (i > this_limit) i = this_limit
      else
        i = this_limit
      endIf

      while (native("--$i")->Int32 >= 0)
        if (contains_at(other,i)) return i
      endWhile

      return null

    method matches_wildcard_pattern( wildcard_pattern:String )->Logical
      # Determines whether or not this string matches the given
      # Unix/Dos-style ''wildcard pattern''.  ''wildcard_pattern'' is a
      # regular text string that may contain the following special
      # characters:
      #
      # * * - matches zero or more characters of this string.
      # * ? - matches any one character of this string.
      #
      # Example:
      #
      #   local String st = "img_01.png"
      #   println( st.matches_wildcard_pattern("*.png") )  # true
      #   println( st.matches_wildcard_pattern("img_??.png") )  # true
      local c = count
      if (c == 0 and wildcard_pattern.count == 0) return true
      if (wildcard_pattern.count == 0) return false

      local remaining_pattern = wildcard_pattern.from( 1 )
      local ch = wildcard_pattern[0]
      which (ch)
        case '*':
          forEach (n in 0..c)
            if (from(n).matches_wildcard_pattern(remaining_pattern)) return true
          endForEach

        case '?':
          if (c == 0) return false
          return from(1).matches_wildcard_pattern( remaining_pattern )

        others:
          if (c == 0) return false
          if (ch == this[0])
            return from(1).matches_wildcard_pattern( remaining_pattern )
          endIf
      endWhich
      return false

    method operator+( value:Byte )->String [macro]
      this + value->Int32

    method operator+( value:Character )->String
      return StringBuilder().print( this ).print( value )->String

    method operator+( value:Int32 )->String
      return StringBuilder().print( this ).print( value )->String

    method operator==( value:String )->Logical
      if (this.hash_code != value.hash_code or this.count != value.count) return false
      return (native("(0==memcmp($this->characters,$value->characters,$this->count*sizeof(RogueCharacter)))")->Logical)

    method operator==( value:StringBuilder )->Logical
      return (value == this)  # invoke the existing operator== method on value)

    method operator<>( other:String )->Int32
      $if ("C++")
        native @|if ($this == $other) return 0;
                |
                |RogueInt32 other_count = $other->count;
                |RogueInt32 limit = $this->count;
                |
                |int result;
                |if (limit == other_count)
                |{
                |  // Strings are same length
                |  result = memcmp( $this->characters, $other->characters, limit * sizeof(RogueCharacter) );
                |  if (result == 0) return 0;
                |}
                |else
                |{
                |  // Strings differ in length.  Compare the part that matches first.
                |  if (limit > other_count) limit = other_count;
                |  result = memcmp( $this->characters, $other->characters, limit * sizeof(RogueCharacter) );
                |  if (result == 0)
                |  {
                |    // Equal so far - the shorter string comes before the longer one.
                |    if (limit == other_count) return 1;
                |    return -1;
                |  }
                |}
                |if (result < 0) return -1;
                |else            return 1;
      $endIf

    method operator+( value:Logical )->String
      if (value) return this + "true"
      else       return this + "false"

    method operator+( value:Int64 )->String
      return StringBuilder().print( this ).print( value )->String

    method operator+( value:Object )->String
      if (value) return this + value->String
      else       return this + "null"

    method operator+( value:Real64 )->String
      return StringBuilder().print( this ).print( value )->String

    method operator+( value:String )->String
      if (value is null) return this + "null"
      if (count == 0) return value
      if (value.count == 0) return this
      return StringBuilder().print( this ).print( value )->String

    method operator*( value:Int32 )->String [macro]
      this.times( value )

    method pluralized( quantity:Int32 )->String
      # Returns a pluralized form of this string.
      #
      # This string may be of the form "singlar" or "singlar/plural",
      # where both singular and plural parts may contain a "#"
      # to indicate where the given ''quantity'' should be inserted.
      #
      # If the string only contains the "singular" part, first a
      # substring of the form "(s)" or "(es)" (etc.) is looked for.
      # If that exists, it is included in the result if the string
      # is plural and omitted if the string is singular.
      #
      # If there is no "(s)" (etc.) then either "s" or "es" is
      # inserted after the last letter - "es" is used only when the
      # last letter is an "s" already.
      #
      # Examples:
      #
      #   "cat".pluralized(1)   # returns: cat
      #   "cat".pluralized(2)   # returns: cats
      #   "My # glass.".pluralized(1)  # returns: My 1 glass.
      #   "My # glass.".pluralized(2)  # returns: My 2 glasses.
      #   "a thief./# thieves".pluralized(1)   # returns: a thief.
      #   "a thief./# thieves".pluralized(40)  # returns: 40 thieves.
      #   "# match(es) found".pluralized(1)    # returns: 1 match found
      #   "# match(es) found".pluralized(0)    # returns: 0 matches found
      local st = this.replacing( "#", ""+quantity )

      if (st.contains('/'))
        if (quantity == 1) return st.before_first( '/' )
        else               return st.after_last( '/' )

      else
        local alt1 = st.locate('(')
        if (alt1.exists)
          local alt2 = st.locate(')',alt1.value+1)
          if (not alt2.exists) return this

          if (quantity == 1)
            return st.before(alt1.value) + st.after(alt2.value)
          endIf

          # plural
          return "$$$" (st.before(alt1.value),st.from(alt1.value+1,alt2.value-1),st.after(alt2.value))
        else
          if (quantity == 1) return st

          # plural
          local index = 0
          local i = st.count
          while (i > 0)
            --i
            if (st[i].is_letter) index = i; escapeWhile
          endWhile

          if (st[index] == 's') return "$es$" (st.before(index+1),st.after(index))
          else                  return "$s$" (st.before(index+1),st.after(index))
        endIf

      endIf

    method reader->StringReader
      return StringReader( this )

    method replacing( look_for:Character, replace_with:Character )->String
      if (not contains(look_for)) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch == look_for) result.print( replace_with )
        else                   result.print( ch )
      endForEach
      return result->String

    method replacing( look_for:Character, replace_with:String )->String
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      if (not contains(look_for)) return this

      local buffer = StringBuilder(count*2)
      forEach (ch in this)
        if (ch == look_for) buffer.print( replace_with )
        else                buffer.print( ch )
      endForEach

      return buffer->String

    method replacing( look_for:String, replace_with:String )->String
      # Returns a modified string where all instances of
      # ''look_for'' are replaced with ''replace_with''.
      local buffer = StringBuilder( count*2 )
      local st = this
      local i = st.locate(look_for)
      if (not i.exists) return st
      while (i.exists)
        buffer.print( st.before(i.value) )
        buffer.print( replace_with )
        st = st.from( i.value + look_for.count )
        i = st.locate(look_for)
      endWhile
      buffer.print( st )
      return buffer->String

    method reversed->String
      local buffer = StringBuilder(count)
      forEach (ch in this step -1)
        buffer.print( ch )
      endForEach
      return buffer->String

    method right_justified( spaces:Int32 )->String
      if (count >= spaces) return this

      local buffer = StringBuilder( spaces )
      forEach (count..spaces) buffer.print( ' ' )
      buffer.print( this )

      return buffer->String

    method rightmost( n:Int32 )->String
      local this_count = count
      if (n < 0) return from( -n, this_count-1 )
      else       return from( this_count-n, this_count-1 )

    method split( separator:Character )->String[]
      local result = String[]

      local i1 = 0
      local i2 = locate( separator, i1 )
      while (i2.exists)
        result.add( from(i1,i2.value-1) )
        i1 = i2.value + 1
        i2 = locate( separator, i1 )
      endWhile

      result.add( from(i1) )

      return result

    method split( separator:String )->String[]
      local result = String[]
      local separator_count = separator.count

      local i1 = 0
      local i2 = locate( separator, i1 )
      while (i2.exists)
        result.add( from(i1,i2.value-1) )
        i1 = i2.value + separator_count
        i2 = locate( separator, i1 )
      endWhile

      result.add( from(i1) )

      return result

    method split->String[]
      # Splits the string on whitespace

      local result = String[]
      local start = -1
      local current = 0
      forEach (ch in this)
        which (ch)
          case ' ', '\t', '\n':
            if start >= 0
              result.add( this.from(start, current-1) )
              start = -1
            endIf
          others:
            if start < 0
              start = current
            endIf
          endWhich
        current++
      endForEach

      if start >= 0
        result.add( this.from(start, current-1) )
      endIf

      return result

    method join( substrings:String[] )->String
      return join( substrings.reader )

    method join( substrings:Reader<<String>> )->String
      local result = StringBuilder()
      local first = true
      forEach (s in substrings)
        if (not first) result.print(this)
        first = false
        result.print( s )
      endForEach
      return result->String

    method substring( i1:Int32, n:Int32 )->String
      return from( i1, i1+(n-1) )

    method times( n:Int32 )->String
      if (n <= 0) return ""
      if (n == 1) return this

      local builder = StringBuilder( count * n )
      forEach (1..n) builder.print( this )

      return builder->String

    method to->Int32
      $if ("C++")
        native @|char buffer[80];
                |if (RogueString_to_c_string($this,buffer,80))
                |{
                |  return (RogueInt32) strtol( buffer, 0, 10 );
                |}
                |else
                |{
                |  return 0;
                |}
      $endIf

      #{
    method to->Object
      return Boxed<<String>>(this)
      }#

    method to->Real64
      $if ("C++")
        native @|char buffer[80];
                |if (RogueString_to_c_string($this,buffer,80))
                |{
                |  return strtod( buffer, 0 );
                |}
                |else
                |{
                |  return 0;
                |}
      $endIf

    method to->String
      return this

    method to_lowercase->String
      local has_uc = false
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') has_uc = true; escapeForEach
      endForEach

      if (not has_uc) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') result.print( ((ch-'A')+'a')->Character )
        else                         result.print( ch )
      endForEach
      return result->String

    method to_uppercase->String
      local has_lc = false
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'a') has_lc = true; escapeForEach
      endForEach

      if (not has_lc) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'z') result.print( ((ch-'a')+'A')->Character )
        else                         result.print( ch )
      endForEach
      return result->String

    method to_utf8->String
      # Returns a copy of this string encoded in UTF-8 format where only
      # the lower 8 bits of each character are used.  Any character
      # with the unicode range 0..127 is unchanged; characters originally
      # having a higher unicode value are encoded into a sequence of 2 or 3
      # consecutive characters.

      # Return this string unchanged if no alterations are required
      local needs_encoding = false
      forEach (ch in this)
        if (ch >= 0x80)
          needs_encoding = true
          escapeForEach
        endIf
      endForEach
      if (not needs_encoding) return this

      local result = StringBuilder( count )

      local n = count
      local i = 0
      while (i < n)
        local ch = this[i]
        ++i

        if (ch < 0x80)
          # %0xxxxxxx
          result.print( ch )

        elseIf (ch < 0x800)
          # %110xxxxx 10xxxxxx
          result.print( (((ch:>>>:6) & 0x1f) | 0xc0)->Character )
          result.print( ((ch & 0x3f) | 0x80)->Character )

        elseIf (ch >= 0xd800 and ch <= 0xdbff and i < n)
          # Start of a surrogate pair
          local low = this[i]
          ++i
          if (low >= 0xdc00 and low <= 0xdfff)
            local value = 0x10000 + (((ch - 0xd800):<<:10) | (low-0xdc00))
            result.print( (0xf0 | ((value:>>>:18) & 7))->Character )
            result.print( (0x80 | ((value:>>>:12) & 0x3f))->Character )
            result.print( (0x80 | ((value:>>>:6)  & 0x3f))->Character )
            result.print( ((value & 0x3f) | 0x80)->Character )
          endIf
        else
          # %1110xxxx 10xxxxxx 10xxxxxx
          result.print( (((ch:>>>:12) & 15) | 0xe0)->Character )
          result.print( (((ch:>>>:6) & 0x3f) | 0x80)->Character )
          result.print( ((ch & 0x3f) | 0x80)->Character )

        endIf

      endWhile

      return result->String

    method trimmed->String
      local i1 = 0
      local i2 = count - 1

      while (i1 <= i2)
        if     (this[i1] <= ' ') ++i1
        elseIf (this[i2] <= ' ') --i2
        else                     escapeWhile
      endWhile

      if (i1 > i2) return ""
      if (i1 == 0 and i2 == count-1) return this
      return from( i1, i2 )

    method word_wrapped( width:Int32 )->String[]
      # Returns a word-wrapped version of this string as a list of lines.
      # Existing newlines characters will cause a new line to begin
      # immediately.  Spaces immediately following existing newline
      # characters are preserved.
      return word_wrapped( width, StringBuilder() )->String.split('\n')

    method word_wrapped( width:Int32, buffer:StringBuilder )->StringBuilder
      # Prints a word-wrapped version of this string to the given
      # StringBuilder.  Existing newlines characters will cause a new line to
      # begin immediately.  Spaces immediately following existing newline
      # characters are preserved.
      local i1, i2 : Int32
      local len = count

      if (len == 0) return buffer

      local needs_newline = false
      while (i2 < len)

        # find last space or first \n
        while ((i2-i1) < width and i2 < len and this[i2] != '\n') i2++

        if ((i2-i1) == width)
          if (i2 >= len)
            i2 = len
          else
            while (this[i2]!=' ' and this[i2]!='\n' and i2>i1) i2--
            if (i2 == i1) i2 = i1 + width
          endIf
        endIf

        if (needs_newline)
          buffer.println
        endIf
        forEach (i in i1..(i2-1)) buffer.print( this[i] )
        needs_newline = true

        if (i2 == len)
          return buffer
        else
          which (this[i2])
            case ' ':
              while (i2<len and this[i2]==' ') i2++
              if (i2<len and this[i2]=='\n') i2++

            case '\n':
              i2++
          endWhich
          i1 = i2
        endIf
      endWhile

      return buffer

  GLOBAL METHODS
    method operator*( integer:Int32, string:String  )->String [macro]
      string.times( integer )

endClass

class StringReader : Reader<<Character>>
  PROPERTIES
    position : Int32
    count    : Int32
    string   : String

  METHODS
    method init( string )
      if (string) count = string.count

    method has_another->Logical
      return (position < count)

    method has_another( n:Int32 )->Logical
      return (position + n <= count)

    method peek->Character
      if (position == count) return 0
      return string[ position ]

    method read->Character
      ++position
      return string[ position - 1 ]

    method reset->this
      seek( 0 )
      return this

    method seek( pos:Int32 )->this
      count = string.count
      if (pos < 0 or pos > count) return this
      position = pos
      return this
endClass

class LineReader : Reader<<String>>
  PROPERTIES
    source : Reader<<Character>>
    next   : String
    buffer = StringBuilder()
    prev   : Character

  METHODS
    method init( source )
      next = prepare_next

    method init( file:File )
      init( file.reader )

    method init( string:String )
      init( string.reader )

    method has_another->Logical
      return next

    method peek->String
      return next

    method prepare_next->String
      if (not source.has_another)
        if (prev == '\n')
          # if the last line ended with '\n', count it as one more line
          prev = 0
          return ""
        else
          return null
        endIf
      endIf

      prev = 0

      buffer.clear
      while (source.has_another)
        local ch = source.read
        if (ch == '\n') prev = '\n'; return buffer->String
        buffer.print( ch )
      endWhile

      return buffer->String

    method read->String
      local result = next
      next = prepare_next
      ++position
      return result

    method reset->this
      seek( 0 )
      return this

    method seek( n:Int32 )->this
      if (n < 0) n = 0

      if (n < position)
        source.reset
        position = 0
        next = prepare_next
      endIf

      while (n > position)
        read
      endWhile

      return this

endClass


class StringConsolidationTable : StringTable<<String>> [singleton]
  # Used by the consolidate() and consolidated() methods to map equivalent
  # strings to the same string object on demand.  Reduces memory usage and
  # allows the use of the 'is' test rather than the '==' test.  Similar
  # to Java's intern() method.
  METHODS
    method get( st:String )->String
      local result = prior.get( st )
      if (result) return result
      this[ st ] = st
      return st

    method get( buffer:StringBuilder )->String
      local result = prior.get( buffer )
      if (result) return result
      
      result = buffer->String
      this[ result ] = result
      return result
endClass


