class String [native functional]
  ROUTINES
    routine create( characters:Character[] )->String
      $if ("C++") inlineNative 'RogueString::create( $characters )'

    routine create( characters:StringBuilder )->String
      return create( characters.characters )

  METHODS
    method after_any( ch:Character )->String
      local i = locate( ch )
      if (i.exists) return from( i.value+1 )
      else          return this

    method after_any( st:String )->String
      local i = locate( st )
      if (i.exists) return from( i.value+st.count )
      else          return this

    method after_first( ch:Character )->String
      local i = locate( ch )
      if (i.exists) return from( i.value+1 )
      else          return ""

    method after_first( st:String )->String
      local i = locate( st )
      if (i.exists) return from( i.value+st.count )
      else          return ""

    method after_last( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( i.value+1 )
      else          return ""

    method after_last( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( i.value+st.count )
      else          return ""

    method before_first( ch:Character )->String
      local i = locate( ch )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_first( st:String )->String
      local i = locate( st )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method before_last( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( 0, i.value-1 )
      else          return this

    method begins_with( ch:Character )->Logical
      return (count and this[0] == ch)

    method begins_with( other:String )->Logical
      local other_count = other.count
      return (count >= other_count and contains_at(other,0))

    method contains( substring:String )->Logical
      return locate(substring)?

    method contains_at( substring:String, at_index:Integer )->Logical
      $if ("C++") inlineNative '$this->contains($substring,$at_index)'

    method count->Integer
      $if ("C++") inlineNative '$this->count'

    method ends_with( other:String )->Logical
      local other_count = other.count
      return (count >= other_count and other_count > 0 and contains_at(other,count-other_count))

    method from( i1:Integer )->String
      return from( i1, count-1 )

    method from( i1:Integer, i2:Integer )->String
      $if ("C++")
        native @|// Clamp i1 and i2
                |if ($i1 < 0) $i1 = 0;
                |if ($i2 >= $this->count) $i2 = $this->count - 1;
                |
                |// Return empty quotes if zero-length
                |if ($i1 > $i2) return Rogue_program.literal_strings[0]; // empty string
                |
                |int new_count = ($i2 - $i1) + 1;
                |
                |RogueString* result = RogueString::create( new_count );
                |
                |// Copy character substring while computing hash code.
                |RogueCharacter* dest = result->characters - 1;
                |RogueCharacter* src  = ($this->characters + $i1) - 1;
                |RogueInteger hash_code = 0;
                |while (--new_count >= 0)
                |{
                |  RogueCharacter ch = *(++src);
                |  *(++dest) = ch;
                |  hash_code = ((hash_code << 3) - hash_code) + ch;  // hash * 7 + ch
                |}
                |
                |result->hash_code = hash_code;
                |return result;
      $endIf

    method from_first( ch:Character )->String
      local i = locate( ch )
      if (not i) return ""
      return from( i! )

    method from_first( st:String )->String
      local i = locate( st )
      if (not i) return ""
      return from( i! )

    method from_last( ch:Character )->String
      local i = locate_last( ch )
      if (i.exists) return from( i.value )
      else          return ""

    method from_last( st:String )->String
      local i = locate_last( st )
      if (i.exists) return from( i.value )
      else          return ""

    method get( index:Integer )->Character
      $if ("C++") inlineNative '$this->characters[$index]'

    method hash_code->Integer
      $if ("C++") inlineNative '$this->hash_code'

    method indented( spaces:Integer )->String
      local lines = split( '\n' )
      local builder = StringBuilder( count + lines.count*2 )
      forEach (line in lines)
        if (builder.count) builder.println
        if (spaces> 0)      builder.print( " ".times(spaces) ).print( line )
        elseIf (spaces < 0) builder.print( line.rightmost(spaces) )
      endForEach
      return builder->String

    method last->Character
      return this[ count-1 ]

    method left_justified( spaces:Integer )->String
      if (count >= spaces) return this

      local buffer = StringBuilder( spaces )
      buffer.print( this )
      forEach (count..spaces) buffer.print( ' ' )

      return buffer->String

    method leftmost( n:Integer )->String
      if (n >= 0) return from( 0, n-1 )
      else        return from( 0, (count + n) - 1 )

    method locate( ch:Character, optional_i1=null:Integer? )->Integer?
      $if ("C++")
        native @|RogueInteger    limit = $this->count;
                |RogueCharacter* data  = $this->characters;
                |RogueInteger    i1 = $optional_i1.exists ? ($optional_i1.value-1) : -1;
                |
                |while (++i1 < limit)
                |{
                |  if (data[i1] == $ch)
                |  {
                |    return RogueOptionalInteger(i1);
                |  }
                |}
                |return RogueOptionalInteger();
      $endIf

    method locate( other:String, optional_i1=null:Integer? )->Integer?
      local other_count = other.count
      if (other_count == 1) return locate( other[0], optional_i1 )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null
      
      local i1 : Integer
      if (optional_i1)
        i1 = optional_i1.value - 1
        if (i1 < -1) i1 = -1
      else
        i1 = -1
      endIf
      
      ++i1
      while (i1 < this_limit)
        if (contains_at(other,i1)) return i1
        ++i1
      endWhile

      return null

    method locate_last( ch:Character, starting_index=null:Integer? )->Integer?
      $if ("C++")
        native @|RogueInteger    limit = $this->count;
                |RogueCharacter* data  = $this->characters;
                |
                |int i;
                |if ($starting_index.exists)
                |{
                |  i = $starting_index.value + 1;
                |  if (i > limit) i = limit;
                |}
                |else
                |{
                |  i = limit;
                |}
                |
                |while (--i >= 0)
                |{
                |  if (data[i] == $ch) return RogueOptionalInteger(i);
                |}
                |
                |return RogueOptionalInteger();
      $endIf

    method locate_last( other:String, starting_index=null:Integer? )->Integer?
      local other_count = other.count
      if (other_count == 1) return locate_last( other[0], starting_index )

      local this_limit = (count - other_count) + 1
      if (other_count == 0 or this_limit <= 0) return null

      local i : Integer
      if (starting_index)
        i = starting_index.value + 1
        if (i > this_limit) i = this_limit
      else
        i = this_limit
      endIf

      --i
      while (i >= 0)
        if (contains_at(other,i)) return i
        --i
      endWhile

      return null

    method operator+( value:Byte )->String
      inline this + value->Integer

    method operator+( value:Character )->String
      $if ("C++") inlineNative '$this->plus($value)'

    method operator+( value:Integer )->String
      $if ("C++") inlineNative '$this->plus($value)'

    method operator<>( other:String )->Integer
      $if ("C++")
        native @|if ($this == $other) return 0;
                |
                |RogueInteger other_count = $other->count;
                |RogueInteger limit = $this->count;
                |
                |int result;
                |if (limit == other_count)
                |{
                |  // Strings are same length
                |  result = memcmp( $this->characters, $other->characters, limit * sizeof(RogueCharacter) );
                |  if (result == 0) return 0;
                |}
                |else
                |{
                |  // Strings differ in length.  Compare the part that matches first.
                |  if (limit > other_count) limit = other_count;
                |  result = memcmp( $this->characters, $other->characters, limit * sizeof(RogueCharacter) );
                |  if (result == 0)
                |  {
                |    // Equal so far - the shorter string comes before the longer one.
                |    if (limit == other_count) return 1;
                |    return -1;
                |  }
                |}
                |if (result < 0) return -1;
                |else            return 1;
      $endIf

    method operator+( value:Logical )->String
      if (value) return this + "true"
      else       return this + "false"

    method operator+( value:Long )->String
      $if ("C++") inlineNative '$this->plus($value)'

    method operator+( value:Object )->String
      if (value) return this + value->String
      else       return this + "null"

    method operator+( value:Real )->String
      $if ("C++") inlineNative '$this->plus($value)'

    method operator+( value:String )->String
      $if ("C++") inlineNative '$this->plus($value)'

    method reader->StringReader
      return StringReader( this )

    method replace( existing_ch:Character, replacement_ch:Character )->String
      contingent
        forEach (ch in this)
          necessary (ch != existing_ch)
        endForEach

      satisfied
        # No changes required
        return this

      unsatisfied
        local result = StringBuilder( count )
        forEach (ch in this)
          if (ch == existing_ch) result.print( replacement_ch )
          else                   result.print( ch )
        endForEach
        return result->String

      endContingent


    method reversed->String
      local buffer = StringBuilder(count)
      forEach (ch in this step -1)
        buffer.print( ch )
      endForEach
      return buffer->String

    method right_justified( spaces:Integer )->String
      if (count >= spaces) return this

      local buffer = StringBuilder( spaces )
      forEach (count..spaces) buffer.print( ' ' )
      buffer.print( this )

      return buffer->String

    method rightmost( n:Integer )->String
      local this_count = count
      if (n < 0) return from( -n, this_count-1 )
      else       return from( this_count-n, this_count-1 )

    method split( separator:Character )->String[]
      local result = String[]

      local i1 = 0
      local i2 = locate( separator, i1 )
      while (i2.exists)
        result.add( from(i1,i2.value-1) )
        i1 = i2.value + 1
        i2 = locate( separator, i1 )
      endWhile

      result.add( from(i1) )

      return result

    method split( separator:String )->String[]
      local result = String[]
      local separator_count = separator.count

      local i1 = 0
      local i2 = locate( separator, i1 )
      while (i2.exists)
        result.add( from(i1,i2.value-1) )
        i1 = i2.value + separator_count
        i2 = locate( separator, i1 )
      endWhile

      result.add( from(i1) )

      return result

    method substring( i1:Integer, n:Integer )->String
      return from( i1, i1+(n-1) )

    method times( n:Integer )->String
      if (n <= 0) return ""
      if (n == 1) return this

      local builder = StringBuilder( count * n )
      forEach (1..n) builder.print( this )

      return builder->String

    method to->Integer
      $if ("C++")
        native @|char buffer[80];
                |if ($this->to_c_string(buffer,80))
                |{
                |  return strtol( buffer, 0, 10 );
                |}
                |else
                |{
                |  return 0;
                |}
      $endIf

    method to->Real
      $if ("C++")
        native @|char buffer[80];
                |if ($this->to_c_string(buffer,80))
                |{
                |  return strtod( buffer, 0 );
                |}
                |else
                |{
                |  return 0;
                |}
      $endIf

    method to->String
      return this

    method to_lowercase->String
      local has_uc = false
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') has_uc = true; escapeForEach
      endForEach

      if (not has_uc) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch >= 'A' and ch <= 'Z') result.print( ((ch-'A')+'a')->Character )
        else                         result.print( ch )
      endForEach
      return result->String

    method to_uppercase->String
      local has_lc = false
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'a') has_lc = true; escapeForEach
      endForEach

      if (not has_lc) return this

      local result = StringBuilder( count )
      forEach (ch in this)
        if (ch >= 'a' and ch <= 'z') result.print( ((ch-'a')+'A')->Character )
        else                         result.print( ch )
      endForEach
      return result->String

    method word_wrapped( width:Integer )->String[]
      # Returns a word-wrapped version of this string as a list of lines.
      # Existing newlines characters will cause a new line to begin
      # immediately.  Spaces immediately following existing newline 
      # characters are preserved.
      return word_wrapped( width, StringBuilder() )->String.split('\n')

    method word_wrapped( width:Integer, buffer:StringBuilder )->StringBuilder
      # Prints a word-wrapped version of this string to the given
      # StringBuilder.  Existing newlines characters will cause a new line to 
      # begin immediately.  Spaces immediately following existing newline 
      # characters are preserved.
      local i1, i2 : Integer
      local len = count

      if (len == 0) return buffer

      local needs_newline = false
      while (i2 < len)

        # find last space or first \n
        while ((i2-i1) < width and i2 < len and this[i2] != '\n') i2++

        if ((i2-i1) == width)
          if (i2 >= len)
            i2 = len
          else
            while (this[i2]!=' ' and this[i2]!='\n' and i2>i1) i2--
            if (i2 == i1) i2 = i1 + width
          endIf
        endIf

        if (needs_newline)
          buffer.println
        endIf
        forEach (i in i1..(i2-1)) buffer.print( this[i] )
        needs_newline = true

        if (i2 == len)
          return buffer
        else
          which (this[i2])
            case ' ':
              while (i2<len and this[i2]==' ') i2++
              if (i2<len and this[i2]=='\n') i2++

            case '\n':
              i2++
          endWhich
          i1 = i2
        endIf
      endWhile

      return buffer

endClass
