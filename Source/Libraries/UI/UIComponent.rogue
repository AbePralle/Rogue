module UI
  uses Utility/Node

class UIComponent : Node<<UIComponent>>
  PROPERTIES
    position : XY
    size     : XY
    offset   : XY
    content_size     : XY

    is_modified  = true
    needs_draw   : Logical
    needs_render : Logical
    renderer     : UIRenderer?

  METHODS
    method init( content=null:UIComponent )
      if (content) add( content )

    method after( e:ScrollEvent )
      noAction

    method after_buffer
      # Called at the end of a buffer operation after any children have been drawn
      noAction

    method after_render
      # Called at the end of a render operation after any children have been drawn
      noAction

    method assign_renderer [propagated]
      UIManager.theme._dispatch_assign_renderer( this )

    method bounds->Box
      return display_bounds

    method content_bounds->Box
      local cx = which{ content_size.x || size.x }
      local cy = which{ content_size.y || size.y }
      return Box( position+offset, XY(cx,cy) )

    method dispatch( e:ScrollEvent )
      forEachChild (cur,this)
        if (e.is_consumed) return
        cur.handle( e )
      endForEachChild (cur)

    method display_bounds->Box
      return Box( position, size )

    method compute_bounds( parent_bounds:Box )->Box
      if (content_size.x)
        if (content_size.y)
          return Box( position, content_size )
        else
          return Box( position.x, parent_bounds.position.y, content_size.x, parent_bounds.size.y )
        endIf
      else
        if (content_size.x)
          return Box( parent_bounds.position.x, position.y, parent_bounds.size.x, content_size.y )
        else
          return parent_bounds
        endIf
      endIf

    method draw
      update_layout

      if (not renderer.exists) assign_renderer

      if (needs_draw)
        needs_render = true
        on_buffer
      elseIf (UIManager.render_every_frame)
        needs_render = true
      endIf

      if (needs_render)
        on_render
      endIf

      forEachChild (cur,this,cur.draw)

      if (needs_draw)
        needs_draw = false
        after_buffer
      endIf

      if (needs_render)
        needs_render = false
        after_render
      endIf

    method handle( e:ScrollEvent )
      on( e )
      if (not e.is_consumed) dispatch( e )
      if (not e.is_consumed) after( e )

    method horizontal_flex->Real64
      if (content_size.x) return 0.0
      else              return 1.0

    method invalidate
      mark_modified

    method maximum_height( &subcomponents_only )->Real64
      return content_size.y

    method maximum_size( &subcomponents_only )->XY
      return XY( maximum_width, maximum_height )

    method maximum_width( &subcomponents_only )->Real64
      return content_size.x

    method minimum_height( &subcomponents_only )->Real64
      return content_size.y

    method minimum_size( &subcomponents_only )->XY
      return XY( minimum_width, minimum_height )

    method minimum_width( &subcomponents_only )->Real64
      return content_size.x

    method on( e:ScrollEvent )
      noAction

    method on_buffer
      # Called at the beginning of a buffer operation before any children have been drawn
      _dispatch_buffer

    method on_render
      # Called at the beginning of a render operation before any children have been drawn
      _dispatch_render

    method on_update
      noAction

      #{
    method operator+( right_component:UIComponent )->UIComponent
      return UILayout.h.[ add(this), add(right_component) ]

    method operator/( bottom_component:UIComponent )->UIComponent
      return UILayout.v.[ add(this), add(bottom_component) ]
      }#

    method redraw
      needs_draw = true
      redraw_area( display_bounds )

    method redraw_area( area:Box )
      # Propagate area to root
      if (parent) parent.redraw_area( area )

    method set_bounds( new_bounds:Box )
      set_display_bounds( new_bounds )

    method set_content_bounds( new_bounds:Box )
      offset = new_bounds.position
      content_size = new_bounds.size

    method set_content_size( new_size:XY )
      if (@content_size != new_size)
        is_modified = true
        @content_size = new_size
      endIf
      if (@size != new_size)
        is_modified = true
        @size = new_size
      endIf

    method set_display_bounds( new_bounds:Box )
      set_position( new_bounds.position )
      set_size( new_bounds.size )

    method set_is_modified( setting:Logical )
      if (setting) mark_modified
      @is_modified = true

    method set_offset( new_content_offset:XY )
      if (@offset != new_content_offset)
        is_modified = true
        @offset = new_content_offset
      endIf

    method set_position( new_position:XY )
      if (@position != new_position)
        is_modified = true
        @position = new_position
      endIf

    method set_size( new_size:XY )
      set_content_size( new_size )

    method update
      update( display_bounds )

    method update( new_bounds:Box )
      on_update
      update_layout( new_bounds )
      forEachChild (cur,this,cur.update)

    method update_subcomponent_layout
      local bounds = this.display_bounds
      forEachChild (cur,this,cur.update_layout(bounds))

    method update_draw_buffer
      needs_draw = false
      needs_render = true

    method update_layout
      update_layout( display_bounds )

    method update_layout( new_bounds:Box )
      if (is_modified or new_bounds != display_bounds)
        is_modified = false
        needs_draw = true
        @size = XY( which{content_size.x||new_bounds.width}, which{content_size.y||new_bounds.height} ).floor
        @position = display_bounds.positioned_within( new_bounds ).position.floor
        update_subcomponent_layout
      endIf

    method vertical_flex->Real64
      if (content_size.y) return 0.0
      else                return 1.0

    method _assign_renderer<<$Theme>>( theme:$Theme ) [propagated]
      renderer = (UIManager.theme as $Theme).renderer( this )

    method _dispatch_buffer [propagated]
      if (renderer.exists and renderer.value)
        # The renderer can exist and be null
        renderer.value.buffer( this )
      endIf

    method _dispatch_render [propagated]
      if (renderer.exists and renderer.value)
        # The renderer can exist and be null
        renderer.value.render( this )
      endIf
endClass

