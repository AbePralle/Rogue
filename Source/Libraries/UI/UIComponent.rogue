module UI
  uses Utility/Node

class UIComponent : Node<<UIComponent>>
  DEFINITIONS
    FLAG_FIXED_WIDTH           = 1
    FLAG_FIXED_HEIGHT          = 2
    FLAG_SHRINK_TO_FIT_WIDTH   = 4
    FLAG_SHRINK_TO_FIT_HEIGHT  = 8
    FLAG_WIDTH_MASK            = (FLAG_FIXED_WIDTH | FLAG_SHRINK_TO_FIT_WIDTH)
    FLAG_HEIGHT_MASK           = (FLAG_FIXED_HEIGHT | FLAG_SHRINK_TO_FIT_HEIGHT)
    FLAG_SIZE_MASK             = (FLAG_WIDTH_MASK | FLAG_HEIGHT_MASK)
    FLAG_DEFAULT_WIDTH         = 16
    FLAG_DEFAULT_HEIGHT        = 32

  PROPERTIES
    position    : XY
    size        : XY
    flags       : Int32
    attributes  : UIAttribute
    
  METHODS
    method init

    method init( w:Real64, h:Real64 )
      init( XY(w,h) )

    method init( size:XY )
      fixed_size = size

    method init( position, size:XY )
      init( size )

    method init( bounds:Box )
      init( bounds.position, bounds.size )

    method init( content:UIComponent )
      init
      if (content) add( content )

    method add( attribute:UIAttribute )
      if (not attribute.is_stacking and attributes)
        local attribute_type_name = attribute.type_name
        if (attributes.type_name is attribute_type_name)
          attribute.next = attributes.next
          attributes = attribute
          return
        else
          local prev = attributes
          local cur = attributes.next
          while (cur)
            if (cur.type_name is attribute_type_name)
              prev.next = attribute
              attribute.next = cur.next
              return
            endIf
            prev = cur
            cur .= next
          endWhile
        endIf
      endIf
      attribute.next = attributes
      attributes = attribute

    method after( e:KeyEvent )
      noAction

    method after( e:PointerEvent )
      noAction

    method after( e:ScrollEvent )
      noAction

    method after( e:TextEvent )
      noAction

    method after_draw
      UI.theme._dispatch_after_draw( this )

    method after_draw<<$Theme>>( theme:$Theme )  [propagated]
      # Components can override this method per-theme and draw themselves or
      # they can let the theme draw them.
      theme.after_draw( this )

    method after_update
      noAction

    method after_update_layout

    method alignment->Anchor
      # 'alignment' affects text within this component. Unlike 'anchor',
      # 'alignment' is propagated to child components until a new alignment
      # is set.
      if (attributes)
        local result = attributes.alignment
        if (result.exists) return result.value
      endIf
      if (parent) return parent.alignment
      return Anchor.TOP_LEFT

    method anchor->Anchor
      # 'anchor' affects the placement of this component.
      if (attributes) return attributes.anchor
      return Anchor.TOP_LEFT

    method attribute<<$OfType>>->$OfType
      local cur = attributes
      while (cur)
        local match = cur as $OfType
        if (match) return match
        cur .= next
      endWhile
      return null

    method attributes->UIAttribute
      return @attributes

    method bounds->Box
      return Box( position, size )

    method can_split->Logical
      return false

    method can_split( max_width:Int32 )->Logical
      return false

    method capture_keyboard_focus->Logical
      if (UI.keyboard_focus and UI.keyboard_focus is not this) return false
      UI.keyboard_focus = this
      return true

    method capture_pointer_focus->Logical
      if (UI.pointer_focus and UI.pointer_focus is not this) return false
      UI.pointer_focus = this
      return true

    method collect_components( list:UIComponent[] )
      list.add( this )

    method clip->Box
      return UI.clip.value

    method contains( e:PointerEvent )->Logical
      return contains( e.position )

    method contains( pos:XY )->Logical
      return display_bounds.contains( pos )

    method contains( component:UIComponent )->Logical
      while (component)
        if (component is this) return true
        component .= parent
      endWhile
      return false

    method contains_newline->Logical
      return false

    method content->UIComponent
      return first_child

    method content_bounds->Box
      return Box( content_position, size )

    method default_height
      # Sets this component's fixed height to be its default height after it is measured.
      flags |= FLAG_DEFAULT_HEIGHT

    method default_width
      # Sets this component's fixed width to be its default width after it is measured.
      flags |= FLAG_DEFAULT_WIDTH

    method default_size
      # Sets this component's fixed size to be its default size after it is measured.
      flags |= FLAG_DEFAULT_WIDTH | FLAG_DEFAULT_HEIGHT

    method display_bounds->Box
      return Box( display_position, size )

    method clear_modified
      (forEach in children).clear_modified
      @is_modified = false

    method content_position->XY
      # Same as display_position except adds this component's content offset()
      if (parent) return position + offset + parent.content_position
      else        return position + offset

    method dispatch( e:KeyEvent )
      # Send input events to children in reverse order because the top layer comes last
      if (next) next.dispatch( e )
      if (e.is_consumed) return
      handle( e )

    method dispatch( e:PointerEvent )
      # Send input events to children in reverse order because the top layer comes last
      if (next) next.dispatch( e )
      if (e.is_consumed) return
      handle( e )

    method dispatch( e:ScrollEvent )
      # Send input events to children in reverse order because the top layer comes last
      if (next) next.dispatch( e )
      if (e.is_consumed) return
      handle( e )

    method dispatch( e:TextEvent )
      # Send input events to children in reverse order because the top layer comes last
      if (next) next.dispatch( e )
      if (e.is_consumed) return
      handle( e )

    method display_position->XY
      if (parent) return position + parent.content_position
      else        return position

    method draw( draw_bounds:Box )
      if (not size.is_zero)
        local clip = draw_bounds & display_bounds
        if (not clip)
          return
        endIf
        draw_bounds = clip.value
      endIf

      temporarily UI.clip = draw_bounds
        on_draw
        local inner_bounds = draw_bounds & padding.apply(display_bounds)
        if (inner_bounds)
          temporarily UI.clip = inner_bounds.value
            draw_subcomponents( inner_bounds.value )
          endTemporarily
        endIf
        after_draw
      endTemporarily

    method draw_subcomponents( draw_bounds:Box )
      forEach (component in children)
        component.draw( draw_bounds )
      endForEach

    method expand_to_fill
      flags &= !(FLAG_WIDTH_MASK|FLAG_HEIGHT_MASK)  # turn off fixed and shrink flags

    method expand_to_fill_height
      flags &= !FLAG_HEIGHT_MASK  # turn off fixed and shrink flags

    method expand_to_fill_width
      flags &= !FLAG_WIDTH_MASK   # turn off fixed and shrink flags

    method find( pos:XY, &always_check_subcomponents )->UIComponent
      # The algorithm looks a little unusual because we want to find the
      # LAST child that contains 'pos'.

      if (next)
        # Recursively find the last sibling that contains 'pos'
        local result = next.find( pos, &=always_check_subcomponents )
        if (result) return result
      endIf

      if (not always_check_subcomponents and not contains(pos)) return null # Don't bother checking children

      if (first_child)
        local result = first_child.find( pos, &=always_check_subcomponents )
        if (result) return result
      endIf

      if (not always_check_subcomponents or contains(pos)) return this
      return null

    method first_element_width->Real64
      # Used to aid UIContent word wrap.
      return size.x

    method font->UIFont
      if (attributes) return attributes.font
      return UI.theme.default_font

    method handle( e:KeyEvent )
      on( e )
      if (e.is_consumed) return

      if (first_child)
        first_child.dispatch( e )
        if (e.is_consumed) return
      endIf

      after( e )

    method handle( e:PointerEvent )
      on( e )
      if (e.is_consumed) return

      if (first_child)
        first_child.dispatch( e )
        if (e.is_consumed) return
      endIf

      after( e )

    method handle( e:ScrollEvent )
      on( e )
      if (e.is_consumed) return

      if (first_child)
        first_child.dispatch( e )
        if (e.is_consumed) return
      endIf

      after( e )

    method handle( e:TextEvent )
      on( e )
      if (e.is_consumed) return

      if (first_child)
        first_child.dispatch( e )
        if (e.is_consumed) return
      endIf

      after( e )

    method has_keyboard_focus->Logical
      return (UI.keyboard_focus is this)

    method has_pointer_focus->Logical
      return (UI.pointer_focus is this)

    method height->Real64
      return size.y

    method is_expand_to_fill_height->Logical
      return not (@flags & FLAG_HEIGHT_MASK)

    method is_expand_to_fill_width->Logical
      return not (@flags & FLAG_WIDTH_MASK)

    method is_fixed_height->Logical
      return (@flags & FLAG_FIXED_HEIGHT)?

    method is_fixed_width->Logical
      return (@flags & FLAG_FIXED_WIDTH)?

    method is_shrink_to_fit_height->Logical
      return (@flags & FLAG_SHRINK_TO_FIT_HEIGHT)?

    method is_shrink_to_fit_width->Logical
      return (@flags & FLAG_SHRINK_TO_FIT_WIDTH)?

    method is_style_bold->Logical
      if (parent) return parent.is_style_bold
      return false

    method is_style_inverse->Logical
      if (parent) return parent.is_style_inverse
      return false

    method is_style_italic->Logical
      if (parent) return parent.is_style_italic
      return false

    method is_style_underline->Logical
      if (parent) return parent.is_style_underline
      return false

    method max_content_size( container_size:XY )->XY
      return container_size  # no restriction

    method measure
      on_measure

      # on_measure must have set "default_width/height/size = ..." or "size = ..."
      # for this to work correctly.
      if (flags & FLAG_DEFAULT_WIDTH)  fixed_width = size.x
      if (flags & FLAG_DEFAULT_HEIGHT) fixed_height = size.y

    method offset->XY
      return XY.zero

    method on( e:KeyEvent )
      noAction

    method on( e:PointerEvent )
      noAction

    method on( e:ScrollEvent )
      noAction

    method on( e:TextEvent )
      noAction

    method on_draw
      UI.theme._dispatch_on_draw( this )

    method on_draw<<$Theme>>( theme:$Theme )  [propagated]
      # Components can override this method per-theme and draw themselves or
      # they can let the theme draw them.
      theme.on_draw( this )

    method on_measure
      noAction

    method on_release_keyboard_focus
      noAction

    method on_release_pointer_focus
      noAction

    method on_update
      noAction

    method original_position->XY
      if (attributes) return attributes.original_position
      return XY.zero

    method operator+( rhs:UIComponent )->UIComponent
      return UILayout.h( this, rhs )

    method operator/( rhs:UIComponent )->UIComponent
      return UILayout.v( this, rhs )

    method padding->UIPadding
      if (attributes) return attributes.padding
      return UIPadding(0)

    method print_state( output=StringBuilder():StringBuilder )->StringBuilder
      output.println "$$" (type_name,which{is_modified:" [modified]"||""})
      if (count)
        output.indent += 2
        (forEach in children).print_state( output )
        output.indent -= 2
      endIf
      return output

    method release_keyboard_focus
      if (UI.keyboard_focus is this)
        UI.keyboard_focus = null
        on_release_keyboard_focus
      endIf

    method release_pointer_focus
      if (UI.pointer_focus is this)
        UI.pointer_focus = null
        on_release_pointer_focus
      endIf

    method request_redraw
      # Marks this component and its screen area as needing to be redrawn
      request_redraw( display_bounds )

    method request_redraw( redraw_bounds:Box )
      if (redraw_bounds.size.is_zero) return

      if (UI.dirty_bounds)
        UI.dirty_bounds = UI.dirty_bounds.value | redraw_bounds
      else
        UI.dirty_bounds = redraw_bounds
      endIf

    method request_layout
      is_modified = true  # class Node setter auto-propagates this up the hierarchy

    method set_alignment( alignment:Anchor )
      add( UIAttributeAlignment(alignment) )

    method set_anchor( anchor:Anchor )
      add( UIAttributeAnchor(anchor) )

    method set_attributes( @attributes )
      noAction

    method set_content( content:UIComponent )
      if (content is not first_child or count != 1)
        clear
        add content
      endIf

    method set_default_height( h:Real64 )
      if (not (flags & FLAG_HEIGHT_MASK)) size = XY( size.x, h )

    method set_default_width( w:Real64 )
      if (not (flags & FLAG_WIDTH_MASK)) size = XY( w, size.y )

    method set_default_size( new_size:XY )
      if (not (flags & FLAG_HEIGHT_MASK)) size = XY( size.x, new_size.y )
      if (not (flags & FLAG_WIDTH_MASK))  size = XY( new_size.x, size.y )

    method set_fixed_height( h:Real64 )
      flags = (flags & !FLAG_HEIGHT_MASK) | FLAG_FIXED_HEIGHT
      size = XY( size.x, h )

    method set_fixed_width( w:Real64 )
      flags = (flags & !FLAG_WIDTH_MASK) | FLAG_FIXED_WIDTH
      size = XY( w, size.y )

    method set_fixed_size( new_size:XY )
      flags = (flags & !(FLAG_WIDTH_MASK|FLAG_HEIGHT_MASK)) | FLAG_FIXED_WIDTH | FLAG_FIXED_HEIGHT
      size = new_size

    method set_font( font:UIFont )
      add( UIAttributeFont(font) )

    method set_is_modified( setting:Logical )
      if (@is_modified == setting) return
      @is_modified = setting
      if (setting)
        request_redraw
        local cur = parent
        while (cur)
          cur.@is_modified = true
          cur .= parent
        endWhile
      endIf

    method set_height( h:Real64 )
      size = XY( size.x, h )

    method set_original_position( value:XY )
      add( UIAttributeOriginalPosition(value) )

    method set_padding( value:Int32 )
      add( UIAttributePadding(UIPadding(value)) )

    method set_padding( left:Int32, top:Int32, right:Int32, bottom:Int32 )
      add( UIAttributePadding(UIPadding(left,top,right,bottom)) )

    method set_weight( w:Real64 )
      add( UIAttributeWeight(XY(w,w)) )

    method set_weight( w:XY )
      add( UIAttributeWeight(w) )

    method set_width( w:Real64 )
      size = XY( w, size.y )

    method shrink_to_fit
      shrink_to_fit_width
      shrink_to_fit_height

    method shrink_to_fit_height
      flags = (flags & !FLAG_HEIGHT_MASK) | FLAG_SHRINK_TO_FIT_HEIGHT

    method shrink_to_fit_width
      flags = (flags & !FLAG_WIDTH_MASK) | FLAG_SHRINK_TO_FIT_WIDTH

    method split( max_width:Int32, writer:ListRewriter<<UIComponent>> )
      writer.write( this )

    method text->String
      return this->String

    method to->String
      return type_name.after_any( "::" )

    method update
      on_update
      update_subcomponents
      after_update

    # Layout Infrastructure
    # ---------------------
    # update_layout_size
    #   update_subcomponent_sizes
    #   update_subcomponent_layout
    # update_layout_bounds  (positions components using sizes established above)
    method update_layout( new_bounds:Box )
      # Only called on a top-level UIComponent
      update_layout_size( new_bounds.size )
      update_layout_bounds( new_bounds )
      clear_modified

    method update_layout_bounds( new_bounds:Box )
      position = Box(size).positioned_within( new_bounds, anchor ).position.floor

    method update_layout_size( container_size:XY )
      if (not is_modified and container_size == size) return

      local padding = this.padding

      local w = which{ (flags&FLAG_FIXED_WIDTH):size.x  ||  container_size.x }
      local h = which{ (flags&FLAG_FIXED_HEIGHT):size.y ||  container_size.y }
      local inner_w = (w - padding.x).clamped_low( 0 )
      local inner_h = (h - padding.y).clamped_low( 0 )

      (forEach in children).measure
      local content_size = update_subcomponent_sizes( XY(inner_w,inner_h) )
      if (flags & (FLAG_SHRINK_TO_FIT_WIDTH|FLAG_SHRINK_TO_FIT_HEIGHT))
        if (flags & FLAG_SHRINK_TO_FIT_WIDTH)  w .= or_smaller( content_size.x+padding.y )
        if (flags & FLAG_SHRINK_TO_FIT_HEIGHT) h .= or_smaller( content_size.y+padding.x )
      endIf

      update_layout_size( XY(w,h), content_size )
      update_subcomponent_layout

    method update_layout_size( frame_size:XY, content_size:XY )
      size = frame_size.or_larger( content_size )   # overloaded by UILayout to disregard content size

    method update_subcomponent_layout
      block bounds = padding.apply(Box(size))
        forEach (component in children)
          component.update_layout_bounds( bounds )
        endForEach
      endBlock

    method update_subcomponent_sizes( container_size:XY )->XY
      # Returns minimum size to enclose all subcomponents - will vary by extended type.
      local min_size : XY
      forEach (component in children)
        component.update_layout_size( container_size )
        min_size .= or_larger( component.size )
      endForEach
      return min_size

    method update_layout( placement:UIIntervalPlacement )->UIIntervalPlacement
      return placement.placing( this )

    method update_shrink_to_fit_size
      if (flags & (FLAG_SHRINK_TO_FIT_WIDTH|FLAG_SHRINK_TO_FIT_HEIGHT))
        local max_size : XY
        max_size .= or_larger( (forEach in children).size )
        if (is_shrink_to_fit_width)  width = max_size.x
        if (is_shrink_to_fit_height) height = max_size.y
      endIf

    method update_subcomponents
      (forEach in children).update

    method width->Real64
      return size.x

    method weight->XY
      if (attributes) return attributes.weight
      return XY(1,1)

    method write_text( builder:StringBuilder )
      builder.print text

endClass

