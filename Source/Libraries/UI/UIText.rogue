module UI

class UIText : UITextComponent
  PROPERTIES
    value : String

  METHODS
    method init

    method init( value )
      if (value.count > 1 and value.contains('\n'))
        local left  = value.before_first('\n')
        local right = value.after_first('\n')
        if (String.exists(left))  add( UIText(left) )
        add( UINewline() )
        if (String.exists(right)) add( UIText(right) )
      endIf

    method init( child:UIComponent )
      value = child.text
      add( child )

    method can_split->Logical
      return value.contains(' ')

    method can_split( max_width:Int32 )->Logical
      local i = value.locate( ' ' )
      return (i and font.measure(value,0,i.value+1).x <= max_width)

    method first_element_width->Real64
      # Used to aid UIContent word wrap.
      if (value.count == 0) return 0
      return font.measure( value, 0, 1 ).x

    method on_measure [override]
      size = font.measure( value )

    method split( max_width:Int32, writer:ListRewriter<<UIComponent>> )
      local font = this.font

      local first_i = value.locate( ' ' )
      if (first_i.exists)
        forEach (i in value.count-2 downTo 0)
          local ch = value[i]
          if (ch == ' ')
            if (font.measure(value,0,i+1).x <= max_width or i == first_i.value)
              _split( i+1, writer )
              return
            endIf
          endIf
        endForEach
      else
        # Cannot split as requested. Split arbitrarily instead. Include at least
        # one character although that should already be accounted for.
        if (value.count <= 1)
          writer.write( this )
          return
        endIf

        local w = font.measure(value,0,1).x
        forEach (i in value from 1)
          local next_w = font.measure( value, i, 1 ).x
          if (w + next_w > max_width)
            local part_1 = UIText( value.leftmost(i) ).[ measure ]
            local part_2 = UIText( value.from(i) ).[ measure ]
            add( part_1 )
            add( part_2 )
            writer.write( part_1 )
            writer.write( part_2 )
            return
          else
            w += next_w
          endIf
        endForEach
      endIf

      writer.write( this )

    method _split( i:Int32, writer:ListRewriter<<UIComponent>> )
      local a = value.leftmost(i)
      local b = value.from(i)

      if (a.count)
        local part_1 = UIText(a).[ measure ]
        add( part_1 )
        writer.write( part_1 )
      endIf

      if (b.count)
        local part_2 = UIText(b).[ measure ]
        add( part_2 )
        writer.write( part_2 )
      endIf

    method text->String
      if (count) return prior.text
      else       return value

    method to->String
      if (count) return prior.to_String
      else       return "UIText($)" (value)

    method write_text( builder:StringBuilder )
      if (count)
        prior.write_text( builder )
      else
        builder.print value
      endIf
endClass

