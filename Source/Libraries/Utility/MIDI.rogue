#===================================================================================================
# MIDI.rogue
#
# June 7, 2021 by Abe Pralle
#
# REFERENCES
#   https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf
#   http://midi.teragonaudio.com/tech/midifile.htm
#   https://interglacial.com/pub/dr_midi.html
#===================================================================================================

class MIDIMusic
  PROPERTIES
    format           : Int32   # 0, 1, or 2
    is_smpte         : Logical # if walse then uses metric ticks per quarter note
    smpte_format     : Int32   # -24, -25, -29, or -30 - only valid if 'is_smpte'
    ticks            : Int32   # if 'not is_smpte' then ticks per quarter-note, else ticks per frame

    copyright_notice : String

    tracks           = MIDITrack[]
    unknown_chunks   = UnknownMIDIChunk[]

  METHODS
    method init( file:File )
      init( file.load_as_bytes )

    method init( bytes:Byte[] )
      MIDIReader( this, bytes )

endClass

class MIDIReader
  PROPERTIES
    music  : MIDIMusic
    reader : BitReader

  METHODS
    method init( music, bytes:Byte[] )
      reader = BitReader( bytes )

      read_header

      while (reader.has_another)
        read_chunk
      endWhile

    method read_chunk
      local type = read_chunk_type
      local size = reader.read_int32
      which (type)
        case "MTrk"
          read_track( size )
        others
          local chunk = UnknownMIDIChunk(type)
          local data = Byte[](size)
          loop (size) data.add( reader.read )
          chunk.data = data
          music.unknown_chunks.add( chunk )
      endWhich

    method read_chunk_type->String
      use result = StringBuilder.pool
        loop (4) result.print( Character(reader.read) )
        return result->String
      endUse

    method read_header
      require read_chunk_type == "MThd"
      local header_bytes = reader.read_int32
      require header_bytes >= 6
      music.format = reader.read(16)
      require music.format >= 0 and music.format <= 2
      reader.read(16) # Ignore track count; it can be inferred later
      music.is_smpte = reader.read(1)?
      if (music.is_smpte)
        music.smpte_format = reader.read(7) - 65536
        music.ticks = reader.read  # ticks per frame
      else
        music.ticks = reader.read(15) # ticks per quarter-note
      endIf

      # Ignore any remaining header bytes (unlikely to be any)
      loop (header_bytes - 6) reader.read

    method read_track( size:Int32 )
      local track = MIDITrack()

      local previous_event_type = MIDIEventType.NOTE_OFF : Int32
      local limit = reader.position + size
      while (reader.has_another and reader.position < limit)
        local dt = read_variable_length_value

        if (reader.peek(1)) previous_event_type = reader.read
        local event_type  = previous_event_type
        local category    = event_type & 0xF0
        local channel     = event_type & 0x0F

        which (category)
          case MIDIEventType.NOTE_OFF
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            track.events.add( MIDIEvent(category,dt,channel,note,velocity) )

          case MIDIEventType.NOTE_ON
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            track.events.add( MIDIEvent(category,dt,channel,note,velocity) )

          case MIDIEventType.AFTERTOUCH
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            track.events.add( MIDIEvent(category,dt,channel,note,velocity) )

          case MIDIEventType.CONTROL_CHANGE
            local controller = reader.read & 0x7F
            local value      = reader.read & 0x7F
            track.events.add( MIDIEvent(category,dt,channel,controller,value) )

          case MIDIEventType.PROGRAM_CHANGE
            local patch = reader.read & 0x7F
            track.events.add( MIDIEvent(category,dt,channel,patch) )

          case MIDIEventType.CHANNEL_PRESSURE
            local pressure = reader.read & 0x7F
            track.events.add( MIDIEvent(category,dt,channel,pressure) )

          case MIDIEventType.PITCH_WHEEL
            local lo    = reader.read & 0x7F
            local hi    = reader.read & 0x7F
            local delta = (hi :<<: 7) | lo
            track.events.add( MIDIEvent(category,dt,channel,delta) )

          case MIDIEventType.SYSTEM
            which (event_type)
              case MIDIEventType.SYSTEM_EXCLUSIVE
                local id = reader.read
                local data = Byte[]
                local byte = reader.read
                while (reader.has_another and byte != MIDIEventType.SYSTEM_END_OF_EXCLUSIVE->Int32)
                  data.add( byte )
                  byte = reader.read
                endWhile
                track.events.add( MIDIEvent(event_type,dt,id,&=data) )

              case MIDIEventType.SYSTEM_SONG_POSITION_POINTER
                local lo = reader.read & 0x7F
                local hi = reader.read & 0x7F
                local position = (hi :<<: 7) | lo
                track.events.add( MIDIEvent(event_type,dt,position) )

              case MIDIEventType.SYSTEM_SONG_SELECT
                local song = reader.read & 0x7F
                track.events.add( MIDIEvent(event_type,dt,song) )

              case MIDIEventType.SYSTEM_TUNE_REQUEST
                track.events.add( MIDIEvent(event_type,dt) )

              case MIDIEventType.SYSTEM_END_OF_EXCLUSIVE
                # This should never be a standalone event; it will always be handled in SYSTEM_EXCLUSIVE
                throw Error( "Unexpected 'end of exclusive' MIDI event." )

              case MIDIEventType.SYSTEM_TIMING_CLOCK
                track.events.add( MIDIEvent(event_type,dt) )

              case MIDIEventType.SYSTEM_START
                track.events.add( MIDISystemEventStart(dt) )

              case MIDIEventType.SYSTEM_CONTINUE
                track.events.add( MIDISystemEventContinue(dt) )

              case MIDIEventType.SYSTEM_STOP
                track.events.add( MIDISystemEventStop(dt) )

              case MIDIEventType.SYSTEM_ACTIVE_SENSING
                track.events.add( MIDISystemEventActiveSensing(dt) )

              case MIDIEventType.SYSTEM_META
                local meta_type = reader.read->Int32
                which (meta_type)
                  case MIDIEventType.META_SEQUENCE_NUMBER
                    # 00       Sequence Number = Track Index
                    # 02 SS SS Sequence Number
                    local n = reader.read
                    which (n)
                      case 0
                        track.sequence_number = music.tracks.count
                        track.events.add( MIDIMetaEvent(meta_type,dt) )
                      case 2
                        track.sequence_number = reader.read(16)
                        track.events.add( MIDIMetaEventSequenceNumber(dt,track.sequence_number.value) )
                      others
                        throw Error( "Unsupported Meta Sequence Number byte count: $."(n) )
                    endWhich

                  case MIDIEventType.META_TEXT
                    # Text Event
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,read_string) )

                  case MIDIEventType.META_COPYRIGHT_NOTICE
                    # Copyright Notice
                    music.copyright_notice = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,music.copyright_notice) )

                  case MIDIEventType.META_TRACK_NAME
                    # Track Name
                    track.name = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,track.name) )

                  case MIDIEventType.META_INSTRUMENT_NAME
                    local instrument_name = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,instrument_name) )

                  case MIDIEventType.META_LYRIC
                    local lyric = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,lyric) )

                  case MIDIEventType.META_MARKER
                    local marker = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,marker) )

                  case MIDIEventType.META_CUE_POINT
                    local cue_point = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,dt,cue_point) )

                  case MIDIEventType.META_CHANNEL_PREFIX
                    reader.read # byte count: 1
                    local cc = reader.read
                    track.events.add( MIDIMetaEventChannelPrefix(dt,cc) )

                  case MIDIEventType.META_MIDI_PORT
                    # MIDI Port
                    reader.read  # byte count of 1
                    local port = reader.read
                    track.events.add( MIDIMetaEventMIDIPort(dt,port) )

                  case MIDIEventType.META_END_OF_TRACK
                    # End of Track
                    reader.read  # '0'
                    track.events.add( MIDIMetaEvent(meta_type,dt) )

                  case MIDIEventType.META_TEMPO
                    # Tempo
                    reader.read  # byte count of 3
                    local tempo = reader.read(24)  # microseconds per MIDI quarter-note
                    track.events.add( MIDIMetaEventTempo(dt,tempo) )

                  case MIDIEventType.META_SMPTE_OFFSET
                    # SMPTE Offset
                    reader.read  # byte count of 5
                    local h  = reader.read
                    local m  = reader.read
                    local s  = reader.read
                    local f  = reader.read
                    local ff = reader.read
                    track.events.add( MIDIMetaEventSMPTEOffset(dt,h,m,s,f,ff) )

                  case MIDIEventType.META_TIME_SIGNATURE
                    # Time Signature
                    reader.read  # byte count of 4
                    local num    = reader.read
                    local denom  = reader.read
                    local clocks = reader.read
                    local _32nds = reader.read
                    track.events.add( MIDIMetaEventTimeSignature(dt,num,denom,clocks,_32nds) )

                  case MIDIEventType.META_KEY_SIGNATURE
                    # Key Signature
                    reader.read  # byte count of 2
                    local sf = reader.read
                    local mi = reader.read
                    track.events.add( MIDIMetaEventKeySignature(dt,sf,mi) )

                  case MIDIEventType.META_PROPRIETARY
                    local count = read_variable_length_value
                    local data = Byte[]
                    loop count
                      data.add( reader.read )
                    endLoop
                    track.events.add( MIDIEvent(meta_type,dt,&=data) )

                  others
                    throw Error( "Unhandled MIDI meta event type $."(meta_type->String(&hex,2)) )
                endWhich
              others
                throw Error( "Unhandled MIDI system event type $." (event_type->String(&binary,8)) )
            endWhich
          others
            throw Error( "Unhandled MIDI event type $xxxx." (((event_type:>>>:4)&0xF)->String(&binary,4)) )
        endWhich
      endWhile

      music.tracks.add( track )

    method read_string->String
      local n = read_variable_length_value
      use builder = StringBuilder.pool
        builder.reserve( n )
        loop (n) builder.print( Character(reader.read) )
        return builder->String
      endUse

    method read_variable_length_value->Int32
      local has_more = reader.read(1)?
      local result = reader.read(7)
      while (has_more)
        has_more = reader.read(1)?
        result = (result :<<: 7) | reader.read(7)
      endWhile
      return result
endClass

class MIDIChunk
endClass

class UnknownMIDIChunk : MIDIChunk
  PROPERTIES
    type : String
    data : Byte[]

  METHODS
    method init( type )
endClass

class MIDITrack : MIDIChunk
  PROPERTIES
    name             : String
    sequence_number  : Int32?
    events           = MIDIEvent[]
endClass

enum MIDIEventType
  # Meta events are serialized as SYSTEM_META followed by META_XYZ
  META_SEQUENCE_NUMBER         = 0x00
  META_TEXT                    = 0x01
  META_COPYRIGHT_NOTICE        = 0x02
  META_TRACK_NAME              = 0x03
  META_INSTRUMENT_NAME         = 0x04
  META_LYRIC                   = 0x05
  META_MARKER                  = 0x06
  META_CUE_POINT               = 0x07
  META_CHANNEL_PREFIX          = 0x20
  META_MIDI_PORT               = 0x21
  META_END_OF_TRACK            = 0x2F
  META_TEMPO                   = 0x51
  META_SMPTE_OFFSET            = 0x54
  META_TIME_SIGNATURE          = 0x58
  META_KEY_SIGNATURE           = 0x59
  META_PROPRIETARY             = 0x7F

  NOTE_OFF         = 0x80   # 0b1000 nnnn
  NOTE_ON          = 0x90   # 0b1001 nnnn
  AFTERTOUCH       = 0xA0   # 0b1010 nnnn
  CONTROL_CHANGE   = 0xB0   # 0b1011 nnnn
  PROGRAM_CHANGE   = 0xC0   # 0b1100 nnnn
  CHANNEL_PRESSURE = 0xD0   # 0b1101 nnnn
  PITCH_WHEEL      = 0xE0   # 0b1110 nnnn
  SYSTEM           = 0xF0   # 0b1111 xxxx

  SYSTEM_EXCLUSIVE             = 0xF0
  SYSTEM_SONG_POSITION_POINTER = 0xF2
  SYSTEM_SONG_SELECT           = 0xF3
  SYSTEM_TUNE_REQUEST          = 0xF6
  SYSTEM_END_OF_EXCLUSIVE      = 0xF7
  SYSTEM_TIMING_CLOCK          = 0xF8
  SYSTEM_START                 = 0xFA
  SYSTEM_CONTINUE              = 0xFB
  SYSTEM_STOP                  = 0xFC
  SYSTEM_ACTIVE_SENSING        = 0xFE
  SYSTEM_META                  = 0xFF  # same as SYSTEM_RESET; used in files only
  SYSTEM_RESET                 = 0xFF  # same as SYSTEM_META; used in real time
endEnum

class MIDIEvent( type:MIDIEventType, dt:Int32, charlie=0:Int32, alpha=0:Int32, beta=0:Int32, data=null:Object )
  METHODS
    method description->String
      use builder = StringBuilder.pool
        builder.print "dt:$ $" (dt->String(&hex,4),type)
        which (type)
          case MIDIEventType.CHANNEL_PRESSURE,
               MIDIEventType.PROGRAM_CHANGE
            builder.print " ch:$ v:$" (charlie->String(&hex,1),alpha->String(&hex,2))
          case MIDIEventType.AFTERTOUCH,
               MIDIEventType.CONTROL_CHANGE,
               MIDIEventType.NOTE_OFF,
               MIDIEventType.NOTE_ON
            builder.print " ch:$ k:$ v:$" (charlie->String(&hex,1),alpha->String(&hex,2),beta->String(&hex,2))
          case MIDIEventType.PITCH_WHEEL
            builder.print " ch:$ delta:$ ($)" (charlie->String(&hex,1),alpha->String(&hex),alpha-0x2000)
          case MIDIEventType.SYSTEM_EXCLUSIVE
            builder.print " id:$ data:$" (alpha->String(&hex,2),data as Byte[])
          case MIDIEventType.SYSTEM_SONG_POSITION_POINTER,
               MIDIEventType.SYSTEM_SONG_SELECT
            builder.print " v:$" (alpha->String(&hex,2))
          case MIDIEventType.SYSTEM_TUNE_REQUEST,
               MIDIEventType.SYSTEM_TIMING_CLOCK
            noAction
          case MIDIEventType.META_PROPRIETARY
            builder.print " data:$" (data as Byte[])
        endWhich
        return builder->String
      endUse
endClass

class MIDIChannelEvent : MIDIEvent
  PROPERTIES
    channel : Int32

  METHODS
    method init( type:MIDIEventType, dt:Int32, channel )
      prior.init( type->Int32 & 0xF0, dt )

    method description->String
      return "$ ch:$" (prior.description,channel->String(&hex,1))
endClass

class MIDIChannelValue7Event : MIDIChannelEvent
  PROPERTIES
    v : Int32

  METHODS
    method init( type:MIDIEventType, dt:Int32, channel:Int32, v )
      prior.init( type, dt, channel )

    method description->String
      return "$ v:$" (prior.description,v->String(&hex,2))
endClass

class MIDIEventProgramChange : MIDIChannelValue7Event
  METHODS
    method init( dt:Int32, channel:Int32, v:Int32 )
      prior.init( MIDIEventType.PROGRAM_CHANGE, dt, channel, v )
endClass

class MIDISystemEvent : MIDIEvent
endClass

class MIDISystemEvent<<$midi_event_type>> : MIDISystemEvent
  METHODS
    method init( dt:Int32 )
      prior.init( MIDIEventType.$midi_event_type, dt )
endClass

class MIDISystemEventStart : MIDISystemEvent<<SYSTEM_START>>;
class MIDISystemEventContinue : MIDISystemEvent<<SYSTEM_CONTINUE>>;
class MIDISystemEventStop : MIDISystemEvent<<SYSTEM_STOP>>;
class MIDISystemEventActiveSensing : MIDISystemEvent<<SYSTEM_ACTIVE_SENSING>>;

class MIDIMetaEvent : MIDIEvent
endClass

class MIDIMetaValue8Event : MIDIMetaEvent
  PROPERTIES
    value : Int32

  METHODS
    method init( meta_type:MIDIEventType, dt:Int32, value )
      prior.init( meta_type, dt )

    method description->String
      return "$ v:$" (prior.description,value)
endClass

class MIDIMetaEventChannelPrefix : MIDIMetaValue8Event
  METHODS
    method init( dt:Int32, value:Int32 )
      prior.init( MIDIEventType.META_CHANNEL_PREFIX, dt, value )
endClass

class MIDIMetaEventMIDIPort : MIDIMetaValue8Event
  METHODS
    method init( dt:Int32, value:Int32 )
      prior.init( MIDIEventType.META_MIDI_PORT, dt, value )
endClass

class MIDIMetaEventSequenceNumber : MIDIMetaEvent
  PROPERTIES
    value : Int32

  METHODS
    method init( dt:Int32, value )
      prior.init( MIDIEventType.META_SEQUENCE_NUMBER, dt )

    method description->String
      return "$ v:$" (prior.description,value->String(&hex,2))
endClass

class MIDIMetaEventTempo : MIDIMetaEvent
  PROPERTIES
    value : Int32

  METHODS
    method init( dt:Int32, value )
      prior.init( MIDIEventType.META_TEMPO, dt )

    method description->String
      return "$ v:$" (prior.description,value->String(&hex,3))
endClass

class MIDIMetaTextEvent : MIDIMetaEvent
  PROPERTIES
    text : String

  METHODS
    method init( meta_type:MIDIEventType, dt:Int32, text )
      prior.init( meta_type, dt )

    method description->String
      return prior.description + " " + text
endClass

class MIDIMetaEventSMPTEOffset : MIDIMetaEvent
  PROPERTIES
    h  : Int32
    m  : Int32
    s  : Int32
    f  : Int32
    ff : Int32

  METHODS
    method init( dt:Int32, h, m, s, f, ff )
      prior.init( MIDIEventType.META_SMPTE_OFFSET, dt )

    method description->String
      return "$ $:$:$:$.$" (prior.description,h.format("02"),m.format("02"),s.format("02"),f.format("02"),ff.format("02"))
endClass

class MIDIMetaEventTimeSignature : MIDIMetaEvent
  PROPERTIES
    numerator               : Int32
    denominator             : Int32
    clocks_per_quarter      : Int32
    _32nd_notes_per_quarter : Int32

  METHODS
    method init( dt:Int32, numerator, denominator, clocks_per_quarter, _32nd_notes_per_quarter )
      prior.init( MIDIEventType.META_TIME_SIGNATURE, dt )

    method description->String
      return "$ $/$, clocks:$ 32nd notes per quarter-note:$"...
        (prior.description, numerator,2^denominator, clocks_per_quarter, _32nd_notes_per_quarter)
endClass

class MIDIMetaEventKeySignature : MIDIMetaEvent
  PROPERTIES
    sf : Int32
    mi : Int32

  METHODS
    method init( dt:Int32, sf, mi )
      prior.init( MIDIEventType.META_KEY_SIGNATURE, dt )

    method description->String
      return "$: $, $ key"...
        (
          prior.description,
          which(sf){ -7:"7 flats" || -1:"1 flat" || 1:"1 sharp" || 7:"7 sharps" || 0:"key of C" || sf+"?" },
          which(mi){ 0:"major" || "minor" }
        )
endClass

