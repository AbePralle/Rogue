#===================================================================================================
# MIDI.rogue
#
# June 7, 2021 by Abe Pralle
#
# REFERENCES
#   https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf
#   http://midi.teragonaudio.com/tech/midifile.htm
#   https://interglacial.com/pub/dr_midi.html
#===================================================================================================

class MIDIMusic
  PROPERTIES
    format           : Int32   # 0, 1, or 2
    is_smpte         : Logical # if walse then uses metric ticks per quarter note
    smpte_format     : Int32   # -24, -25, -29, or -30 - only valid if 'is_smpte'
    ticks            : Int32   # if 'not is_smpte' then ticks per quarter-note, else ticks per frame

    copyright_notice : String

    tracks           = MIDITrack[]
    unknown_chunks   = UnknownMIDIChunk[]

  METHODS
    method init( file:File )
      init( file.load_as_bytes )

    method init( bytes:Byte[] )
      MIDIReader( this, bytes )

endClass

class MIDIReader
  PROPERTIES
    music  : MIDIMusic
    reader : BitReader

  METHODS
    method init( music, bytes:Byte[] )
      reader = BitReader( bytes )

      read_header

      while (reader.has_another)
        read_chunk
      endWhile

    method read_chunk
      local type = read_chunk_type
      local size = reader.read_int32
      which (type)
        case "MTrk"
          read_track( size )
        others
          local chunk = UnknownMIDIChunk(type)
          local data = Byte[](size)
          loop (size) data.add( reader.read )
          chunk.data = data
          music.unknown_chunks.add( chunk )
      endWhich

    method read_chunk_type->String
      use result = StringBuilder.pool
        loop (4) result.print( Character(reader.read) )
        return result->String
      endUse

    method read_header
      require read_chunk_type == "MThd"
      local header_bytes = reader.read_int32
      require header_bytes >= 6
      music.format = reader.read(16)
      require music.format >= 0 and music.format <= 2
      reader.read(16) # Ignore track count; it can be inferred later
      music.is_smpte = reader.read(1)?
      if (music.is_smpte)
        music.smpte_format = reader.read(7) - 65536
        music.ticks = reader.read  # ticks per frame
      else
        music.ticks = reader.read(15) # ticks per quarter-note
      endIf

      # Ignore any remaining header bytes (unlikely to be any)
      loop (header_bytes - 6) reader.read

    method read_track( size:Int32 )
      local track = MIDITrack()

      local previous_event_type = MIDIEventType.NOTE_OFF : Int32
      local limit = reader.position + size
      while (reader.position < limit)
        local delta_time = read_variable_length_value

        if (reader.peek(1)) previous_event_type = reader.read
        local event_type  = previous_event_type
        local channel = event_type & 0x0F

        local high    = (event_type :>>: 4) & 0xF
        which (high)
          case MIDIEventType.NOTE_OFF
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            println "Note Off channel:$ note:$ velocity:$" (channel,note,velocity)

          case MIDIEventType.NOTE_ON
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            println "Note On channel:$ note:$ velocity:$" (channel,note,velocity)

          case MIDIEventType.AFTERTOUCH
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            println "Aftertouch channel:$ note:$ velocity:$" (channel,note,velocity)

          case MIDIEventType.CONTROL_CHANGE
            local controller = reader.read & 0x7F
            local value      = reader.read & 0x7F
            println "Control Change channel:$ controller:$ value:$" (channel,controller,value)

          case MIDIEventType.PROGRAM_CHANGE
            local patch = reader.read & 0x7F
            println "Program Change channel:$ patch:$" (channel,patch)

          case MIDIEventType.CHANNEL_PRESSURE
            local pressure = reader.read & 0x7F
            println "Channel Pressure channel:$ pressure:$" (channel,pressure)

          case MIDIEventType.PITCH_WHEEL
            local lo    = reader.read & 0x7F
            local hi    = reader.read & 0x7F
            local delta = (hi :<<: 7) | lo
            println "Pitch Wheel channel:$ delta:$ ($)" (channel,delta->String(&hex),delta-0x2000)

          case MIDIEventType.SYSTEM
            which (event_type)
              case MIDIEventType.META
                local meta_type = reader.read
                which (meta_type)
                  case MIDIMetaEventType.SEQUENCE_NUMBER
                    # 00       Sequence Number = Track Index
                    # 02 SS SS Sequence Number
                    local n = reader.read
                    which (n)
                      case 0: track.sequence_number = music.tracks.count
                      case 2: track.sequence_number = reader.read(16)
                      others: throw Error( "Unsupported Meta Sequence Number byte count: $."(n) )
                    endWhich

                  case MIDIMetaEventType.TEXT
                    # Text Event
                    track.events.add( MIDIMetaEventText(delta_time,read_string) )

                  case MIDIMetaEventType.COPYRIGHT_NOTICE
                    # Copyright Notice
                    music.copyright_notice = read_string

                  case MIDIMetaEventType.TRACK_NAME
                    # Track Name
                    track.name = read_string
                    println "Track Name: " + track.name

                  case MIDIMetaEventType.INSTRUMENT_NAME
                    local instrument_name = read_string
                    println "Instrument Name: $" (instrument_name)

                  case MIDIMetaEventType.LYRIC
                    local lyric = read_string
                    println "Lyric: $" (lyric)

                  case MIDIMetaEventType.MARKER
                    local marker = read_string
                    println "Marker: $" (marker)

                  case MIDIMetaEventType.CUE_POINT
                    local cue_point = read_string
                    println "Cue Point: $" (cue_point)

                  case MIDIMetaEventType.CHANNEL_PREFIX
                    reader.read # byte count: 1
                    local cc = reader.read
                    println "MIDI Channel Prefix: $" (cc)

                  case MIDIMetaEventType.MIDI_PORT
                    # MIDI Port
                    reader.read  # byte count of 1
                    local port = reader.read
                    println "MIDI Port: $"( port)

                  case MIDIMetaEventType.END_OF_TRACK
                    # End of Track
                    reader.read  # '0'
                    println "End of Track"

                  case MIDIMetaEventType.TEMPO
                    # Tempo
                    reader.read  # byte count of 3
                    local tempo = reader.read(24)  # microseconds per MIDI quarter-note
                    println "Tempo: $" (tempo)

                  case MIDIMetaEventType.SMPTE_OFFSET
                    # SMPTE Offset
                    reader.read  # byte count of 5
                    local h  = reader.read
                    local m  = reader.read
                    local s  = reader.read
                    local f  = reader.read
                    local ff = reader.read
                    println "SMPTE Offset $:$:$:$.$" (h.format("02"),m.format("02"),s.format("02"),f.format("02"),ff.format("02"))

                  case MIDIMetaEventType.TIME_SIGNATURE
                    # Time Signature
                    reader.read  # byte count of 4
                    local numerator               = reader.read
                    local denominator             = reader.read
                    local clocks_per_quarter      = reader.read
                    local _32nd_notes_per_quarter = reader.read
                    println "Time Signature: $/$, $ clocks and $ 32nd notes per quarter-note"(numerator,2^denominator,
                      clocks_per_quarter, _32nd_notes_per_quarter)

                  case MIDIMetaEventType.KEY_SIGNATURE
                    # Key Signature
                    reader.read  # byte count of 2
                    local sf = reader.read
                    local mi = reader.read
                    println "Key Signature: $, $ key" (
                      which(sf){ -7:"7 flats" || -1:"1 flat" || 1:"1 sharp" || 7:"7 sharps" || 0:"key of C" || sf+"?" },
                      which(mi){ 0:"major" || "minor" }
                    )

                  case MIDIMetaEventType.PROPRIETARY
                    local count = read_variable_length_value
                    print "Proprietary Event:"
                    loop count
                      print " " + reader.read->String(&hex,2)
                    endLoop
                  others
                    throw Error( "Unhandled MIDI meta event type $."(meta_type->String(&hex,2)) )
                endWhich
              others
                throw Error( "Unhandled MIDI system event type $." (event_type->String(&binary,8)) )
            endWhich
          others
            throw Error( "Unhandled MIDI event type $xxxx." (high->String(&binary,4)) )
        endWhich
      endWhile

      music.tracks.add( track )

    method read_string->String
      local n = read_variable_length_value
      use builder = StringBuilder.pool
        builder.reserve( n )
        loop (n) builder.print( Character(reader.read) )
        return builder->String
      endUse

    method read_variable_length_value->Int32
      local has_more = reader.read(1)?
      local result = reader.read(7)
      while (has_more)
        has_more = reader.read(1)?
        result = (result :<<: 7) | reader.read(7)
      endWhile
      return result
endClass

class MIDIChunk
endClass

class UnknownMIDIChunk : MIDIChunk
  PROPERTIES
    type : String
    data : Byte[]

  METHODS
    method init( type )
endClass

class MIDITrack : MIDIChunk
  PROPERTIES
    name             : String
    sequence_number  : Int32?
    events           = MIDIEvent[]
endClass

enum MIDIEventType
  NOTE_OFF         = 0x8   # 0b1000
  NOTE_ON          = 0x9   # 0b1001
  AFTERTOUCH       = 0xA   # 0b1010
  CONTROL_CHANGE   = 0xB   # 0b1011
  PROGRAM_CHANGE   = 0xC   # 0b1100
  CHANNEL_PRESSURE = 0xD   # 0b1101
  PITCH_WHEEL      = 0xE   # 0b1110
  SYSTEM           = 0xF   # 0b1111

  META     = 0xFF
endEnum

enum MIDIMetaEventType
  SEQUENCE_NUMBER  = 0x00
  TEXT             = 0x01
  COPYRIGHT_NOTICE = 0x02
  TRACK_NAME       = 0x03
  INSTRUMENT_NAME  = 0x04
  LYRIC            = 0x05
  MARKER           = 0x06
  CUE_POINT        = 0x07
  CHANNEL_PREFIX   = 0x20
  MIDI_PORT        = 0x21
  END_OF_TRACK     = 0x2F
  TEMPO            = 0x51
  SMPTE_OFFSET     = 0x54
  TIME_SIGNATURE   = 0x58
  KEY_SIGNATURE    = 0x59
  PROPRIETARY      = 0x7F
endEnum

class MIDIEvent( delta_time:Real64 )
endClass

class MIDIMetaEvent : MIDIEvent
endClass

class MIDIMetaEventText( delta_time, text:String ) : MIDIMetaEvent
  METHODS
    method description->String
      return "$ Meta Text $" (delta_time,text)
endClass

