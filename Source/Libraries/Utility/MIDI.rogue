#===================================================================================================
# MIDI.rogue
#
# June 7, 2021 by Abe Pralle
#
# REFERENCES
#   https://www.cs.cmu.edu/~music/cmsip/readings/Standard-MIDI-file-format-updated.pdf
#   http://midi.teragonaudio.com/tech/midifile.htm
#   https://interglacial.com/pub/dr_midi.html
#===================================================================================================

class MIDIMusic
  PROPERTIES
    format           : Int32   # 0, 1, or 2
    is_smpte         : Logical # if walse then uses metric ticks per quarter note
    smpte_format     : Int32   # -24, -25, -29, or -30 - only valid if 'is_smpte'
    ticks            : Int32   # if 'not is_smpte' then ticks per quarter-note, else ticks per frame

    copyright_notice : String

    tracks           = MIDITrack[]
    unknown_chunks   = UnknownMIDIChunk[]

  METHODS
    method init( file:File )
      init( file.load_as_bytes )

    method init( bytes:Byte[] )
      MIDIReader( this, bytes )

endClass

class MIDIReader
  PROPERTIES
    music  : MIDIMusic
    reader : BitReader

  METHODS
    method init( music, bytes:Byte[] )
      reader = BitReader( bytes )

      read_header

      while (reader.has_another)
        read_chunk
      endWhile

    method read_chunk
      local type = read_chunk_type
      local size = reader.read_int32
      which (type)
        case "MTrk"
          read_track( size )
        others
          local chunk = UnknownMIDIChunk(type)
          local data = Byte[](size)
          loop (size) data.add( reader.read )
          chunk.data = data
          music.unknown_chunks.add( chunk )
      endWhich

    method read_chunk_type->String
      use result = StringBuilder.pool
        loop (4) result.print( Character(reader.read) )
        return result->String
      endUse

    method read_header
      require read_chunk_type == "MThd"
      local header_bytes = reader.read_int32
      require header_bytes >= 6
      music.format = reader.read(16)
      require music.format >= 0 and music.format <= 2
      reader.read(16) # Ignore track count; it can be inferred later
      music.is_smpte = reader.read(1)?
      if (music.is_smpte)
        music.smpte_format = reader.read(7) - 65536
        music.ticks = reader.read  # ticks per frame
      else
        music.ticks = reader.read(15) # ticks per quarter-note
      endIf

      # Ignore any remaining header bytes (unlikely to be any)
      loop (header_bytes - 6) reader.read

    method read_track( size:Int32 )
      local track = MIDITrack()

      local previous_event_type = MIDIEventType.NOTE_OFF : Int32
      local limit = reader.position + size
      while (reader.has_another and reader.position < limit)
        local delta_time = read_variable_length_value

        if (reader.peek(1)) previous_event_type = reader.read
        local event_type  = previous_event_type
        local channel     = event_type & 0x0F

        which (event_type & 0xF0)
          case MIDIEventType.NOTE_OFF
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            track.events.add( MIDIChannelEventNoteOff(delta_time,channel,note,velocity) )

          case MIDIEventType.NOTE_ON
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            track.events.add( MIDIChannelEventNoteOn(delta_time,channel,note,velocity) )

          case MIDIEventType.AFTERTOUCH
            local note     = reader.read & 0x7F
            local velocity = reader.read & 0x7F
            track.events.add( MIDIChannelEventAftertouch(delta_time,channel,note,velocity) )

          case MIDIEventType.CONTROL_CHANGE
            local controller = reader.read & 0x7F
            local value      = reader.read & 0x7F
            track.events.add( MIDIChannelEventControlChange(delta_time,channel,controller,value) )

          case MIDIEventType.PROGRAM_CHANGE
            local patch = reader.read & 0x7F
            track.events.add( MIDIEventProgramChange(delta_time,channel,patch) )

          case MIDIEventType.CHANNEL_PRESSURE
            local pressure = reader.read & 0x7F
            track.events.add( MIDIEventChannelPressure(delta_time,channel,pressure) )

          case MIDIEventType.PITCH_WHEEL
            local lo    = reader.read & 0x7F
            local hi    = reader.read & 0x7F
            local delta = (hi :<<: 7) | lo
            track.events.add( MIDIChannelEventPitchWheel(delta_time,channel,delta) )

          case MIDIEventType.SYSTEM
            which (event_type)
              case MIDIEventType.SYSTEM_EXCLUSIVE
                local id = reader.read
                local data = Byte[]
                local byte = reader.read
                while (reader.has_another and byte != MIDIEventType.SYSTEM_END_OF_EXCLUSIVE->Int32)
                  data.add( byte )
                  byte = reader.read
                endWhile
                track.events.add( MIDISystemExclusiveEvent(delta_time,id,data) )

              case MIDIEventType.SYSTEM_SONG_POSITION_POINTER
                local lo = reader.read & 0x7F
                local hi = reader.read & 0x7F
                local position = (hi :<<: 7) | lo
                track.events.add( MIDISystemEventSongPositionPointer(delta_time,position) )

              case MIDIEventType.SYSTEM_SONG_SELECT
                local song = reader.read & 0x7F
                track.events.add( MIDISystemEventSongSelect(delta_time,song) )

              case MIDIEventType.SYSTEM_TUNE_REQUEST
                track.events.add( MIDISystemEventTuneRequest(delta_time) )

              case MIDIEventType.SYSTEM_END_OF_EXCLUSIVE
                # This should never be a standalone event; it will always be handled in SYSTEM_EXCLUSIVE
                throw Error( "Unexpected 'end of exclusive' MIDI event." )

              case MIDIEventType.SYSTEM_TIMING_CLOCK
                track.events.add( MIDISystemEventTimingClock(delta_time) )

              case MIDIEventType.SYSTEM_START
                track.events.add( MIDISystemEventStart(delta_time) )

              case MIDIEventType.SYSTEM_CONTINUE
                track.events.add( MIDISystemEventContinue(delta_time) )

              case MIDIEventType.SYSTEM_STOP
                track.events.add( MIDISystemEventStop(delta_time) )

              case MIDIEventType.SYSTEM_ACTIVE_SENSING
                track.events.add( MIDISystemEventActiveSensing(delta_time) )

              case MIDIEventType.SYSTEM_META
                local meta_type = reader.read->Int32
                which (meta_type)
                  case MIDIMetaEventType.SEQUENCE_NUMBER
                    # 00       Sequence Number = Track Index
                    # 02 SS SS Sequence Number
                    local n = reader.read
                    which (n)
                      case 0
                        track.sequence_number = music.tracks.count
                        track.events.add( MIDIMetaEvent(meta_type,delta_time) )
                      case 2
                        track.sequence_number = reader.read(16)
                        track.events.add( MIDIMetaEventSequenceNumber(delta_time,track.sequence_number.value) )
                      others
                        throw Error( "Unsupported Meta Sequence Number byte count: $."(n) )
                    endWhich

                  case MIDIMetaEventType.TEXT
                    # Text Event
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,read_string) )

                  case MIDIMetaEventType.COPYRIGHT_NOTICE
                    # Copyright Notice
                    music.copyright_notice = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,music.copyright_notice) )

                  case MIDIMetaEventType.TRACK_NAME
                    # Track Name
                    track.name = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,track.name) )

                  case MIDIMetaEventType.INSTRUMENT_NAME
                    local instrument_name = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,instrument_name) )

                  case MIDIMetaEventType.LYRIC
                    local lyric = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,lyric) )

                  case MIDIMetaEventType.MARKER
                    local marker = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,marker) )

                  case MIDIMetaEventType.CUE_POINT
                    local cue_point = read_string
                    track.events.add( MIDIMetaTextEvent(meta_type,delta_time,cue_point) )

                  case MIDIMetaEventType.CHANNEL_PREFIX
                    reader.read # byte count: 1
                    local cc = reader.read
                    track.events.add( MIDIMetaEventChannelPrefix(delta_time,cc) )

                  case MIDIMetaEventType.MIDI_PORT
                    # MIDI Port
                    reader.read  # byte count of 1
                    local port = reader.read
                    track.events.add( MIDIMetaEventMIDIPort(delta_time,port) )

                  case MIDIMetaEventType.END_OF_TRACK
                    # End of Track
                    reader.read  # '0'
                    track.events.add( MIDIMetaEvent(meta_type,delta_time) )

                  case MIDIMetaEventType.TEMPO
                    # Tempo
                    reader.read  # byte count of 3
                    local tempo = reader.read(24)  # microseconds per MIDI quarter-note
                    track.events.add( MIDIMetaEventTempo(delta_time,tempo) )

                  case MIDIMetaEventType.SMPTE_OFFSET
                    # SMPTE Offset
                    reader.read  # byte count of 5
                    local h  = reader.read
                    local m  = reader.read
                    local s  = reader.read
                    local f  = reader.read
                    local ff = reader.read
                    track.events.add( MIDIMetaEventSMPTEOffset(delta_time,h,m,s,f,ff) )

                  case MIDIMetaEventType.TIME_SIGNATURE
                    # Time Signature
                    reader.read  # byte count of 4
                    local num    = reader.read
                    local denom  = reader.read
                    local clocks = reader.read
                    local _32nds = reader.read
                    track.events.add( MIDIMetaEventTimeSignature(delta_time,num,denom,clocks,_32nds) )

                  case MIDIMetaEventType.KEY_SIGNATURE
                    # Key Signature
                    reader.read  # byte count of 2
                    local sf = reader.read
                    local mi = reader.read
                    track.events.add( MIDIMetaEventKeySignature(delta_time,sf,mi) )

                  case MIDIMetaEventType.PROPRIETARY
                    local count = read_variable_length_value
                    local data = Byte[]
                    loop count
                      data.add( reader.read )
                    endLoop
                    track.events.add( MIDIMetaEventProprietary(delta_time,data) )

                  others
                    throw Error( "Unhandled MIDI meta event type $."(meta_type->String(&hex,2)) )
                endWhich
              others
                throw Error( "Unhandled MIDI system event type $." (event_type->String(&binary,8)) )
            endWhich
          others
            throw Error( "Unhandled MIDI event type $xxxx." (((event_type:>>>:4)&0xF)->String(&binary,4)) )
        endWhich
      endWhile

      music.tracks.add( track )

    method read_string->String
      local n = read_variable_length_value
      use builder = StringBuilder.pool
        builder.reserve( n )
        loop (n) builder.print( Character(reader.read) )
        return builder->String
      endUse

    method read_variable_length_value->Int32
      local has_more = reader.read(1)?
      local result = reader.read(7)
      while (has_more)
        has_more = reader.read(1)?
        result = (result :<<: 7) | reader.read(7)
      endWhile
      return result
endClass

class MIDIChunk
endClass

class UnknownMIDIChunk : MIDIChunk
  PROPERTIES
    type : String
    data : Byte[]

  METHODS
    method init( type )
endClass

class MIDITrack : MIDIChunk
  PROPERTIES
    name             : String
    sequence_number  : Int32?
    events           = MIDIEvent[]
endClass

enum MIDIEventType
  NOTE_OFF         = 0x80   # 0b1000 nnnn
  NOTE_ON          = 0x90   # 0b1001 nnnn
  AFTERTOUCH       = 0xA0   # 0b1010 nnnn
  CONTROL_CHANGE   = 0xB0   # 0b1011 nnnn
  PROGRAM_CHANGE   = 0xC0   # 0b1100 nnnn
  CHANNEL_PRESSURE = 0xD0   # 0b1101 nnnn
  PITCH_WHEEL      = 0xE0   # 0b1110 nnnn
  SYSTEM           = 0xF0   # 0b1111 xxxx

  SYSTEM_EXCLUSIVE             = 0xF0
  SYSTEM_SONG_POSITION_POINTER = 0xF2
  SYSTEM_SONG_SELECT           = 0xF3
  SYSTEM_TUNE_REQUEST          = 0xF6
  SYSTEM_END_OF_EXCLUSIVE      = 0xF7
  SYSTEM_TIMING_CLOCK          = 0xF8
  SYSTEM_START                 = 0xFA
  SYSTEM_CONTINUE              = 0xFB
  SYSTEM_STOP                  = 0xFC
  SYSTEM_ACTIVE_SENSING        = 0xFE
  SYSTEM_META                  = 0xFF  # same as SYSTEM_RESET; used in files only
  SYSTEM_RESET                 = 0xFF  # same as SYSTEM_META; used in real time
endEnum

enum MIDIMetaEventType
  SEQUENCE_NUMBER  = 0x00
  TEXT             = 0x01
  COPYRIGHT_NOTICE = 0x02
  TRACK_NAME       = 0x03
  INSTRUMENT_NAME  = 0x04
  LYRIC            = 0x05
  MARKER           = 0x06
  CUE_POINT        = 0x07
  CHANNEL_PREFIX   = 0x20
  MIDI_PORT        = 0x21
  END_OF_TRACK     = 0x2F
  TEMPO            = 0x51
  SMPTE_OFFSET     = 0x54
  TIME_SIGNATURE   = 0x58
  KEY_SIGNATURE    = 0x59
  PROPRIETARY      = 0x7F
endEnum

class MIDIEvent( type:MIDIEventType, delta_time:Int32 )
  METHODS
    method description->String
      return "dt:$ $" (delta_time->String(&hex,4),type)
endClass

class MIDIChannelEvent : MIDIEvent
  PROPERTIES
    channel : Int32

  METHODS
    method init( type:MIDIEventType, delta_time:Int32, channel )
      prior.init( type->Int32 & 0xF0, delta_time )

    method description->String
      return "$ ch:$" (prior.description,channel->String(&hex,1))
endClass

class MIDIChannelValue7Event : MIDIChannelEvent
  PROPERTIES
    v : Int32

  METHODS
    method init( type:MIDIEventType, delta_time:Int32, channel:Int32, v )
      prior.init( type, delta_time, channel )

    method description->String
      return "$ v:$" (prior.description,v->String(&hex,2))
endClass

class MIDIEventProgramChange : MIDIChannelValue7Event
  METHODS
    method init( delta_time:Int32, channel:Int32, v:Int32 )
      prior.init( MIDIEventType.PROGRAM_CHANGE, delta_time, channel, v )
endClass

class MIDIEventChannelPressure : MIDIChannelValue7Event
  METHODS
    method init( delta_time:Int32, channel:Int32, v:Int32 )
      prior.init( MIDIEventType.CHANNEL_PRESSURE, delta_time, channel, v )
endClass

class MIDIChannelValue7Value7Event : MIDIChannelEvent
  PROPERTIES
    k : Int32
    v : Int32

  METHODS
    method init( type:MIDIEventType, delta_time:Int32, channel:Int32, k, v )
      prior.init( type, delta_time, channel )

    method description->String
      return "$ k:$ v:$" (prior.description,k->String(&hex,2),v->String(&hex,2))
endClass

class MIDIChannelValue7Value7Event<<$midi_event_type>> : MIDIChannelValue7Value7Event
  METHODS
    method init( delta_time:Int32, channel:Int32, k, v )
      prior.init( MIDIEventType.$midi_event_type, delta_time, channel, k, v )
endClass

class MIDIChannelEventNoteOff : MIDIChannelValue7Value7Event<<NOTE_OFF>>;
class MIDIChannelEventNoteOn : MIDIChannelValue7Value7Event<<NOTE_ON>>;
class MIDIChannelEventAftertouch : MIDIChannelValue7Value7Event<<AFTERTOUCH>>;
class MIDIChannelEventControlChange : MIDIChannelValue7Value7Event<<CONTROL_CHANGE>>;

class MIDIChannelEventPitchWheel : MIDIChannelEvent
  PROPERTIES
    delta : Int32

  METHODS
    method init( delta_time:Int32, channel:Int32, delta )
      prior.init( MIDIEventType.PITCH_WHEEL, delta_time, channel )

    method description->String
      return "$ delta:$ ($)" (prior.description,delta->String(&hex),delta-0x2000)
endClass

class MIDISystemEvent : MIDIEvent
endClass

class MIDISystemEvent<<$midi_event_type>> : MIDISystemEvent
  METHODS
    method init( delta_time:Int32 )
      prior.init( MIDIEventType.$midi_event_type, delta_time )
endClass

class MIDISystemEventTuneRequest : MIDISystemEvent<<SYSTEM_TUNE_REQUEST>>;
class MIDISystemEventTimingClock : MIDISystemEvent<<SYSTEM_TIMING_CLOCK>>;
class MIDISystemEventStart : MIDISystemEvent<<SYSTEM_START>>;
class MIDISystemEventContinue : MIDISystemEvent<<SYSTEM_CONTINUE>>;
class MIDISystemEventStop : MIDISystemEvent<<SYSTEM_STOP>>;
class MIDISystemEventActiveSensing : MIDISystemEvent<<SYSTEM_ACTIVE_SENSING>>;

class MIDISystemExclusiveEvent : MIDISystemEvent
  PROPERTIES
    id_code : Int32
    data    : Byte[]

  METHODS
    method init( delta_time:Int32, id_code, data )
      prior.init( MIDIEventType.SYSTEM_EXCLUSIVE, delta_time )

    method description->String
      return "$ id:$ data:$" (prior.description,id_code->String(&hex,2),data)
endClass

class MIDISystemEventSongSelect : MIDISystemEvent
  PROPERTIES
    v : Int32

  METHODS
    method init( delta_time:Int32, v )
      prior.init( MIDIEventType.SYSTEM_SONG_SELECT, delta_time )

    method description->String
      return "$ v:$" (prior.description,v->String(&hex,2))
endClass

class MIDISystemEventSongPositionPointer : MIDISystemEvent
  PROPERTIES
    v : Int32

  METHODS
    method init( delta_time:Int32, v )
      prior.init( MIDIEventType.SYSTEM_SONG_POSITION_POINTER, delta_time )

    method description->String
      return "$ v:$" (prior.description,v->String(&hex,4))
endClass

class MIDIMetaEvent : MIDIEvent
  PROPERTIES
    meta_type : MIDIMetaEventType

  METHODS
    method init( meta_type, delta_time:Int32 )
      prior.init( MIDIEventType.SYSTEM_META, delta_time )

    method description->String
      return prior.description + " " + meta_type

endClass

class MIDIMetaValue8Event : MIDIMetaEvent
  PROPERTIES
    value : Int32

  METHODS
    method init( meta_type:MIDIMetaEventType, delta_time:Int32, value )
      prior.init( meta_type, delta_time )

    method description->String
      return "$ v:$" (prior.description,value)
endClass

class MIDIMetaEventChannelPrefix : MIDIMetaValue8Event
  METHODS
    method init( delta_time:Int32, value:Int32 )
      prior.init( MIDIMetaEventType.CHANNEL_PREFIX, delta_time, value )
endClass

class MIDIMetaEventMIDIPort : MIDIMetaValue8Event
  METHODS
    method init( delta_time:Int32, value:Int32 )
      prior.init( MIDIMetaEventType.MIDI_PORT, delta_time, value )
endClass

class MIDIMetaEventSequenceNumber : MIDIMetaEvent
  PROPERTIES
    value : Int32

  METHODS
    method init( delta_time:Int32, value )
      prior.init( MIDIMetaEventType.SEQUENCE_NUMBER, delta_time )

    method description->String
      return "$ v:$" (prior.description,value->String(&hex,2))
endClass

class MIDIMetaEventTempo : MIDIMetaEvent
  PROPERTIES
    value : Int32

  METHODS
    method init( delta_time:Int32, value )
      prior.init( MIDIMetaEventType.TEMPO, delta_time )

    method description->String
      return "$ v:$" (prior.description,value->String(&hex,3))
endClass

class MIDIMetaTextEvent : MIDIMetaEvent
  PROPERTIES
    text : String

  METHODS
    method init( meta_type:MIDIMetaEventType, delta_time:Int32, text )
      prior.init( meta_type, delta_time )

    method description->String
      return prior.description + " " + text
endClass

class MIDIMetaEventSMPTEOffset : MIDIMetaEvent
  PROPERTIES
    h  : Int32
    m  : Int32
    s  : Int32
    f  : Int32
    ff : Int32

  METHODS
    method init( delta_time:Int32, h, m, s, f, ff )
      prior.init( MIDIMetaEventType.SMPTE_OFFSET, delta_time )

    method description->String
      return "$ $:$:$:$.$" (prior.description,h.format("02"),m.format("02"),s.format("02"),f.format("02"),ff.format("02"))
endClass

class MIDIMetaEventTimeSignature : MIDIMetaEvent
  PROPERTIES
    numerator               : Int32
    denominator             : Int32
    clocks_per_quarter      : Int32
    _32nd_notes_per_quarter : Int32

  METHODS
    method init( delta_time:Int32, numerator, denominator, clocks_per_quarter, _32nd_notes_per_quarter )
      prior.init( MIDIMetaEventType.TIME_SIGNATURE, delta_time )

    method description->String
      return "$ $/$, clocks:$ 32nd notes per quarter-note:$"...
        (prior.description, numerator,2^denominator, clocks_per_quarter, _32nd_notes_per_quarter)
endClass

class MIDIMetaEventKeySignature : MIDIMetaEvent
  PROPERTIES
    sf : Int32
    mi : Int32

  METHODS
    method init( delta_time:Int32, sf, mi )
      prior.init( MIDIMetaEventType.KEY_SIGNATURE, delta_time )

    method description->String
      return "$: $, $ key"...
        (
          prior.description,
          which(sf){ -7:"7 flats" || -1:"1 flat" || 1:"1 sharp" || 7:"7 sharps" || 0:"key of C" || sf+"?" },
          which(mi){ 0:"major" || "minor" }
        )
endClass

class MIDIMetaEventProprietary : MIDIMetaEvent
  PROPERTIES
    data : Byte[]

  METHODS
    method init( delta_time:Int32, data )
      prior.init( MIDIMetaEventType.PROPRIETARY, delta_time )

    method description->String
      return "$ data:$" (prior.description,data)
endClass

