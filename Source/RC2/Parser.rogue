$include "Tokenizer.rogue"
$include "TokenReader.rogue"

class Parser
  PROPERTIES
    reader : TokenReader

  METHODS
    method init( filepath:String )
      println "Parsing $..." (filepath)
      reader = TokenReader( Tokenizer(filepath).tokenize )

    method consume( token_type:Integer )->Logical
      if (reader.peek.type != token_type) return false
      reader.read
      return true

    method consume_end_cmds->Logical
      local success = false
      while (consume(TokenType.EOL) or consume(TokenType.SYMBOL_SEMICOLON))
        success = true
      endWhile
      return success

    method must_consume( token_type:Integer )
      if (consume(token_type)) return
      local t = reader.peek
      throw reader.peek.error( "Expected $, found $." ...
        (Token.describe(token_type),t.describe) )
      
    method must_consume_end_cmds
      if (not consume_end_cmds) must_consume( TokenType.EOL )

    method next_is_statement->Logical
      return (peek.type >= TokenType.STATEMENT_LEVEL_TOKENS)

    method parse_elements
      while (not consume(TokenType.EOI))
        parse_multi_line_commands( Program.immediate_commands )
      endWhile

    method parse_multi_line_commands( list:CmdStatementList )
      consume_end_cmds
      while (next_is_statement)
        local cmd = parse_statement
        if (cmd) list.add( cmd )
        must_consume_end_cmds
      endWhile

    method parse_statement->Cmd
      local t = peek

      if (consume(TokenType.KEYWORD_GLOBAL))
        local t2 = peek
        local name = read_identifier

        must_consume( TokenType.SYMBOL_COLON )
        local type = parse_type

        local existing = Program.global_lookup[ name ]
        if (existing)
          throw t.error( //A global named "$" already exists at line $ of $.// (name,existing.t.line,existing.t.filepath) )
        endIf

        local global_info = GlobalVar( t, name, type )
        return CmdDeclareGlobal( t, global_info )

      elseIf (consume(TokenType.KEYWORD_LOG))
        local operand=null : Cmd
        if (not consume_end_cmds)
          operand = parse_expression
        endIf
        return CmdLog( t, operand )
      endIf

      local expression = parse_expression
      return expression

    method parse_expression->Cmd
      return parse_add_or_subtract

    method parse_add_or_subtract( left=null:Cmd )->Cmd
      if (left)
        local t = peek
        if (consume(TokenType.SYMBOL_PLUS))
          return parse_add_or_subtract( CmdAdd(t,left,parse_term) )
        endIf
        return left
      else
        return parse_add_or_subtract( parse_term )
      endIf

    method parse_term->Cmd
      local t = reader.read

      which (t.type)
        case TokenType.LITERAL_INTEGER
          return CmdLiteralInteger( t, (t as LiteralIntegerToken).value )

        case TokenType.LITERAL_REAL
          return CmdLiteralReal( t, (t as LiteralRealToken).value )

        case TokenType.LITERAL_STRING
          return CmdLiteralString( t, (t as LiteralStringToken).value )
      endWhich

      throw t.error( "Unexpected $." (t.describe) )

    method parse_type->Type
      local t = peek
      local name = read_identifier
      return Program.acquire_type( t, name )

    method peek->Token
      return reader.peek

    method read_identifier->String
      local t = peek
      must_consume( TokenType.IDENTIFIER )
      return t->String

endClass

