$include "Augment.rogue"

class Program [requisite singleton]
  PROPERTIES
    code_prefix  = "Rogue"
    program_name = "Rogue_program"

    unique_integer : Integer

    template_list   = Template[]                 : Template[]
    template_lookup = Table<<String,Template>>() : Table<<String,Template>>

    augment_lookup = Table<<String,Augment[]>>()

    first_filepath           = ""
    m_on_launch              : Method

    type_list       = Type[]                 : Type[]
    type_lookup     = Table<<String,Type>>() : Table<<String,Type>>

    type_null        : Type
    type_Real        : Type
    type_Real32       : Type
    type_Long        : Type
    type_Integer     : Type
    type_Character   : Type
    type_Byte        : Type
    type_Logical     : Type

    type_Object      : Type
    type_String      : Type
    type_NativeArray : Type
    type_GenericList : Type
    type_Global      : Type
    type_Error       : Type

    type_StringBuilder : Type
    type_FileReader    : Type
    type_FileWriter    : Type

    literal_string_lookup = Table<<String,Integer>>() : Table<<String,Integer>>
    literal_string_list   = String[]

    string_buffer = StringBuilder()

  METHODS
    method configure
      type_null          = create_built_in_type( "null",      Attribute.is_native | Attribute.is_class )
      type_Real          = create_built_in_type( "Real",      Attribute.is_native | Attribute.is_primitive )
      type_Real32         = create_built_in_type( "Real32",     Attribute.is_native | Attribute.is_primitive )
      type_Long          = create_built_in_type( "Long",      Attribute.is_native | Attribute.is_primitive )
      type_Integer       = create_built_in_type( "Integer",   Attribute.is_native | Attribute.is_primitive )
      type_Character     = create_built_in_type( "Character", Attribute.is_native | Attribute.is_primitive )
      type_Byte          = create_built_in_type( "Byte",      Attribute.is_native | Attribute.is_primitive )
      type_Logical       = create_built_in_type( "Logical",   Attribute.is_native | Attribute.is_primitive )

      type_Object        = create_built_in_type( "Object", Attribute.is_native | Attribute.is_class )
      type_String        = create_built_in_type( "String", Attribute.is_native | Attribute.is_class | Attribute.is_functional )
      type_StringBuilder = create_built_in_type( "StringBuilder", Attribute.is_class )
      type_NativeArray   = create_built_in_type( "NativeArray", Attribute.is_native | Attribute.is_class )
      type_GenericList   = create_built_in_type( "GenericList", Attribute.is_class )
      type_Global        = create_built_in_type( "Global", Attribute.is_class )
      type_Error         = create_built_in_type( "Error", Attribute.is_class )

      type_FileReader    = create_built_in_type( "FileReader", Attribute.is_class | Attribute.is_native )
      type_FileWriter    = create_built_in_type( "FileWriter", Attribute.is_class | Attribute.is_native )

      type_Object.simplify_name = true
      type_String.simplify_name = true
      type_StringBuilder.simplify_name = true
      type_FileReader.simplify_name = true
      type_FileWriter.simplify_name = true

      type_null.organized = true
      type_null.defined   = true

      # Ensure that "" is the first literal string
      literal_string_list.add( "" )
      literal_string_lookup[ "" ] = 0

    method create_unique_id->String
      return "_auto_" + next_unique_integer

    method next_unique_integer->Integer
      ++unique_integer
      return unique_integer - 1

    method find_template( name:String )->Template
      which (name.last)
        case '?'
          if (find_type(name.leftmost(-1))) return template_lookup[ "Optional" ]
          else return null
        case ']'
          return template_lookup[ "List" ]
        others
          return template_lookup[ name.before_first('<') ]
      endWhich

    method find_type( name:String )->Type
      local type = type_lookup[ name ]
      if (type) return type

      local template = find_template( name )
      if (template)
        type = Type( template.t, name )
        type_lookup[name] = type
        return type
      endIf

      return null

    method get_type_reference( t:Token, name:String )->Type
      local type = type_lookup[ name ]
      if (type) return type

      type = Type( t, name )
      type_lookup[name] = type

      return type

    method get_callback_type_signature( parameter_types:Type[] )->String
      string_buffer.clear.print( "(" )
      if (parameter_types)
        local first = true
        forEach (type in parameter_types)
          if (first) first = false
          else       string_buffer.print( ',' )
          string_buffer.print( type.name )
        endForEach
      endIf
      string_buffer.print( ')' )
      return string_buffer->String

    method get_callback_type_reference( t:Token, parameter_types:Type[], return_type:Type )->Type
      local name = "Callback" + get_callback_type_signature( parameter_types )
      if (return_type) name += "->" + return_type.name

      local type = get_type_reference( t, name )
      if (type.defined) return type

      type.defined = true
      type.attributes.add( Attribute.is_class )
      local m_call = type.add_method( t, "call" )
      if (parameter_types)
        forEach (i of parameter_types) m_call.add_parameter( t, "param"+(i+1), parameter_types[i] )
      endIf
      if (return_type)
        m_call.return_type = return_type
        m_call.statements.add( CmdReturn(t,return_type.create_default_value(t)) )
      endIf

      return type

    method create_built_in_type( name:String, attributes=0:Integer )->Type
      local t = TokenType("Internal").create_token( "[Built-in Type]", 0, 0 )
      local type = get_type_reference( t, name )
      type.attributes.add( attributes )
      return type

    method resolve
      if (m_on_launch) type_Global.add_method( m_on_launch )
      else             m_on_launch = type_Global.add_method( type_Global.t, "on_launch" )
      m_on_launch.statements.add( m_on_launch.begin_label(m_on_launch.t,"append",false) )
      m_on_launch.attributes.add( Attribute.is_requisite )

      type_null.resolve
      type_Real.resolve
      type_Real32.resolve
      type_Long.resolve
      type_Integer.resolve
      type_Character.resolve
      type_Byte.resolve
      type_Logical.resolve
      type_Global.resolve
      type_Error.resolve

      type_Object.resolve
      type_NativeArray.resolve
      type_GenericList.resolve
      type_String.resolve

      #{
      local type_CharacterList = find_type( "Character[]" )
      if (type_CharacterList)
        #type_CharacterList
      endIf
      }#


      # Reference and resolve all requisite type templates
      forEach (templ in template_list)
        if ((templ.attributes.flags & Attribute.is_requisite) and not templ.type_parameters)
          get_type_reference( templ.t, templ.name ).resolve
        endIf
      endForEach

      local i = 0
      while (i < type_list.count)
        type_list[i].resolve
        ++i
      endWhile

      # trace used code
      forEach (type in type_list)
        #if (type.is_requisite)
          type.trace_used_code
          forEach (r in type.routine_list) r.trace_used_code
          forEach (m in type.method_list)  m.trace_used_code
        #endIf
      endForEach

endClass

