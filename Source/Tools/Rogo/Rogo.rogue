#$ ROGUEC       = roguec
#$ ROGUEC_ARGS  = --whatever
#$ CPP          = g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof
#$ CPP_ARGS     = -a -b -c
#$ LIBRARIES    = libalpha
#$ LIBRARIES    = libbeta(library-name)
#$ LIBRARIES    = libfreetype6-dev(freetype2)
#$ LINK         = -lalpha -lbeta
#$ DEPENDENCIES = Library/Rogue/**/*.rogue

# Build.rogue source replacements - the libraries should also be declared in #$ LIBRARIES:
#   $LIBRARY_FLAGS(lib1,lib2) -> -Ipath/to/lib1/include -Lpath/to/lib1/library -I ...

File.create_folder( ".rogo" )
global cache_filepath = ".rogo/Cache-$.json" (System.os)
global config = @{ roguec:"roguec", filepath:cache_filepath }
global cache  = JSON.load_table( File(cache_filepath) ) : Value
global is_cache_modified : Logical

local compiler_invocation : String
native @|#if defined(DEFAULT_CXX)
        |  $compiler_invocation = RogueString_create_from_utf8( DEFAULT_CXX );
        |#else
           which (System.os)
             case "Windows"
               compiler_invocation = "cl /EHsc /nologo"
             others
               compiler_invocation = "g++ -Wall -std=gnu++11 -fno-strict-aliasing -Wno-invalid-offsetof"
           endWhich
native @|#endif

config//cpp = compiler_invocation

local buildfiles = Files( "." )

local should_create = false
local buildfile : String
local cmd_line_args = String[]
forEach (arg in System.command_line_arguments)
  if (arg == "--build" or arg.begins_with("--build="))
    local cur_buildfile = arg.after_first( '=' )
    if (cur_buildfile.count == 0)
      Console.error.println ''ERROR: expected filename after "--build=".''
      System.exit 1
    endIf
    if (not File.exists(cur_buildfile))
      if (File.exists(cur_buildfile + ".rogue"))
        cur_buildfile += ".rogue"
      else
        Console.error.println ''ERROR: no such file "$".'' (cur_buildfile)
        System.exit 1
      endIf
    endIf
    buildfiles.add( cur_buildfile )
    if (buildfile is null) buildfile = cur_buildfile

  else
    if (arg == "--create") should_create = true
    cmd_line_args.add( arg )
  endIf

endForEach

if (not buildfile)
  if (File.exists("Build.rogue")) buildfiles.add( "Build.rogue" )
  if (File.exists("BuildCore.rogue")) buildfiles.add( "BuildCore.rogue" )
  if (File.exists("BuildLocal.rogue")) buildfiles.add( "BuildLocal.rogue" )
endIf

if (not buildfiles.count)
  if (should_create)
    println "Creating Build.rogue with default Rogo framework."
    cmd_line_args.clear

    File.save( "Build.rogue",
      @|# To run this build file, install Rogue from github.com/AbePralle/Rogue and type "rogo" at the command line.
       |
       |# Rogo is a "build your own build system" facilitator. At its core Rogo just recompiles build files if
       |# needed and then runs the build executable while forwarding any command line arguments. This file contains
       |# a default framework which uses introspection to turn command line arguments into parameterized routine calls.
       |
       |# Example: to handle the command "rogo abc xyz 5", define "routine rogo_abc_xyz( n:Int32 )".
       |
       |# "rogo_default" will run in the absence of any other command line argument.
       |
       |routine rogo_default
       |  rogo_help
       |endRoutine
       |
       |routine execute( commands:String, &suppress_error )->Logical
       |  forEach (cmd in LineReader(commands))
       |    print( "> " ).println( cmd )
       |    if (System.run(cmd) != 0)
       |      if (suppress_error) return false
       |      else                throw Error( "Build failed." )
       |    endIf
       |  endForEach
       |  return true
       |endRoutine
       |
       |#------------------------------------------------------------------------------
       |# Introspection-based Launcher Framework
       |#------------------------------------------------------------------------------
       |routine syntax( command:String, text:String )
       |  Build.rogo_syntax[ command ] = text
       |endRoutine
       |
       |routine description( command:String, text:String )
       |  Build.rogo_descriptions[ command ] = text
       |endRoutine
       |
       |routine help( command:String, description=null:String, syntax=null:String )
       |  if (description) Global.description( command, description )
       |  if (syntax)      Global.syntax( command, syntax )
       |endRoutine
       |
       |try
       |  Build.launch
       |catch (err:Error)
       |  Build.rogo_error = err
       |  Build.on_error
       |endTry
       |
       |class Build [singleton]
       |  PROPERTIES
       |    rogo_syntax         = StringTable<<String>>()
       |    rogo_descriptions   = StringTable<<String>>()
       |    rogo_prefix         = ?:{ $moduleName.count:$moduleName "::" || "" } + "rogo_" : String
       |    rogo_command        = "default"
       |    rogo_args           = @[]
       |    rogo_error          : Error
       |
       |    LOCAL_DEFS_FILE     = "Local.mk"
       |
       |  METHODS
       |    method launch
       |      rogo_args.add( forEach in System.command_line_arguments )
       |      read_defs
       |      on_launch
       |      parse_args
       |      dispatch_command
       |
       |    method dispatch_command
       |      local m = find_command( rogo_command )
       |      require m
       |
       |      local args = @[]
       |      forEach (arg in rogo_args)
       |        which (arg)
       |          case "true":  args.add( true )
       |          case "false": args.add( false )
       |          case "null":  args.add( NullValue )
       |          others:       args.add( arg )
       |        endWhich
       |      endForEach
       |      if (m.parameter_count == 1 and args.count > 1) args = @[ args ] # Wrap args in a ValueList.
       |      m.call( Global, args )
       |
       |    method find_command( name:String )->MethodInfo
       |      return <<Global>>.find_method( rogo_prefix + name )
       |
       |    method on_error
       |      Console.error.println rogo_error
       |      on_exit
       |      System.exit 1
       |
       |    method on_command_found
       |      noAction
       |
       |    method on_command_not_found
       |      println "=" * 79
       |      println "ERROR: No such command '$'." (rogo_args.first)
       |      println "=" * 79
       |      println
       |      rogo_command = "help"
       |      rogo_args.clear
       |      on_command_found
       |
       |    method on_launch
       |      noAction
       |
       |    method on_exit
       |      noAction
       |
       |    method parse_args
       |      block
       |        if (rogo_args.count)
       |          local parts = String[]
       |          parts.add( forEach in rogo_args )
       |          rogo_args.clear
       |
       |          while (parts.count)
       |            local cmd = _join( parts )
       |            if (find_command(cmd))
       |              rogo_command = cmd
       |              on_command_found
       |              escapeBlock
       |            endIf
       |            rogo_args.insert( parts.remove_last )
       |          endWhile
       |
       |          on_command_not_found
       |        endIf
       |
       |        # Use default command
       |        on_command_found
       |      endBlock
       |
       |    method read_defs
       |      read_defs( LOCAL_DEFS_FILE )
       |
       |    method read_defs( defs_filepath:String )
       |      # Attempt to read defs from Local.mk
       |      local overrides = String[]
       |      if (File.exists(defs_filepath))
       |        forEach (line in LineReader(File(defs_filepath)))
       |          if (line.contains("="))
       |            local name  = line.before_first('=').trimmed
       |            local value = line.after_first('=').trimmed
       |            if (value.begins_with('"') or value.begins_with('\''))
       |              value = value.leftmost(-1).rightmost(-1)
       |            endIf
       |            local p = <<Build>>.find_property( name )
       |            if (p)
       |              overrides.add( "$ = $" (name,value) )
       |              <<Build>>.set_property( this, p, Value(value) )
       |            endIf
       |          endIf
       |        endForEach
       |      endIf
       |
       |    method _join( value:Value )->String
       |      local args = String[]
       |      args.add( forEach in value )
       |      return args.join( "_" )
       |endClass
       |
       |
       |routine rogo_help( command="":String )
       |  command = Build._join( Build.rogo_args )
       |  if (command.count)
       |    local syntax = get_syntax( command )
       |    local success = false
       |    if (syntax)
       |      println "SYNTAX"
       |      println "  " + syntax
       |      println
       |      success = true
       |    endIf
       |    local description = get_description( command )
       |    if (description)
       |      println "DESCRIPTION"
       |      forEach (line in LineReader(description.word_wrapped(76)))
       |        print( "  " ).println( line )
       |      endForEach
       |      println
       |      success = true
       |    endIf
       |    if (success)
       |      return
       |    else
       |      println "=" * 79
       |      println "ERROR: No such command '$'." (command)
       |      println "=" * 79
       |      println
       |    endIf
       |  endIf
       |
       |  println "USAGE"
       |  local lines = String[]
       |  forEach (m in <<Global>>.methods)
       |    if (m.name.begins_with(Build.rogo_prefix))
       |      lines.add( "  " + get_syntax(m.name.after_first(Build.rogo_prefix)) )
       |    endIf
       |  endForEach
       |  lines.sort( (a,b)=>(a<b) )
       |  println (forEach in lines)
       |  println
       |endRoutine
       |
       |
       |routine get_syntax( m_name:String )->String
       |  if (Build.rogo_syntax.contains(m_name))
       |    return "rogo " + Build.rogo_syntax[ m_name ]
       |  else
       |    local m = <<Global>>.find_method( Build.rogo_prefix + m_name )
       |    if (not m) return null
       |    local line = "rogo $" (m_name.replacing('_',' '))
       |    line += " <$>" (m.parameter_name(forEach in 0..<m.parameter_count))
       |    return line
       |  endIf
       |endRoutine
       |
       |
       |routine get_description( m_name:String )->String
       |  if (Build.rogo_descriptions.contains(m_name))
       |    return Build.rogo_descriptions[ m_name ]
       |  else
       |    return null
       |  endIf
       |endRoutine
    )
    buildfiles.add( "Build.rogue" )

  else
    local w = (Console.width - 1).or_smaller( 79 )
    loop (w) do Console.error.print( '=' )
    Console.error.println
    local mesg = "ROGO ERROR\n\n"
    mesg += @|No standard build file exists (Build.rogue, BuildCore.rogue, BuildLocal.rogue)
    mesg += @| and no alternate specified with --build=<filename>.
             |
             |
    mesg += @|Type 'rogo --create' to create Build.rogue with a default framework.
    Console.error.println( mesg.word_wrapped(w) )
    loop (w) do Console.error.print( '=' )
    Console.error.println
    System.exit 1
  endIf
endIf

local exe : String
if (buildfile is null)
  buildfile = buildfiles[0]
  exe = ".rogo$Build" (File.separator)
else
  exe = ".rogo$$" (File.separator,File.filename(buildfile).before_first('.'))
endIf
local base_name = exe   # e.g. Build
if (System.os == "Windows") exe += ".exe"
else                        exe += "-" + System.os  # e.g. Build-macOS

install_library_manager

local needs_recompile = buildfiles.any_newer_than( exe )
block
  local dependencies = StringLookupList()
  scan_and_rewrite( File(forEach in buildfiles), dependencies, &skip_rewrite, &dependencies_only )

  local i = 0
  while (i < dependencies.count)
    local pattern = dependencies[ i ]
    local listing = File.listing( pattern, &files )
    forEach (dependency in listing)
      if (File.filename(dependency).begins_with("Build") and not buildfiles.contains(dependency))
        scan_and_rewrite( dependency, dependencies, &skip_rewrite )
      endIf
    endForEach
    ++i
  endWhile

  forEach (pattern in dependencies)
    local listing = File.listing( pattern, &files )
    forEach (dependency in listing)
      if (File.is_newer_than(dependency,exe))
        needs_recompile = true
        escapeBlock
      endIf
    endForEach
  endForEach
endBlock

if (needs_recompile)
  println "Recompiling $..." (buildfile)

  # Collect info for config
  scan_and_rewrite( File(forEach in buildfiles), &skip_rewrite )

  # Select ROGUEC(macOS) or ROGUEC(Linux) etc. based on the OS and copy to ROGUEC, etc.
  local os_arg = "($)" (System.os.to_lowercase)
  forEach (key in config.keys)
    if (key.contains(os_arg))
      config[ key.before_first(os_arg) ] = config[ key ]
    endIf
  endForEach

  # Now that we have the config info, rewriting to handle $ LIBRARY(name) etc. Places copies in .rogo/
  scan_and_rewrite( File(forEach in buildfiles), &skip_directives )

  local roguec = config//roguec
  if (not File.exists(roguec)) roguec = "roguec"  # use system default
  local roguec_args = config//roguec_args->String
  local cmd =  "$ --target=C++,Console,$" (roguec,System.os)
  cmd += " .rogo$$" (File.separator,File.filename(forEach in buildfiles))
  cmd += " --api --debug --main --output=$ $" (base_name,roguec_args)
  println cmd
  if (0 != System.run(cmd))
    Console.error.println "ERROR compiling $." (buildfile)
    System.exit 1
  endIf

  cmd = "$ $ $.cpp" (config//cpp,config//cpp_args,base_name)

  local is_windows = (System.os == "Windows")

  forEach (library in config//libraries)
    install_library( library )

    # Linux generally doesn't need to specify include paths and library paths
    # but occasionally it does (libfreetype)
    cmd += " $" (library_flags(library))
  endForEach

  cmd += " $$ $" (?:{is_windows:"/Fe"||"-o "},exe,config//link)

  println cmd
  if (0 != System.run(cmd)) System.exit( 1 )
  File.delete( File.filename(exe).before_last(".exe") + ".obj" )
endIf

System.exit( System.run(''$ $'' (exe,cmd_line_args.mapped<<String>>( (arg)=>prep_arg(arg) ).join(" "))) )

routine prep_arg( arg:String )->String
  # Quotes and escapes string if necessary
  if (not (arg.contains(' ') or arg.contains('"') or arg.contains('\\'))) return arg
  local quoted = StringBuilder()
  quoted.print( '"' )
  forEach (ch in arg)
    which (ch)
      case '"':  quoted.print( "\\\"" )
      case '\\': quoted.print( "\\\\" )
      others:    quoted.print( ch )
    endWhich
  endForEach
  quoted.print( '"' )
  return quoted
endRoutine

routine require_command_line
  if (System.environment["IDE"])
    throw Error( "$:$: error:Run 'make $' from the command line to install necessary libraries."...
    ($sourceFilepath,$sourceLine,select{System.environment["TARGET"]||""}.to_lowercase) )
  endIf
endRoutine


routine save_cache
  is_cache_modified = false
  cache.save( File(cache_filepath), &formatted )
endRoutine

routine install_library_manager
  which (System.os)
    case "macOS"
      install_brew
    case "Linux"
      install_ubuntu_pkg_config
  endWhich
endRoutine

routine install_brew
  if (0 != System.run("which brew > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "\nHomebrew must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install Homebrew." )
      endIf
    else
      throw Error( "Missing required dependency 'brew' (Homebrew)." )
    endIf

  endIf

  if (0 != System.run("which pkg-config > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|brew install pkg-config
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install pkg-config." )
      endIf
    else
      throw Error( "Missing required dependency 'pkg-config'." )
    endIf

  endIf
endRoutine

routine install_ubuntu_pkg_config
  if (0 != System.run("which pkg-config > /dev/null 2>&1"))
    require_command_line
    if (Console.input( "pkg-config must be installed.  Install now (y/n)? " ).to_lowercase.begins_with('y'))
      local cmd = @|sudo apt-get install pkg-config
      println cmd
      if (0 != System.run(cmd))
        throw Error( "Failed to install pkg-config." )
      endIf
    else
      throw Error( "Missing required dependency 'pkg-config'." )
    endIf

  endIf
endRoutine

routine install_library( library:Value )
  local lib = cache//installed_libraries[ library//name ]
  if (lib) return

  which (System.os)
    case "macOS"
      install_macos_library( library )
    case "Linux"
      install_ubuntu_library( library )
    others
      throw Error( ''Rogo does not know how to install a library for "$".'' (System.os) )
  endWhich
endRoutine

routine install_macos_library( library:Value )
  local library_name = library//name->String
  local package = library//package->String

  local performed_install = false
  println "Checking for library $..." (library_name)
  local cmd = ''brew list $ > /dev/null 2>&1'' (library_name)
  print("  ").println(cmd).flush
  if (0 != System.run(cmd))
    # Install library
    require_command_line
    if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
      throw Error( "Missing required library '$'." (library_name) )
    endIf

    # Two install options:
    #   libname                 - install libname
    #   libname(install:"cmd")  - install cmd
    local install_cmd = library//name
    if (library.contains("install")) install_cmd = library//install

    cmd = "brew install $" (install_cmd)
    println cmd
    if (0 != System.run(cmd))
      throw Error( "Failed to install library '$'." (library_name) )
    endIf

    performed_install = true
  endIf

  if (not performed_install)
    println "Finding $ library..." (library_name)
  endIf

  # Save location in cache
  local library_flags : String
  local result = Process.run( "pkg-config --cflags --libs " + package )
  if (result.exit_code == 0)
    library_flags = result.output_string.trimmed
    println "  Library flags: $" (library_flags)
  endIf

  if (library_flags)
    cache.ensure_table("installed_libraries")[ library_name ] = true
    save_cache
  else
    throw Error( "Library not installed: '$'." (library_name) )
  endIf

endRoutine

routine install_ubuntu_library( library:Value )
  local library_name = library//name->String
  local package = library//package->String

  local performed_install = false
  println "Checking for library $..." (library_name)
  local cmd = ''dpkg -L $ > /dev/null 2>&1'' (library_name)
  print("  ").println(cmd).flush
  if (0 != System.run(cmd))
    # Install library
    require_command_line
    if (not Console.input( "\nLibrary '$' must be installed.  Install now (y/n)? "(library_name) ).to_lowercase.begins_with('y'))
      throw Error( "Missing required library '$'." (library_name) )
    endIf

    # Two install options:
    #   libname                 - install libname
    #   libname(install:"cmd")  - install cmd
    local install_cmd = library//name
    if (library.contains("install")) install_cmd = library//install

    cmd = "sudo apt-get install $" (install_cmd)
    println cmd
    if (0 != System.run(cmd))
      throw Error( "Failed to install library '$'." (library_name) )
    endIf

    performed_install = true
  endIf

  if (not performed_install)
    println "Finding $ library..." (library_name)
  endIf

  # Save location in cache
  local library_flags : String
  local result = Process.run( "pkg-config --cflags " + package )
  result = Process.run( "pkg-config --cflags --libs " + package )
  if (result.exit_code == 0)
    library_flags = result.output_string.trimmed
    println "  Library flags: $" (library_flags)
  endIf

  if (library_flags)
    cache.ensure_table("installed_libraries")[ library_name ] = true
    save_cache
  else
    throw Error( "Library not installed: '$'." (library_name) )
  endIf


endRoutine

routine library_flags( library:Value )->String
  if (not cache//installed_libraries.contains(library//name))
    install_library( library )
  endIf

  local result = Process.run( "pkg-config --libs " + library//package )
  if (result.exit_code == 0)
    local flags = result.output_string.trimmed
    return flags
  else
    cache//installed_libraries.remove( library//name )
    save_cache
    return library_flags( library )
  endIf
endRoutine

routine scan_and_rewrite( file:File, dependencies=null:StringLookupList, &skip_rewrite, &skip_directives, &dependencies_only )
  # Note: the organization and usage of this method has become inelegant over time. Could use a refactoring.
  if (not file.exists) return

  local writer : PrintWriter
  if (not skip_rewrite) writer = PrintWriter( File(".rogo/$"(file.filename)).writer )
  forEach (original_line in LineReader(file))
    local line = original_line.trimmed
    if (not skip_directives)
      if (line.begins_with("#$"))
        local cmd = line.rightmost( -2 )
        local args = cmd.after_first( "=" ).trimmed
        cmd = cmd.before_first( "=" ).trimmed.to_lowercase

        which (cmd.before_first('('))
          case "config", "roguec"
            if (not dependencies_only)
              if (args.begins_with('"')) args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              config[ cmd ] = args
            endIf

          case "libraries"
            if (args.count and not dependencies_only)
              local parser = JSONParser( Scanner(args) )
              parser.consume_spaces
              while (parser.has_another)
                local name = parse_filepath( parser )
                local entry = @{ name:name }
                config.ensure_list( cmd ).add( entry )
                parser.consume_spaces
                entry//package = name.before_first( '-' )  # default name is e.g. libpng-dev -> libpng
                if (parser.consume('('))
                  parser.consume_spaces
                  while (parser.has_another)
                    if (parser.consume(')')) escapeWhile
                    local key = parser.parse_identifier
                    parser.consume_spaces
                    if (parser.consume(':'))
                      parser.consume_spaces
                      local value = parse_filepath( parser )
                      entry[ key ] = value
                    else
                      # An identifier with no mapped value is treated as the package name
                      entry//package = key
                    endIf
                    parser.consume_spaces
                    parser.consume( ',' )
                    parser.consume_spaces
                  endWhile
                endIf
                parser.consume_spaces
              endWhile
            endIf

          case "dependencies"
            if (dependencies)
              if (args.begins_with('"'))       args = args.after_first('"').before_last('"')
              elseIf (args.begins_with('\'')) args = args.after_first('\'').before_last('\'')
              dependencies.add( args )
              is_cache_modified = true
            endIf

          others
            if (not dependencies_only)
              # Join into single space-separated string
              if (config.contains(cmd))
                config[ cmd ] = "$ $" (config[ cmd ],args)
              else
                config[ cmd ] = args
              endIf
            endIf

        endWhich
      endIf
    endIf

    if (not skip_rewrite)
      line = original_line
      local dollar = line.locate( '$' )
      while (dollar.exists)
        if (line.contains_at("$LIBRARY_FLAGS(",dollar.value))
          local close_paren = line.locate( ')', dollar.value + 1 )
          if (close_paren.exists)
            local replacement = ""
            forEach (library_name in line.from(dollar.value,close_paren.value-1).after_first('(').split(','))
              library_name = library_name.trimmed
              block
                forEach (lib in config//libraries)
                  if (lib//name == library_name)
                    if (replacement.count > 0) replacement += " "
                    replacement += library_flags( lib )
                    escapeBlock
                  endIf
                endForEach
              endBlock
            endForEach
            line = "$$$" (line.before(dollar.value),replacement,line.after(close_paren.value))
          endIf
        endIf
        dollar = line.locate( '$', dollar.value+1 )
      endWhile
      writer.println( line )
    endIf
  endForEach
  if (not skip_rewrite) writer.close

endRoutine

routine parse_filepath( parser:JSONParser )->String
  if (parser.next_is('"')) return parser.parse_string

  local buffer = StringBuilder()
  while (parser.has_another and not " \n()".contains(parser.peek)) buffer.print( parser.read )

  if (buffer.count == 0) buffer.print( parser.read )

  return buffer->String
endRoutine
